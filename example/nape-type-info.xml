<haxe>
	<class path="Array" params="T" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win/std/js/_std/Array.hx" extern="1">
		<splice public="1" set="method">
			<f a="pos:len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc><![CDATA[Removes [len] elements from [this] Array, starting at and including
		[pos], an returns them.
		
		This operation modifies [this] Array in place.
		
		If [len] is < 0 or [pos] exceeds [this].length, the result is the empty
		Array [].
		
		If [pos] is negative, its value is calculated from the end	of [this]
		Array by [this].length + [pos]. If this yields a negative value, 0 is
		used instead.
		
		If the sum of the resulting values for [len] and [pos] exceed
		[this].length, this operation will affect the elements from [pos] to the
		end of [this] Array.
		
		The length of the returned Array is equal to the new length of [this]
		Array subtracted from the original length of [this] Array. In other
		words, each element of the original [this] Array either remains in
		[this] Array or becomes an element of the returned Array.]]></haxe_doc>
		</splice>
		<push public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Adds the element [x] at the end of [this] Array and returns the offset
		it was added at.
		
		This operation modifies [this] Array in place.
		
		[this].length will increase by 1.</haxe_doc>
		</push>
		<pop public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>Removes the last element of [this] Array and returns it.
		
		This operation modifies [this] Array in place.
		
		If [this] has at least one element, [this].length will decrease by 1.
		
		If [this] is the empty Array [], null is returned and the length remains
		0.</haxe_doc>
		</pop>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of [this] Array.</haxe_doc>
		</length>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Array.</haxe_doc>
		</new>
		<haxe_doc>An Array is a storage for values. You can access it using indexes or
	with its API. On the server side, it's often better to use a [List] which
	is less memory and CPU consuming, unless you really need indexed access.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Class" params="T" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win/std/Class.hx">
		<haxe_doc>An abstract type that represents a Class.
	
	See [Type] for the haXe Reflection API.</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<class path="Date" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win/std/js/_std/Date.hx" extern="1">
		<now public="1" get="inline" set="null" line="38" static="1">
			<f a=""><c path="Date"/></f>
			<haxe_doc>Returns a Date representing the current local time.</haxe_doc>
		</now>
		<fromTime public="1" get="inline" set="null" line="42" static="1">
			<f a="t">
				<x path="Float"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Returns a Date from timestamp [t].</haxe_doc>
		</fromTime>
		<fromString public="1" get="inline" set="null" line="48" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Returns a Date from a formated string [s], with the following accepted
		formats:
			- [YYYY-MM-DD hh:mm:ss]
			- [YYYY-MM-DD]
			- [hh:mm:ss]
		The first two formats are expressed in local time, the third in UTC
		Epoch.</haxe_doc>
		</fromString>
		<toString public="1" get="inline" set="null" line="34">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of [this] Date, by using the
		standard format [YYYY-MM-DD HH:MM:SS]. See [DateTools.format] for
		other formating rules.</haxe_doc>
		</toString>
		<getDay public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of the week of [this] Date (0-6 range).</haxe_doc>
		</getDay>
		<getDate public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of [this] Date (1-31 range).</haxe_doc>
		</getDate>
		<getMonth public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the month of [this] Date (0-11 range).</haxe_doc>
		</getMonth>
		<getFullYear public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the full year of [this] Date (4-digits).</haxe_doc>
		</getFullYear>
		<getSeconds public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the seconds of the [this] Date (0-59 range).</haxe_doc>
		</getSeconds>
		<getMinutes public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the minutes of [this] Date (0-59 range).</haxe_doc>
		</getMinutes>
		<getHours public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the hours of [this] Date (0-23 range).</haxe_doc>
		</getHours>
		<getTime public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the timestamp of the date. It might only have a per-second
		precision depending on the platforms.</haxe_doc>
		</getTime>
		<new public="1" set="method">
			<f a="year:month:day:hour:min:sec">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new date object from the given arguments.
		
		The behaviour of a Date instance is only consistent across platforms if
		the the arguments describe a valid date.
			- month: 0 to 11
			- day: 1 to 31
			- hour: 0 to 23
			- min: 0 to 59
			- sec: 0 to 59</haxe_doc>
		</new>
		<haxe_doc>The Date class provides a basic structure for date and time related
	information. Date instances can be created by
		- new Date() for a specific date,
		- Date.now() to obtain information about the current time,
		- Date.fromTime() with a given timestamp or
		- Date.fromString() by parsing from a String.
	
	There is some extra functions available in the [DateTools] class.
	
	In the context of haxe dates, a timestamp is defined as the number of
	milliseconds elapsed since 1st January 1970.</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<abstract path="Enum" params="T" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win/std/Enum.hx">
		<haxe_doc>An abstract type that represents an Enum type.
	
	The corresponding enum instance type is EnumValue.
	
	See [Type] for the haXe Reflection API.</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="EnumValue" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win/std/EnumValue.hx">
		<haxe_doc>An abstract type that represents any enum value.
	See [Type] for the haXe Reflection API.</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<class path="Math" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win/std/Math.hx" extern="1">
		<PI public="1" set="null" static="1"><x path="Float"/></PI>
		<NEGATIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special Float constant which denotes negative infinity.
		
		For example, this is the result of -1.0 / 0.0.
		
		Operations with NEGATIVE_INFINITY as an operand may result in
		Operations with NEGATIVE_INFINITY as an operand may result in
		NEGATIVE_INFINITY, POSITIVE_INFINITY or NaN. For detailed information,
		see ...
		
		If this constant is converted to an Int, e.g. through Std.int(), the
		result is unspecified.</haxe_doc>
		</NEGATIVE_INFINITY>
		<POSITIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special Float constant which denotes negative infinity.
		
		For example, this is the result of 1.0 / 0.0.
		
		Operations with POSITIVE_INFINITY as an operand may result in
		NEGATIVE_INFINITY, POSITIVE_INFINITY or NaN. For detailed information,
		see ...
	
		If this constant is converted to an Int, e.g. through Std.int(), the
		result is unspecified.</haxe_doc>
		</POSITIVE_INFINITY>
		<NaN public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special Float constant which denotes an invalid number.
		
		NaN stands for "Not a Number". It occurs when a mathematically incorrect
		operation is executed, such as taking the square root of a negative
		number: Math.sqrt(-1).
		
		All further operations with NaN as an operand will result in NaN.
		
		If this constant is converted to an Int, e.g. through Std.int(), the
		result is unspecified.
		
		In order to test if a value is NaN, you should use Math.isNaN() function.
		
		(Php) In PHP versions prior to 5.3.1 VC 9 there may be unexpected
		results when performing arithmetic operations with NaN on Windows, see:
			https://bugs.php.net/bug.php?id=42143</haxe_doc>
		</NaN>
		<sin public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric sine of [v].
		
		The unit of [v] is radians.
		
		If [v] is NaN or infinite, the result is NaN.</haxe_doc>
		</sin>
		<cos public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric cosine of [v].
		
		The unit of [v] is radians.
		
		If [v] is NaN or infinite, the result is NaN.</haxe_doc>
		</cos>
		<acos public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></acos>
		<atan2 public="1" set="method" static="1"><f a="y:x">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></atan2>
		<sqrt public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the square root of [v].
		
		If [v] is negative (including NEGATIVE_INFINITY) or NaN, the result is
		NaN.
		
		If [v] is POSITIVE_INFINITY, the result is POSITIVE_INFINITY.
		
		If [v] is 0.0, the result is 0.0.</haxe_doc>
		</sqrt>
		<isFinite public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if [f] is a finite number.
		
		If [f] is POSITIVE_INFINITY, NEGATIVE_INFINITY or NaN, the result is
		false.
		
		Otherwise the result is true.</haxe_doc>
		</isFinite>
		<isNaN public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if [f] is not a valid number.
		
		If [f] is NaN, the result is true.
		
		Otherwise the result is false. In particular, both POSITIVE_INFINITY and
		NEGATIVE_INFINITY are not considered NaN.</haxe_doc>
		</isNaN>
		<haxe_doc>This class defines mathematical functions and constants.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="Reflect" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win/std/js/_std/Reflect.hx">
		<field public="1" get="inline" set="null" line="28" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Returns the value of the field named [field] on object [o].
		
		If [o] is not an object or has no field named [field], the result is
		null.
		
		If the field is defined as a property, its accessors are ignored. Refer
		to [Reflect.getProperty()] for a function supporting property accessors.
		
		If [field] is null, the result is unspecified.</haxe_doc>
		</field>
		<fields public="1" set="method" line="55" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the fields of structure [o].
		
		This method is only guaranteed to work on anonymous structures. Refer to
		[Type.getInstanceFields()] for a function supporting class instances.
		
		If [o] is null, the result is unspecified.</haxe_doc>
		</fields>
		<copy public="1" params="T" set="method" line="95" static="1">
			<f a="o">
				<c path="copy.T"/>
				<c path="copy.T"/>
			</f>
			<haxe_doc>Copies the fields of structure [o].
		
		This is only guaranteed to work on anonymous structures.
		
		If [o] is null, the result is unspecified.</haxe_doc>
		</copy>
		<haxe_doc>The Reflect API is a way to manipulate values dynamicly through an
	abstract interface in an untyped manner. Use with care.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="String" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win/std/js/_std/String.hx" extern="1">
		<fromCharCode public="1" set="method" static="1">
			<f a="code">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the String corresponding to the character code [code].
		
		If [code] is negative or has another invalid value, the result is
		unspecified.</haxe_doc>
		</fromCharCode>
		<substr public="1" get="inline" set="null" line="39">
			<f a="pos:?len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns [len] characters of [this] String, starting at position [pos].
		
		If [len] is omitted, all characters from position [pos] to the end of
		[this] String are included.
		
		If [pos] is negative, its values is calculated from the end	of [this]
		String by [this].length + [pos]. If this yields a negative value, 0 is
		used instead.
		
		If [len] is negative, the result is unspecified.</haxe_doc>
		</substr>
		<charCodeAt public="1" get="inline" set="null" line="35">
			<f a="index">
				<x path="Int"/>
				<t path="Null"><x path="Int"/></t>
			</f>
			<haxe_doc>Returns the character code at position [index] of [this] String.
		
		If [index] is negative or exceeds [this].length, null is returned.
		
		To obtain the character code of a single character, "x".code can be used
		instead to inline the character code at compile time. Note that this
		only works on String literals of length 1.</haxe_doc>
		</charCodeAt>
		<substring public="1" set="method">
			<f a="startIndex:?endIndex">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the part of [this] String from [startIndex] to [endIndex].
		
		If [endIndex] is omitted, [this].length is used instead.
		
		If [startIndex] or [endIndex] are negative, 0 is used instead.
		
		If [startIndex] exceeds [endIndex], they are swapped.</haxe_doc>
		</substring>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the String itself.</haxe_doc>
		</toString>
		<split public="1" set="method">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Splits [this] String at each occurence of [delimiter].
		
		If [delimiter] is the empty String "", [this] String is split into an
		Array of [this].length elements, where the elements correspond to the
		characters of [this] String.
		
		If [delimiter] is not found within [this] String, the result is an Array
		with one element, which equals [this] String.
		
		If [delimiter] is null, the result is unspecified.
		
		Otherwise, [this] String is split into parts at each occurence of
		[delimiter]. If [this] String starts (or ends) with [delimiter}, the
		result Array contains a leading (or trailing) empty String "" element.
		Two subsequent delimiters also result in an empty String "" element.</haxe_doc>
		</split>
		<lastIndexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the rightmost occurence of [str] within [this]
		String.
		
		If [startIndex] is given, the search is performed within the substring
		of [this] String from 0 to [startIndex]. Otherwise the search is
		performed within [this] String. In either case, the returned position
		is relative to the beginning of [this] String.
		
		If [str] cannot be found, -1 is returned.</haxe_doc>
		</lastIndexOf>
		<indexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the leftmost occurence of [str] within [this]
		String.
		
		If [startIndex] is given, the search is performed within the substring
		of [this] String starting from [startIndex]. Otherwise the search is
		performed within [this] String. In either case, the returned position
		is relative to the beginning of [this] String.
		
		If [str] cannot be found, -1 is returned.</haxe_doc>
		</indexOf>
		<charAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the character at position [index] of [this] String.
		
		If [index] is negative or exceeds [this].length, the empty String ""
		is returned.</haxe_doc>
		</charAt>
		<toLowerCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of [this] String are lower case.
		
		Affects the characters [A-Z]. Other characters remain unchanged.</haxe_doc>
		</toLowerCase>
		<toUpperCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of [this] String are upper case.
		
		Affects the characters [a-z]. Other characters remain unchanged.</haxe_doc>
		</toUpperCase>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The number of characters in [this] String.</haxe_doc>
		</length>
		<new public="1" set="method">
			<f a="string">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a copy from a given String.</haxe_doc>
		</new>
		<haxe_doc>The basic String class.
	
	A haxe String is immutable, it is not possible to modify individual
	characters. No method of this class changes the state of [this] String.
	
	Strings can be constructed using the string literal syntax "string value".
	
	String can be concatenated by using the + operator. If an operand is not a
	String, it is passed through Std.string() first.</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<class path="Std" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win/std/js/_std/Std.hx">
		<string public="1" set="method" line="31" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Converts any value to a String.

		If s is of String, Int, Float or Bool, its value is returned.

		If s is an instance of a class and that class or one of its parent classes has
		a toString() method, that method is called. If no such method is present, the result
		is unspecified.

		If s is an enum constructor without argument, the constructor's name is returned. If
		arguments exists, the constructor's name followed by the String representations of
		the arguments is returned.

		If s is a structure, the field names along with their values are returned. The field order
		and the operator separating field names and values are unspecified.

		If s is null, "null" is returned.</haxe_doc>
		</string>
		<haxe_doc>The Std class provides standard methods for manipulating basic types.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":keepInit"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Void" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win/std/StdTypes.hx" module="StdTypes">
		<haxe_doc>The standard Void type. Only [null] values can be of the type [Void].</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<abstract path="Float" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win/std/StdTypes.hx" module="StdTypes">
		<haxe_doc>The standard Float type, this is a double-precision IEEE 64bit float.</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Int" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win/std/StdTypes.hx" module="StdTypes">
		<to><x path="Float"/></to>
		<haxe_doc>The standard Int type. Its precision depends on the platform.</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Null" params="T" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win/std/StdTypes.hx" module="StdTypes">
		<c path="Null.T"/>
		<haxe_doc>[Null] can be useful in two cases. In order to document some methods
	that accepts or can return a [null] value, or for the Flash9 compiler and AS3
	generator to distinguish between base values that can be null and others that
	can't.</haxe_doc>
	</typedef>
	<abstract path="Bool" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win/std/StdTypes.hx" module="StdTypes">
		<haxe_doc>The standard Boolean type is represented as an enum with two choices.</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Dynamic" params="T" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win/std/StdTypes.hx" module="StdTypes">
		<haxe_doc>Dynamic is an internal compiler type which has special behavior.
	See the haXe language reference for more informations.</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Iterator" params="T" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win/std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method">
				<f a=""><c path="Iterator.T"/></f>
				<haxe_doc>Returns the current item of the Iterator and advances to the next one.
		
		This method is not required to check hasNext() first. A call to this
		method while hasNext() is false yields unspecified behavior.</haxe_doc>
			</next>
			<hasNext set="method">
				<f a=""><x path="Bool"/></f>
				<haxe_doc>Returns false if the iteration is complete, true otherwise.
		
		Usually iteration is considered to be complete if all elements of the
		underlying data structure were handled through calls to next(). However,
		in custom iterators any logic may be used to determine the completion
		state.</haxe_doc>
			</hasNext>
		</a>
		<haxe_doc>An Iterator is a structure that permits iteration over elements of type T.

	Any class with matching hasNext and next fields is considered an Iterator
	and can then be used e.g. in for-loops. This makes it easy to implement
	custom iterators.</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win/std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>An Iterable is a data structure which has an iterator() method.
	See [Lambda] for generic functions on iterable structures.</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win/std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>ArrayAccess is used to indicate a class that can be accessed using brackets.
	The type parameter represent the type of the elements stored.</haxe_doc></class>
	<class path="StringTools" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win/std/StringTools.hx">
		<hex public="1" set="method" line="310" static="1">
			<f a="n:?digits">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encodes [n] into a hexadecimal representation.

		If [digits] is specified, the resulting String is padded with "0" until
		its length equals [digits].</haxe_doc>
		</hex>
		<haxe_doc>This class provides advanced methods on Strings. It is ideally used with
	'using StringTools' and then acts as an extension to the String class.

	If the first argument to any of the methods is null, the result is
	unspecified.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.EnumTools" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win/std/haxe/EnumTools.hx" extern="1">
		<getName public="1" params="T" get="inline" set="null" line="41" static="1">
			<f a="e">
				<x path="Enum"><c path="getName.T"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum [e], including its path.
		
		If [e] is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:
			pack1.pack2.(...).packN.EnumName
		If [e] is a sub-type of a haxe module, that module is not part of the
		package structure.
			
		If [e] has no package, the enum name is returned.
		
		If [e] is null, the result is unspecified.
		
		The enum name does not include any type parameters.</haxe_doc>
		</getName>
		<createByName public="1" params="T" get="inline" set="null" line="54" static="1">
			<f a="e:constr:?params">
				<x path="Enum"><c path="createByName.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createByName.T"/>
			</f>
			<haxe_doc>Creates an instance of enum [e] by calling its constructor [constr] with
		arguments [params].
		
		If [e] or [constr] is null, or if enum [e] has no constructor named
		[constr], or if the number of elements in [params] does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createByName>
		<createByIndex public="1" params="T" get="inline" set="null" line="70" static="1">
			<f a="e:index:?params">
				<x path="Enum"><c path="createByIndex.T"/></x>
				<x path="Int"/>
				<c path="Array"><d/></c>
				<c path="createByIndex.T"/>
			</f>
			<haxe_doc>Creates an instance of enum [e] by calling its constructor number
		[index] with arguments [params].
		
		The constructor indices are preserved from haxe syntax, so the first
		declared is index 0, the next index 1 etc.
		
		If [e] or [constr] is null, or if enum [e] has no constructor named
		[constr], or if the number of elements in [params] does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createByIndex>
		<createAll public="1" params="T" get="inline" set="null" line="87" static="1">
			<f a="e">
				<x path="Enum"><c path="createAll.T"/></x>
				<c path="Array"><c path="createAll.T"/></c>
			</f>
			<haxe_doc>Returns a list of all constructors of enum [e] that require no
		arguments.
		
		This may return the empty Array [] if all constructors of [e] require
		arguments.
		
		Otherwise an instance of [e] constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.
		
		If [e] is null, the result is unspecified.</haxe_doc>
		</createAll>
		<getConstructors public="1" params="T" get="inline" set="null" line="99" static="1">
			<f a="e">
				<x path="Enum"><c path="getConstructors.T"/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the names of all constructors of enum [e].
		
		The order of the constructor names in the returned Array is preserved
		from the original syntax.
		
		If [c] is null, the result is unspecified.</haxe_doc>
		</getConstructors>
	</class>
	<class path="haxe.EnumValueTools" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win/std/haxe/EnumTools.hx" module="haxe.EnumTools" extern="1">
		<equals public="1" params="T" get="inline" set="null" line="114" static="1">
			<f a="a:b">
				<c path="equals.T"/>
				<c path="equals.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Recursively compares two enum instances [a] and [b] by value.
		
		Unlike [a] == [b], this function performs a deep equality check on the
		arguments of the constructors, if exists.
		
		If [a] or [b] are null, the result is unspecified.</haxe_doc>
		</equals>
		<getName public="1" get="inline" set="null" line="125" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor name of enum instance [e].
		
		The result String does not contain any constructor arguments.
		
		If [e] is null, the result is unspecified.</haxe_doc>
		</getName>
		<getParameters public="1" get="inline" set="null" line="139" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns a list of the constructor arguments of enum instance [e].
		
		If [e] has no arguments, the result is [].
		
		Otherwise the result are the values that were used as arguments to [e],
		in the order of their declaration.
		
		If [e] is null, the result is unspecified.</haxe_doc>
		</getParameters>
		<getIndex public="1" get="inline" set="null" line="151" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of enum instance [e].
		
		This corresponds to the original syntactic position of [e]. The index of
		the first declared constructor is 0, the next one is 1 etc.
		
		If [e] is null, the result is unspecified.</haxe_doc>
		</getIndex>
	</class>
	<typedef path="haxe.PosInfos" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win/std/haxe/PosInfos.hx">
		<a>
			<methodName><c path="String"/></methodName>
			<lineNumber><x path="Int"/></lineNumber>
			<fileName><c path="String"/></fileName>
			<customParams>
				<c path="Array"><d/></c>
				<meta><m n=":optional"/></meta>
			</customParams>
			<className><c path="String"/></className>
		</a>
		<haxe_doc>PosInfos is a magic type which can be used to generate position information
	into the output for debugging use.
	
	If a function has a final optional argument of this type, i.e.
	(..., ?pos:haxe.PosInfos), each call to that function which does not assign
	a value to that argument has its position added as call argument.
	
	This can be used to track positions of calls in e.g. a unit testing
	framework.</haxe_doc>
	</typedef>
	<class path="js.Boot" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win/std/js/Boot.hx">
		<__string_rec set="method" line="75" static="1">
			<f a="o:s">
				<a>
					<toString set="null"><f a=""><c path="String"/></f></toString>
					<length set="null"><x path="Int"/></length>
					<hasOwnProperty set="null"><f a="">
	<c path="String"/>
	<x path="Bool"/>
</f></hasOwnProperty>
					<__enum__ set="null"><x path="Bool"/></__enum__>
				</a>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":ifFeature"><e>"has_enum"</e></m></meta>
		</__string_rec>
		<__interfLoop set="method" line="147" static="1"><f a="cc:cl">
	<d/>
	<d/>
	<x path="Bool"/>
</f></__interfLoop>
		<__instanceof set="method" line="162" static="1">
			<f a="o:cl">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":ifFeature"><e>"typed_catch"</e></m></meta>
		</__instanceof>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="nape.Config" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/Config.hx">
		<epsilon public="1" line="15" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Generic epsilon value for float comparisons
     * <br/><br/>
     * @default 1e-8]]></haxe_doc>
		</epsilon>
		<fluidAngularDragFriction public="1" line="27" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Parameter used in computing shape fluid angular drag coeffecient.
     * <br/><br/>
     * Defines the contribution to the drag coeffecient due to Material dynamicFriction
     * <br/><br/>
     * This global value must be set as the very first thing to ensure all Shapes
     * use your intended value.
     * <br/><br/>
     * This parameter has units kg/px
     * @default 2.5 kg/px]]></haxe_doc>
		</fluidAngularDragFriction>
		<fluidAngularDrag public="1" line="40" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Parameter used in computing shape fluid angular drag coeffecient.
     * <br/><br/>
     * Defines the contribution to the drag coeffecient due to shape's surface
     * area rotating into a fluid.
     * <br/><br/>
     * This global value must be set as the very first thing to ensure all Shapes
     * use your intended value.
     * <br/><br/>
     * This parameter has units kg/px
     * @default 100kg/px]]></haxe_doc>
		</fluidAngularDrag>
		<fluidVacuumDrag public="1" line="53" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Parameter used in computing fluid drags.
     * <br/><br/>
     * Defines an added weight for scaling the contribution of forward drag due
     * to leaving a vaccuum behind the shape pulling it back.
     * <br/><br/>
     * This global value must be set as the very first thing to ensure all Shapes
     * use your intended value.
     * <br/><br/>
     * This parameter has no units.
     * @default 0.5]]></haxe_doc>
		</fluidVacuumDrag>
		<fluidLinearDrag public="1" line="62" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Parameter used in computing shapes linear drag in fluid.
     * <br/><br/>
     * Used in determining the amount of linear drag for the shape based on forward profile.
     * <br/><br/>
     * This parameter has units kg/px
     * @default 0.5kg/px]]></haxe_doc>
		</fluidLinearDrag>
		<collisionSlop public="1" line="69" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Amount of overlap permitted between Shapes for collisions.
     * <br/><br/>
     * This parameter has units of pixels.
     * @default 0.2px]]></haxe_doc>
		</collisionSlop>
		<collisionSlopCCD public="1" line="77" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Amount of overlap permitted between Shapes before CCD kicks in.
     * <br/><br/>
     * This parameter has units of pixels, and should always be larger
     * than collisionSlop parameter.
     * @default 0.5px]]></haxe_doc>
		</collisionSlopCCD>
		<distanceThresholdCCD public="1" line="88" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Biased distance treshold for CCD collisions.
     * <br/><br/>
     * In CCD collision routines, two Shapes will be considered intersecting
     * when the distance between them + collisionSlopCCD falls below this
     * value.
     * <br/><br/>
     * This parameter has units of pixels, and should always be > 0
     * @default 0.05px]]></haxe_doc>
		</distanceThresholdCCD>
		<staticCCDLinearThreshold public="1" line="104" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Linear sweep threshold-ratio for static CCD collisions
     * <br/><br/>
     * In deciding what non-bullet objects should be collided continuously against
     * static/kinematic objects, the linear speed of the body is considered.
     * <code>
     * ccdCollide if: bodyLinearSpeed * deltaTime > threshold * bodyRadius
     * </code>
     * Intuitively, a value of 0.5 would mean that a body, in the worst case scenario
     * will be permitted to move half of its width in a single time step, before CCD
     * is enabled for this reason.
     * <br/><br/>
     * This parameter has no units.
     * @default 0.05]]></haxe_doc>
		</staticCCDLinearThreshold>
		<staticCCDAngularThreshold public="1" line="121" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Angular sweep threshold for static CCD collisions
     * <br><br/>
     * In deciding what non-bullet objects should be collided continuously against
     * static/kinematic objects, the angular speed of the body is considered.
     * <code>
     * ccdCollide if: bodyAngularSpeed * deltaTime > threshold
     * </code>
     * Intuitively, a value of 0.5 would mean that a body would have to rotate more than
     * 0.5 radians in a single time step, before CCD is enabled for this reason. Noting that
     * at 60fps physics, the body would need an angularVel greater than 30rad/s for this
     * limit of 0.5 to be reached; the default is far smaller.
     * <br/><br/>
     * This parameter has units of rad.
     * @default 0.005rad]]></haxe_doc>
		</staticCCDAngularThreshold>
		<bulletCCDLinearThreshold public="1" line="136" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Linear sweep threshold-ratio for bullet CCD collisions
     * <br/><br/>
     * A dynamic body marked as a bullet, will not necessarigly always be collided
     * with continuously.
     * <br/><br/>
     * Should a body be moving, or rotating fast enough to pass the tests determined
     * by staticCCD#Threshold parameters, and is marked as a bullet, it must then
     * have its velocities checked against the equivalent bullet thresholds to actually
     * be collided continuously against other dynamic bodies too.
     * <br/><br/>
     * This parameter has no units.
     * @default 0.125]]></haxe_doc>
		</bulletCCDLinearThreshold>
		<bulletCCDAngularThreshold public="1" line="145" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Angular sweep threshold for bullet CCD collisions.
     * <br/><br/>
     * See description of bulletCCDLinearThreshold.
     * <br/><br/>
     * This parameter has units of rad.
     * @default 0.0125rad]]></haxe_doc>
		</bulletCCDAngularThreshold>
		<dynamicSweepLinearThreshold public="1" line="157" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Relative linear threshold for dynamic-dynamic sweeps.
     * <br/><br/>
     * When performing dynamic-dynamic sweep of Body shapes during CCD collision phase,
     * should the relative velocity of the bodies fall beneath this magnitude, they
     * may be considered (based on angular velocities also) to be moving together, and
     * this specific CCD test will be skipped.
     * <br/><br/>
     * This parameter has units of px/s
     * @default 17px/s]]></haxe_doc>
		</dynamicSweepLinearThreshold>
		<dynamicSweepAngularThreshold public="1" line="174" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Relative angular bias threshold for dynamic-dynamic sweeps.
     * <br/><br/>
     * When performing dynamic-dynamic sweep of Body shapes during CCD collision phase,
     * should the relative angular velocity (weighted by the shape bias values) fall
     * beneath this magnitude, they may be considered (based on linear velocities also) to
     * be moving together, and this specific CCD test will be skipped.
     * <br/><br/>
     * The shape bias, is an internal value which indicates the 'amount of radius' of
     * a shape about the centre of rotation that can be considered to change under rotations.
     * eg: A circle at origin has a bias of 0 (Its rotation has no effect on sweeps)
     * whilst A circle far from the origin may have a large bias.
     * <br/><br/>
     * This parameter has units of px.rad/s
     * @default 0.6px.rad/s]]></haxe_doc>
		</dynamicSweepAngularThreshold>
		<angularCCDSlipScale public="1" line="188" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Angular velocity scaling during CCD slips.
     * <br/><br/>
     * In rare cases, a Body can be moving in such a way that we fail to compute a perfect
     * time of impact; generally when a thin box-like object is rotating very quickly. The
     * time of impact solver in Nape attempts to avoid impacts which are seperating; so that
     * we can catch true impact times; but in a 'slip' case we are unable to achieve this and
     * to avoid a possible tunneling from the other side during later operations we will in
     * these rare cases scale down the angular velocity of a Body by this parameter.
     * <br/><br/>
     * This parameter has no units.
     * @default 0.75]]></haxe_doc>
		</angularCCDSlipScale>
		<arbiterExpirationDelay public="1" line="200" static="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* Expiration delay length for collision arbiter destruction.
     * <br/><br/>
     * In unstable physics conditions, two colliding shapes may jitter such as to constantly
     * seperate, and then come back together again. This parameter controls the number of time
     * steps during which we will delay this destruction so that cached impulse values may
     * persist and improve stability of strenuous simulations.
     * <br/><br/>
     * This parameter has units of 'steps' I suppose.
     * @default 6steps]]></haxe_doc>
		</arbiterExpirationDelay>
		<staticFrictionThreshold public="1" line="210" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Contact velocity threshold for static-dynamic friction
     * <br/><br/>
     * This is the threshold on projected contact velocities at which Nape will use
     * dynamic friction Mateiral values, in place of static friction Material values.
     * <br/><br/>
     * This parameter has units of px/s
     * @default 2px/s]]></haxe_doc>
		</staticFrictionThreshold>
		<elasticThreshold public="1" line="222" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Contact velocity threshold for elastic collisions
     * <br/><br/>
     * This is the threshold on weighted projected normal-contact velocities at which Nape will
     * decide to stop using elastic collisions. Nape will take the normal velocities at contact
     * and scale by the combined elasticity coeffecient for the Arbiter, if this value falls
     * below the threshold, then elasticity is ignored for stability in stacking.
     * <br/><br/>
     * This parameter has units of px/s
     * @default 20px/s]]></haxe_doc>
		</elasticThreshold>
		<sleepDelay public="1" line="234" static="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* Sleep delay for stationary bodies.
     * <br/><br/>
     * By default, Nape considers a body to be stationary even if it has a very small linear
     * or angular velocity. This parameter controls how many steps such a Body will continue
     * to be simulated for, before being put to sleep (Assuming everything else in the island
     * is also stationary for a sufficiently long time).
     * <br/><br/>
     * This parameter has units of 'steps' I suppose.
     * @default 60steps]]></haxe_doc>
		</sleepDelay>
		<linearSleepThreshold public="1" line="244" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Linear speed threshold for sleeping of Bodies.
     * <br/><br/>
     * A body in Nape will be considered stationary only if its linear velocity has magnitude
     * under this threshold.
     * <br/><br/>
     * This parameter has units of px/s
     * @default 0.2px/s]]></haxe_doc>
		</linearSleepThreshold>
		<angularSleepThreshold public="1" line="258" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Angular speed threshold for sleeping of Bodies.
     * <br/><br/>
     * A body in Nape will be considered stationary only if its angular velocity, multiplied
     * by the body radius (never under-estimated) about the origin, falls below this threshold.
     * <br/><br/>
     * The body radius scaling, ensures that a very large body needs to be rotating more slowly
     * to be considered stationary than a very small body. Intuitively we're designating this
     * a threshold on the maximum tangentenial velocity of the body due to rotation.
     * <br/><br/>
     * This parameter has units of px.rad/s
     * @default 0.4px.rad/s]]></haxe_doc>
		</angularSleepThreshold>
		<contactBiasCoef public="1" line="269" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Fraction of contact slop resolved per-step for dynamic-dynamic discrete collisions.
     * <br/><br/>
     * This value determines, in the case of two non-continuously colliding dynamic objects
     * the fraction of the contact overlap that will attempt to be resolved during positional
     * iterations.
     * <br/><br/>
     * This parameter has units of 1/'step' I suppose.
     * @default 0.3/step]]></haxe_doc>
		</contactBiasCoef>
		<contactStaticBiasCoef public="1" line="279" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Fraction of contact slop resolved per-step for static/kinematic discrete collisions.
     * <br/><br/>
     * See description of contactBiasCoef; this is the coeffecient for non-continuous collisions
     * between a dynamic, and a static or kinematic object.
     * <br/><br/>
     * This parameter has units of 1/'step' I suppose.
     * @default 0.6/step]]></haxe_doc>
		</contactStaticBiasCoef>
		<contactContinuousBiasCoef public="1" line="289" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Fraction of contact slop resolved per-step for dynamic-dynamic continuous collisions.
     * <br/><br/>
     * See description of contactBiasCoef; this is the coeffecient for continuous collisions
     * between two dynamic bodies.
     * <br/><br/>
     * This parameter has units of 1/'step' I suppose.
     * @default 0.4/step]]></haxe_doc>
		</contactContinuousBiasCoef>
		<contactContinuousStaticBiasCoef public="1" line="299" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Fraction of contact slop resolved per-step for static/kinematic continuous collisions.
     * <br/><br/>
     * See description of contactBiasCoef; this is the coeffecient for continuous collisions
     * between a dynamic, and a static or kinematic object.
     * <br/><br/>
     * This parameter has units of 1/'step' I suppose.
     * @default 0.5/step]]></haxe_doc>
		</contactContinuousStaticBiasCoef>
		<constraintLinearSlop public="1" line="309" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Amount of linear slop permitted in constraints.
     * <br/><br/>
     * A constraint will be considered to be 'relaxed' during positional iterations
     * only if the linear error falls below this threshold.
     * <br/><br/>
     * Assuming a 'sensible' constraint, this has units of px
     * @default 0.1px]]></haxe_doc>
		</constraintLinearSlop>
		<constraintAngularSlop public="1" line="319" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Amount of angular slop permitted in constraints.
     * <br/><br/>
     * A constraint will be considered to be 'relaxed' during positional iterations
     * only if the angular error falls below this threshold.
     * <br/><br/>
     * Assuming a 'sensible' constraint, this has units of rad
     * @default 1e-3rad]]></haxe_doc>
		</constraintAngularSlop>
		<illConditionedThreshold public="1" line="332" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Ill-conditioned threshold for 2-contact collision constraints.
     * <br/><br/>
     * This is a threshold on the measure of ill-conditioning of the effective-mass-matrix
     * in a 2-contact collision at which the contact manifold will be forced into a 1-contact
     * constraint. This can occur quite readily when two contact points are almost exactly equal
     * or in certain other conditions where the mathematics quite simply breaks down when using
     * a block solver.
     * <br/><br/>
     * This parameter has no units.
     * @default 2e+8]]></haxe_doc>
		</illConditionedThreshold>
		<new set="method" line="9">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc>* Configuration parameters for Nape</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<typedef path="nape.TArray" params="T" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/TArray.hx">
		<c path="Array"><c path="nape.TArray.T"/></c>
		<haxe_doc><![CDATA[* Platform specific Array type.
 * <br/><br/>
 * For flash10+ This is <code>flash.Vector&lt;T&gt;</code>, and otherwise
 * <code>Array&lt;T&gt;</code>.
 * <pre>
 * #if flash10
 *     typedef TArray&lt;T&gt; = flash.Vector&lt;T&gt;;
 * #else
 *     typedef TArray&lt;T&gt; = Array&lt;T&gt;;
 * #end
 * </pre>]]></haxe_doc>
	</typedef>
	<class path="nape.callbacks.Callback" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/callbacks/Callback.hx">
		<toString public="1" set="method" line="214">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<get_listener get="inline" set="null" line="198"><f a=""><c path="nape.callbacks.Listener"/></f></get_listener>
		<listener public="1" get="accessor" set="null">
			<c path="nape.callbacks.Listener"/>
			<haxe_doc>* The Listener which was responsive for this callback being generated.</haxe_doc>
		</listener>
		<get_event get="inline" set="null" line="190"><f a=""><c path="nape.callbacks.CbEvent"/></f></get_event>
		<event public="1" get="accessor" set="null">
			<c path="nape.callbacks.CbEvent"/>
			<haxe_doc>* CbEvent type this callback was generated for.</haxe_doc>
		</event>
		<zpp_inner public="1">
			<c path="zpp_nape.callbacks.ZPP_Callback"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="204">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Base type for Callback event objects.
 * <br/><br/>
 * Callback objects are automatically reused and you should not keep references
 * to them.]]></haxe_doc>
	</class>
	<class path="nape.callbacks.BodyCallback" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/callbacks/BodyCallback.hx">
		<extends path="nape.callbacks.Callback"/>
		<toString public="1" set="method" line="198" override="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<get_body get="inline" set="null" line="192"><f a=""><c path="nape.phys.Body"/></f></get_body>
		<body public="1" get="accessor" set="null">
			<c path="nape.phys.Body"/>
			<haxe_doc>* Body involved in callback event.</haxe_doc>
		</body>
		<new public="1" set="method" line="184">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Callback object for Body type events.
 * <br/><br/>
 * This, like all other callback objects are automatically reused
 * and you should not keep any reference to them.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.callbacks.Listener" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/callbacks/Listener.hx">
		<toString public="1" set="method" line="276">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<set_space get="inline" set="null" line="257"><f a="space">
	<t path="Null"><c path="nape.space.Space"/></t>
	<t path="Null"><c path="nape.space.Space"/></t>
</f></set_space>
		<get_space get="inline" set="null" line="254"><f a=""><t path="Null"><c path="nape.space.Space"/></t></f></get_space>
		<space public="1" get="accessor" set="accessor">
			<t path="Null"><c path="nape.space.Space"/></t>
			<haxe_doc><![CDATA[* The Space this listener is assigned to.
     * <br/><br/>
     * This value can be set, with setting to null being equivalent to removing
     * the listener from whichever Space it is presently assigned to.
     *
     * @default null]]></haxe_doc>
		</space>
		<set_precedence get="inline" set="null" line="225"><f a="precedence">
	<x path="Int"/>
	<x path="Int"/>
</f></set_precedence>
		<get_precedence get="inline" set="null" line="222"><f a=""><x path="Int"/></f></get_precedence>
		<precedence public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc><![CDATA[* The precedence of this listener.
     * <br/><br/>
     * In any case that there is more than one suitable listener for a situation,
     * the listeners will be ordered by their precedence.
     *
     * @default 0]]></haxe_doc>
		</precedence>
		<set_event get="inline" set="null" line="198"><f a="event">
	<c path="nape.callbacks.CbEvent"/>
	<c path="nape.callbacks.CbEvent"/>
</f></set_event>
		<get_event get="inline" set="null" line="195"><f a=""><c path="nape.callbacks.CbEvent"/></f></get_event>
		<event public="1" get="accessor" set="accessor">
			<c path="nape.callbacks.CbEvent"/>
			<haxe_doc>* The CbEvent this listener responds to.</haxe_doc>
		</event>
		<get_type get="inline" set="null" line="187"><f a=""><c path="nape.callbacks.ListenerType"/></f></get_type>
		<type public="1" get="accessor" set="null">
			<c path="nape.callbacks.ListenerType"/>
			<haxe_doc>* The sub-type of this listener.</haxe_doc>
		</type>
		<zpp_inner public="1">
			<c path="zpp_nape.callbacks.ZPP_Listener"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="237">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc>* Base type for all Nape callback listeners.</haxe_doc>
	</class>
	<class path="nape.callbacks.BodyListener" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/callbacks/BodyListener.hx">
		<extends path="nape.callbacks.Listener"/>
		<set_handler get="inline" set="null" line="211"><f a="handler">
	<f a="">
		<c path="nape.callbacks.BodyCallback"/>
		<x path="Void"/>
	</f>
	<f a="">
		<c path="nape.callbacks.BodyCallback"/>
		<x path="Void"/>
	</f>
</f></set_handler>
		<get_handler get="inline" set="null" line="208"><f a=""><f a="">
	<c path="nape.callbacks.BodyCallback"/>
	<x path="Void"/>
</f></f></get_handler>
		<handler public="1" get="accessor" set="accessor">
			<f a="">
				<c path="nape.callbacks.BodyCallback"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The callback handler for this listener.</haxe_doc>
		</handler>
		<set_options get="inline" set="null" line="197"><f a="options">
	<c path="nape.callbacks.OptionType"/>
	<c path="nape.callbacks.OptionType"/>
</f></set_options>
		<get_options get="inline" set="null" line="194"><f a=""><c path="nape.callbacks.OptionType"/></f></get_options>
		<options public="1" get="accessor" set="accessor">
			<c path="nape.callbacks.OptionType"/>
			<haxe_doc><![CDATA[* The OptionType used to match against Bodies.
     * <br/><br/>
     * When added to the same Space, any Body who's CbType list matches
     * against this OptionType will be issued a callback when the relevant
     * event occurs.]]></haxe_doc>
		</options>
		<zpp_inner_zn public="1">
			<c path="zpp_nape.callbacks.ZPP_BodyListener"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner_zn>
		<new public="1" set="method" line="248">
			<f a="event:options:handler:?precedence">
				<c path="nape.callbacks.CbEvent"/>
				<t path="Null"><d/></t>
				<f a="">
					<c path="nape.callbacks.BodyCallback"/>
					<x path="Void"/>
				</f>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Construct a new BodyListener.
     * <br/><br/>
     * The possible event types are WAKE and SLEEP.
     * <br/><br/>
     * The options argument is typed Dynamic, and is permitted to be either an
     * <code>OptionType</code> or one of:
     * <code>CbType, CbTypeList, Array&lt;CbType&gt;, flash.Vector&lt;CbType&gt;</code>
     * In which case the input CbType's will be used to construct an OptionType
     * whose included types will be the set of CbTypes supplied.
     *
     * @param event The event type to listen for.
     * @param options The OptionType to match Bodys against, passing null
     *                will equate to an empty OptionType.
     * @param handler The callback handler for this listener.
     * @param precedence The precedence of this listener used to sort
     *                   the order of callbacks in the case of more than
     *                   one suitable BodyListener existing for the same
     *                   event on the same Body. (default 0)
     * @return The newly constructed BodyListener
     * @throws # If handler is null.
     * @throws # If the event type is not permitted for this listener.
     * @throws # If options is not of the expected Type.]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Event listener for Body type events.
 * <br/><br/>
 * The events that can be caught are WAKE and SLEEP type events.
 * Theses listeners will only operate on Bodys, not Interactors in general.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.callbacks.CbEvent" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/callbacks/CbEvent.hx">
		<BEGIN public="1" get="accessor" set="null" static="1">
			<c path="nape.callbacks.CbEvent"/>
			<haxe_doc>* BEGIN event corresponds to the start of an interaction</haxe_doc>
		</BEGIN>
		<get_BEGIN get="inline" set="null" line="206" static="1"><f a=""><c path="nape.callbacks.CbEvent"/></f></get_BEGIN>
		<ONGOING public="1" get="accessor" set="null" static="1">
			<c path="nape.callbacks.CbEvent"/>
			<haxe_doc>* ONGOING event corresponds to any step in which an interaction is occuring
     * overlapping with the BEGIN event.</haxe_doc>
		</ONGOING>
		<get_ONGOING get="inline" set="null" line="220" static="1"><f a=""><c path="nape.callbacks.CbEvent"/></f></get_ONGOING>
		<END public="1" get="accessor" set="null" static="1">
			<c path="nape.callbacks.CbEvent"/>
			<haxe_doc>* END event corresponds to the end of an interaction.</haxe_doc>
		</END>
		<get_END get="inline" set="null" line="233" static="1"><f a=""><c path="nape.callbacks.CbEvent"/></f></get_END>
		<WAKE public="1" get="accessor" set="null" static="1">
			<c path="nape.callbacks.CbEvent"/>
			<haxe_doc>* WAKE event corresponds to the waking of a Body or Constraint in the space.</haxe_doc>
		</WAKE>
		<get_WAKE get="inline" set="null" line="246" static="1"><f a=""><c path="nape.callbacks.CbEvent"/></f></get_WAKE>
		<SLEEP public="1" get="accessor" set="null" static="1">
			<c path="nape.callbacks.CbEvent"/>
			<haxe_doc>* SLEEP event corresponds to the sleeping of a Body or Constraint in the space.</haxe_doc>
		</SLEEP>
		<get_SLEEP get="inline" set="null" line="259" static="1"><f a=""><c path="nape.callbacks.CbEvent"/></f></get_SLEEP>
		<BREAK public="1" get="accessor" set="null" static="1">
			<c path="nape.callbacks.CbEvent"/>
			<haxe_doc>* BREAK event corresponds to the breaking of a defined limit on a Constraint.</haxe_doc>
		</BREAK>
		<get_BREAK get="inline" set="null" line="272" static="1"><f a=""><c path="nape.callbacks.CbEvent"/></f></get_BREAK>
		<PRE public="1" get="accessor" set="null" static="1">
			<c path="nape.callbacks.CbEvent"/>
			<haxe_doc>* PRE event corresponds to a special mid-step event that occurs after it is determined
     * that two objects 'will' begin to interact, but before any interaction commences.</haxe_doc>
		</PRE>
		<get_PRE get="inline" set="null" line="286" static="1"><f a=""><c path="nape.callbacks.CbEvent"/></f></get_PRE>
		<toString public="1" set="method" line="189">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<new public="1" set="method" line="181">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc>* Enumeration of possible callback event types.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.callbacks.CbType" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/callbacks/CbType.hx">
		<ANY_BODY public="1" get="accessor" set="null" static="1">
			<c path="nape.callbacks.CbType"/>
			<haxe_doc>* Default CbType given to all Bodys
     *
     * Due to the way the Callback system in Nape works, you can use this
     * CbType to match against 'all'
     * Bodys
     * In a Listener (Assuming you do not 'remove' this type from the object)</haxe_doc>
		</ANY_BODY>
		<get_ANY_BODY get="inline" set="null" line="212" static="1"><f a=""><c path="nape.callbacks.CbType"/></f></get_ANY_BODY>
		<ANY_CONSTRAINT public="1" get="accessor" set="null" static="1">
			<c path="nape.callbacks.CbType"/>
			<haxe_doc>* Default CbType given to all Constraints
     *
     * Due to the way the Callback system in Nape works, you can use this
     * CbType to match against 'all'
     * Constraints
     * In a Listener (Assuming you do not 'remove' this type from the object)</haxe_doc>
		</ANY_CONSTRAINT>
		<get_ANY_CONSTRAINT get="inline" set="null" line="225" static="1"><f a=""><c path="nape.callbacks.CbType"/></f></get_ANY_CONSTRAINT>
		<ANY_SHAPE public="1" get="accessor" set="null" static="1">
			<c path="nape.callbacks.CbType"/>
			<haxe_doc>* Default CbType given to all Shapes
     *
     * Due to the way the Callback system in Nape works, you can use this
     * CbType to match against 'all'
     * Shapes
     * In a Listener (Assuming you do not 'remove' this type from the object)</haxe_doc>
		</ANY_SHAPE>
		<get_ANY_SHAPE get="inline" set="null" line="238" static="1"><f a=""><c path="nape.callbacks.CbType"/></f></get_ANY_SHAPE>
		<ANY_COMPOUND public="1" get="accessor" set="null" static="1">
			<c path="nape.callbacks.CbType"/>
			<haxe_doc>* Default CbType given to all Compounds
     *
     * Due to the way the Callback system in Nape works, you can use this
     * CbType to match against 'all'
     * Compounds
     * In a Listener (Assuming you do not 'remove' this type from the object)</haxe_doc>
		</ANY_COMPOUND>
		<get_ANY_COMPOUND get="inline" set="null" line="251" static="1"><f a=""><c path="nape.callbacks.CbType"/></f></get_ANY_COMPOUND>
		<toString public="1" set="method" line="338">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<get_constraints get="inline" set="null" line="329"><f a=""><c path="nape.constraint.ConstraintList"/></f></get_constraints>
		<constraints public="1" get="accessor" set="null">
			<c path="nape.constraint.ConstraintList"/>
			<haxe_doc><![CDATA[* List of all Constraints using this CbType.
     * <br/><br/>
     * This list contains only those Constraints that are inside of a Space
     * <br/><br/>
     * This list is not only readonly, but also immutable.]]></haxe_doc>
		</constraints>
		<get_interactors get="inline" set="null" line="314"><f a=""><c path="nape.phys.InteractorList"/></f></get_interactors>
		<interactors public="1" get="accessor" set="null">
			<c path="nape.phys.InteractorList"/>
			<haxe_doc><![CDATA[* List of all Interactors using this CbType.
     * <br/><br/>
     * This list contains only those Interactors that are inside of a Space
     * <br/><br/>
     * This list is not only readonly, but also immutable.]]></haxe_doc>
		</interactors>
		<get_userData get="inline" set="null" line="299"><f a=""><d><d/></d></f></get_userData>
		<userData public="1" get="accessor" set="null">
			<d><d/></d>
			<haxe_doc><![CDATA[* Dynamic object for user to store additional data.
     * <br/><br/>
     * This object cannot be set, only its dynamically created
     * properties may be set. In AS3 the type of this property is &#42
     * <br/><br/>
     * This object will be lazily constructed so that until accessed
     * for the first time, will be null internally.
     *
     * @default {}]]></haxe_doc>
		</userData>
		<excluding public="1" set="method" line="283">
			<f a="excludes">
				<d/>
				<c path="nape.callbacks.OptionType"/>
			</f>
			<haxe_doc><![CDATA[* Construct OptionType with given excludes.
     * <br/><br/>
     * Equivalent to <code>new OptionType(this).excluding(excludes)</code>
     * <br/><br/>
     * The excludes argument is typed Dynamic, and is permitted to be one of:
     * <code>CbType, CbTypeList, Array&lt;CbType&gt;, flash.Vector&lt;CbType&gt;</code>
     *
     * @param excludes The CbTypes to exclude.
     * @return A new OptionType whose included types are just 'this' and whose
     *         excluded types are those given as argument.
     * @throws # If excludes is null.]]></haxe_doc>
		</excluding>
		<including public="1" set="method" line="267">
			<f a="includes">
				<d/>
				<c path="nape.callbacks.OptionType"/>
			</f>
			<haxe_doc><![CDATA[* Construct OptionType with given extra includes.
     * <br/><br/>
     * Equivalent to <code>new OptionType(this).including(includes)</code>
     * <br/><br/>
     * The includes argument is typed Dynamic, and is permitted to be one of:
     * <code>CbType, CbTypeList, Array&lt;CbType&gt;, flash.Vector&lt;CbType&gt;</code>
     *
     * @param includes The CbTypes to include.
     * @return A new OptionType whose includes are equal to this CbType
     *         and all the CbTypes given as argument.
     * @throws # If includes is null.]]></haxe_doc>
		</including>
		<get_id get="inline" set="null" line="189"><f a=""><x path="Int"/></f></get_id>
		<id public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Unique identifier for this CbType.</haxe_doc>
		</id>
		<zpp_inner public="1">
			<c path="zpp_nape.callbacks.ZPP_CbType"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="197">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Construct a new CbType object.
     *
     * @return A new CbType.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Callback Type applied to Interactors and Constraints.
 * <br/><br/>
 * Callback types are ranged over by listeners.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.callbacks.CbTypeIterator" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/callbacks/CbTypeIterator.hx">
		<zpp_pool public="1" line="194" static="1">
			<c path="nape.callbacks.CbTypeIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_pool>
		<get public="1" set="method" line="217" static="1">
			<f a="list">
				<c path="nape.callbacks.CbTypeList"/>
				<c path="nape.callbacks.CbTypeIterator"/>
			</f>
			<haxe_doc><![CDATA[* Create iterator for Nape list.
     * <br/><br/>
     * There is no specific reason to use this over: <code>list.iterator()</code>
     * especcialy since this requires writing the class name :)
     * (This function is used internally)
     *
     * @param list The Nape list to create iterator for.
     * @return     An iterator over the Nape list.]]></haxe_doc>
		</get>
		<next public="1" get="inline" set="null" line="264">
			<f a=""><c path="nape.callbacks.CbType"/></f>
			<haxe_doc>* Return next element in list.
     *
     * @return The next element in iteration.</haxe_doc>
		</next>
		<hasNext public="1" get="inline" set="null" line="240">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Check if there are any elements remaining.
     *
     * @return True if there are more elements to iterator over.</haxe_doc>
		</hasNext>
		<zpp_next public="1">
			<c path="nape.callbacks.CbTypeIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_next>
		<zpp_critical public="1">
			<x path="Bool"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_critical>
		<zpp_i public="1">
			<x path="Int"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_i>
		<zpp_inner public="1">
			<c path="nape.callbacks.CbTypeList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="202">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Haxe Iterator<T> compatible iterator over Nape list.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.callbacks.CbTypeList" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/callbacks/CbTypeList.hx">
		<fromArray public="1" set="method" line="304" static="1">
			<f a="array">
				<c path="Array"><c path="nape.callbacks.CbType"/></c>
				<c path="nape.callbacks.CbTypeList"/>
			</f>
			<haxe_doc>* Convert standard Array to Nape list.
     *
     * @param array The array to be converted
     * @return An equivalent Nape list.
     * @throws If array argument is null.
     * @throws If array contains elements of type other than CbType</haxe_doc>
		</fromArray>
		<filter public="1" set="method" line="779">
			<f a="lambda">
				<f a="">
					<c path="nape.callbacks.CbType"/>
					<x path="Bool"/>
				</f>
				<c path="nape.callbacks.CbTypeList"/>
			</f>
			<haxe_doc><![CDATA[* Iterate over list filtering elements.
     * <br/><br/>
     * The given function will be applied to each element, whenever the
     * function returns false, the element will be removed from the list.
     * <br/><br/>
     * Any exception thrown by the supplied function will be treat as a
     * signal to halt iteration acting as a 'break' statement.
     * <br/><br/>
     * This method is to be greatly preferred for filtering logic as
     * it is otherwise unsafe to modify the list during an iteration.
     * <br/><br/>
     * An example of using this method to clean up a list whilst performing
     * actions on the elements.
     * <pre>
     * list.filter(function (obj) {
     *    // perform clean up with obj
     *    return false; // remove from list.
     * });
     * </pre>
     *
     * @param lambda The function to apply to each argument, deciding if
     *               element should be removed.
     * @return A reference to 'this' list.
     * @throws # If lambda argument is null.]]></haxe_doc>
		</filter>
		<foreach public="1" get="inline" set="null" line="732">
			<f a="lambda">
				<f a="">
					<c path="nape.callbacks.CbType"/>
					<x path="Void"/>
				</f>
				<c path="nape.callbacks.CbTypeList"/>
			</f>
			<haxe_doc><![CDATA[* Iterate over list applying function.
     * <br/><br/>
     * Any exception thrown by the supplied function will be treat as a
     * signal to halt iteration acting as a 'break' statement.
     * <br/><br/>
     * This method should be preferred to using standard haxe iteration
     * as there will be no allocation of an iterator object.
     * <pre>
     * list.foreach(function (obj) {
     *     if (ignore_object(obj)) return; //acts as a 'continue' statement
     *     if (halt_iteration(obj)) throw "": //acts as a 'break' statement
     * });
     * </pre>
     *
     * @param lambda The function to apply to each argument.
     * @return A reference to 'this' list.
     * @throws # If lambda argument is null.]]></haxe_doc>
		</foreach>
		<toString public="1" set="method" line="702">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<merge public="1" set="method" line="684">
			<f a="xs">
				<c path="nape.callbacks.CbTypeList"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Merge given list into this one.
     * <br/><br/>
     * The result is that this list will have all objects from the argument
     * that were not already in the list inserted. You should make no
     * assumption about the order of these insertions.
     *
     * @param xs The list to merge.
     * @throws # If xs argument is null.]]></haxe_doc>
		</merge>
		<copy public="1" set="method" line="662">
			<f a="?deep">
				<x path="Bool"/>
				<c path="nape.callbacks.CbTypeList"/>
			</f>
			<haxe_doc>* Produce a possibly deep copy of list.
     *
     * @param deep If true, then each element will have its own copy
     *             function called instead of simply having its
     *             reference copied over.
     * @return     The copied list.</haxe_doc>
		</copy>
		<iterator public="1" get="inline" set="null" line="647">
			<f a=""><c path="nape.callbacks.CbTypeIterator"/></f>
			<haxe_doc><![CDATA[* Return Haxe iterator for list.
     * <br/><br/>
     * Use of this iterator, whilst stylistically better in Haxe should not
     * be used, in preference for use of the foreach function which will
     * not require allocation of an iterator object.
     * <br/><br/>
     * Equally in AS3, the foreach method should be the preferred way to iterate.]]></haxe_doc>
		</iterator>
		<empty public="1" get="inline" set="null" line="631">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Test if list is empty or not.
     *
     * @return True if list is empty.</haxe_doc>
		</empty>
		<clear public="1" set="method" line="614">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clear the list, removing all elements.
     *
     * @throws # If list is iummutable</haxe_doc>
		</clear>
		<remove public="1" set="method" line="576">
			<f a="obj">
				<c path="nape.callbacks.CbType"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Remove element from list.
     * <br/><br/>
     * This is a linear time operation.
     *
     * @param obj The object to remove
     * @return True if object was removed from list.
     * @throws # If list is immutable]]></haxe_doc>
		</remove>
		<add public="1" get="inline" set="null" line="563">
			<f a="obj">
				<c path="nape.callbacks.CbType"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Insert element into list in most effecient way.
     * <br/><br/>
     * This method will defer to either the push or unshift function
     * depending on which is most effecient in the context.
     * <br/><br/>
     * If order of elements is not important then you should always use
     * this function to insert elements.
     *
     * @param obj The object to insert.
     * @return True if object was successfuly inserted.
     * @throws # If list is immutable]]></haxe_doc>
		</add>
		<shift public="1" set="method" line="519">
			<f a=""><c path="nape.callbacks.CbType"/></f>
			<haxe_doc><![CDATA[* Pop element from front of list.
     * <br/><br/>
     * If you are wanting to clear a list, whilst operating on its elements,
     * consider use of the filter method instead.
     *
     * @returns The element removed from list.
     * @throws # If list is immutable.
     * @throws # If the list is empty.]]></haxe_doc>
		</shift>
		<pop public="1" set="method" line="478">
			<f a=""><c path="nape.callbacks.CbType"/></f>
			<haxe_doc><![CDATA[* Pop element from back of list.
     * <br/><br/>
     * If you are wanting to clear a list, whilst operating on its elements,
     * consider use of the filter method instead.
     *
     * @returns The element removed from list.
     * @throws # If list is immutable.
     * @throws # If the list is empty.]]></haxe_doc>
		</pop>
		<unshift public="1" set="method" line="447">
			<f a="obj">
				<c path="nape.callbacks.CbType"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Push element to front of list.
     * <br/><br/>
     * When the order of objects is not important, it is best to use the
     * add() method instead.
     *
     * @param obj The object to insert.
     * @returns True if object was successively inserted.
     * @throws # If list is immutable.]]></haxe_doc>
		</unshift>
		<push public="1" set="method" line="416">
			<f a="obj">
				<c path="nape.callbacks.CbType"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Push element to back of list.
     * <br/><br/>
     * When the order of objects is not important, it is best to use the
     * add() method instead.
     *
     * @param obj The object to insert.
     * @returns True if object was successively inserted.
     * @throws # If list is immutable.]]></haxe_doc>
		</push>
		<at public="1" set="method" line="363">
			<f a="index">
				<x path="Int"/>
				<c path="nape.callbacks.CbType"/>
			</f>
			<haxe_doc><![CDATA[* Random access to elements of list by index.
     * <br/><br/>
     * Under normal circumstances, accessing succesive elements via this
     * method will occur in constant time.
     *
     * @param index The index of the element in list to access.
     * @returns The element at the given index.
     * @throws # If index is out of bounds.]]></haxe_doc>
		</at>
		<has public="1" set="method" line="346">
			<f a="obj">
				<c path="nape.callbacks.CbType"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if element is already in the list
     *
     * @param obj The object to test.
     * @return True if object is in the list.</haxe_doc>
		</has>
		<get_length get="inline" set="null" line="244"><f a=""><x path="Int"/></f></get_length>
		<length public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Length of list.</haxe_doc>
		</length>
		<zpp_inner public="1">
			<c path="zpp_nape.util.ZPP_CbTypeList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="695">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Construct a new list.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Nape list of CbType type objects
 * <br/><br/>
 * Internally this list is at present implemented as a linked list with
 * object pooled nodes and iterators with various fast paths made for
 * standard access patterns (For instance accessing successive elements
 * runs in constant time when using random access functions)
 * <br/><br/>
 * Iteration of this list can be done in various ways, but the preferred
 * way on all targets, is through use of the foreach function:
 * <pre>
 * list.foreach(function (obj) {
 * });
 * </pre>
 * This method is inlined so that in haxe no closure will need to be created.
 * <br/><br/>
 * In AS3, a closure would need to be created in general, so for performance
 * reasons you 'may' choose to use iteration as follows:
 * <pre>
 * for (var i:int = 0; i < list.length; i++) {
 *     var obj:CbType = list.at(i);
 * }
 * </pre>
 * <br/>
 * NOTE: It is 'not' safe to modify a list whilst iterating over it.
 * If you wish to remove elements during an iteration you should use the
 * filter method, for example:
 * <pre>
 * list.filter(function (obj) {
 *     // operate on object.
 *     // ...
 *     return (false if you want object to be removed);
 * });
 * </pre>
 * <br/><br/>
 * In AS3, if you wish to avoid a closure generation, you can perform such
 * an iteration in a safe manner as follows:
 * <pre>
 * var i:int = 0;
 * while (i < list.length) {
 *     var obj:CbType = list.at(i);
 *     // operate on object.
 *     // ...
 *     if (should remove obj) {
 *         list.remove(obj);
 *         continue;
 *     }
 *     else i++;
 * }
 * </pre>
 * Or if you are always clearing the list entirely you could write:
 * <pre>
 * while (!list.empty()) {
 *     var obj:CbType = list.pop();
 *     // operate on object.
 *     // ...
 * }
 * </pre>]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.callbacks.ConstraintCallback" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/callbacks/ConstraintCallback.hx">
		<extends path="nape.callbacks.Callback"/>
		<toString public="1" set="method" line="198" override="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<get_constraint get="inline" set="null" line="192"><f a=""><c path="nape.constraint.Constraint"/></f></get_constraint>
		<constraint public="1" get="accessor" set="null">
			<c path="nape.constraint.Constraint"/>
			<haxe_doc>* Constraint involved in callback event.</haxe_doc>
		</constraint>
		<new public="1" set="method" line="184">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Callback object for Constraint type events.
 * <br/><br/>
 * This, like all other callback objects are automatically reused
 * and you should not keep any reference to them.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.callbacks.ConstraintListener" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/callbacks/ConstraintListener.hx">
		<extends path="nape.callbacks.Listener"/>
		<set_handler get="inline" set="null" line="211"><f a="handler">
	<f a="">
		<c path="nape.callbacks.ConstraintCallback"/>
		<x path="Void"/>
	</f>
	<f a="">
		<c path="nape.callbacks.ConstraintCallback"/>
		<x path="Void"/>
	</f>
</f></set_handler>
		<get_handler get="inline" set="null" line="208"><f a=""><f a="">
	<c path="nape.callbacks.ConstraintCallback"/>
	<x path="Void"/>
</f></f></get_handler>
		<handler public="1" get="accessor" set="accessor">
			<f a="">
				<c path="nape.callbacks.ConstraintCallback"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The callback handler for this event.</haxe_doc>
		</handler>
		<set_options get="inline" set="null" line="197"><f a="options">
	<c path="nape.callbacks.OptionType"/>
	<c path="nape.callbacks.OptionType"/>
</f></set_options>
		<get_options get="inline" set="null" line="194"><f a=""><c path="nape.callbacks.OptionType"/></f></get_options>
		<options public="1" get="accessor" set="accessor">
			<c path="nape.callbacks.OptionType"/>
			<haxe_doc><![CDATA[* The OptionType used to match against Constraints.
     * <br/><br/>
     * When added to the same Space, any Constraint who's CbType list matches
     * against this OptionType will be issued a callback when the relevant
     * event occurs.]]></haxe_doc>
		</options>
		<zpp_inner_zn public="1">
			<c path="zpp_nape.callbacks.ZPP_ConstraintListener"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner_zn>
		<new public="1" set="method" line="248">
			<f a="event:options:handler:?precedence">
				<c path="nape.callbacks.CbEvent"/>
				<t path="Null"><d/></t>
				<f a="">
					<c path="nape.callbacks.ConstraintCallback"/>
					<x path="Void"/>
				</f>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Construct a new ConstraintListener.
     * <br/><br/>
     * The possible event types are WAKE, SLEEP and BREAK.
     * <br/><br/>
     * The options argument is typed Dynamic, and is permitted to be either an
     * <code>OptionType</code> or one of:
     * <code>CbType, CbTypeList, Array&lt;CbType&gt;, flash.Vector&lt;CbType&gt;</code>
     * In which case the input CbType's will be used to construct an OptionType
     * whose included types will be the set of CbTypes supplied.
     *
     * @param event The event type to listen for.
     * @param options The OptionType to match Constraints against, passing null
     *                will equate to an empty OptionType.
     * @param handler The callback handler for this listener.
     * @param precedence The precedence of this listener used to sort
     *                   the order of callbacks in the case of more than
     *                   one suitable ConstraintListener existing for the same
     *                   event on the same Constraint. (default 0)
     * @return The newly constructed ConstraintListener
     * @throws # If handler is null.
     * @throws # If the event type is not permitted for this listener.
     * @throws # If options is not of the expected Type.]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Event listener for Constraint type events.
 * <br/><br/>
 * The events that can be caught are WAKE, SLEEP and BREAK type events.
 * Theses listeners will only operate on Constraints.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.callbacks.InteractionCallback" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/callbacks/InteractionCallback.hx">
		<extends path="nape.callbacks.Callback"/>
		<toString public="1" set="method" line="223" override="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<get_arbiters get="inline" set="null" line="217"><f a=""><c path="nape.dynamics.ArbiterList"/></f></get_arbiters>
		<arbiters public="1" get="accessor" set="null">
			<c path="nape.dynamics.ArbiterList"/>
			<haxe_doc><![CDATA[* Existing arbiters between interactors.
     * <br/><br/>
     * This list will at present contain 'all' arbiters, not just those matching the
     * interactionType in the InteractionListener. (This may be subject to change).]]></haxe_doc>
		</arbiters>
		<get_int2 get="inline" set="null" line="206"><f a=""><c path="nape.phys.Interactor"/></f></get_int2>
		<int2 public="1" get="accessor" set="null">
			<c path="nape.phys.Interactor"/>
			<haxe_doc><![CDATA[* Second Interactor involved in callback event.
     * <br/><br/>
     * This interactor will have CbType set matched by the second
     * OptionType in InteractionListener]]></haxe_doc>
		</int2>
		<get_int1 get="inline" set="null" line="195"><f a=""><c path="nape.phys.Interactor"/></f></get_int1>
		<int1 public="1" get="accessor" set="null">
			<c path="nape.phys.Interactor"/>
			<haxe_doc><![CDATA[* First Interactor involved in callback event.
     * <br/><br/>
     * This interactor will have CbType set matched by the first
     * OptionType in InteractionListener]]></haxe_doc>
		</int1>
		<new public="1" set="method" line="184">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Callback object for Interaction type events.
 * <br/><br/>
 * This, like all other callback objects are automatically reused
 * and you should not keep any reference to them.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.callbacks.InteractionListener" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/callbacks/InteractionListener.hx">
		<extends path="nape.callbacks.Listener"/>
		<set_allowSleepingCallbacks get="inline" set="null" line="303"><f a="allowSleepingCallbacks">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_allowSleepingCallbacks>
		<get_allowSleepingCallbacks get="inline" set="null" line="300"><f a=""><x path="Bool"/></f></get_allowSleepingCallbacks>
		<allowSleepingCallbacks public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* For ONGOING listeners only, permit ONGOING callbacks whilst sleeping.
     * <br/><br/>
     * This property determines whether we will still receive
     * ONGOING callbacks between two sleeping Interactors. The default action is to
     * inhibit callbacks between sleeping objects for performance. Setting this field to true
     * will permit Nape to always generate callbacks.]]></haxe_doc>
		</allowSleepingCallbacks>
		<set_handler get="inline" set="null" line="279"><f a="handler">
	<f a="">
		<c path="nape.callbacks.InteractionCallback"/>
		<x path="Void"/>
	</f>
	<f a="">
		<c path="nape.callbacks.InteractionCallback"/>
		<x path="Void"/>
	</f>
</f></set_handler>
		<get_handler get="inline" set="null" line="276"><f a=""><f a="">
	<c path="nape.callbacks.InteractionCallback"/>
	<x path="Void"/>
</f></f></get_handler>
		<handler public="1" get="accessor" set="accessor">
			<f a="">
				<c path="nape.callbacks.InteractionCallback"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The callback handler for this listener.</haxe_doc>
		</handler>
		<set_interactionType get="inline" set="null" line="257"><f a="interactionType">
	<c path="nape.callbacks.InteractionType"/>
	<c path="nape.callbacks.InteractionType"/>
</f></set_interactionType>
		<get_interactionType get="inline" set="null" line="249"><f a=""><c path="nape.callbacks.InteractionType"/></f></get_interactionType>
		<interactionType public="1" get="accessor" set="accessor">
			<c path="nape.callbacks.InteractionType"/>
			<haxe_doc><![CDATA[* The specific type of interaction that is to be listened for.
     * <br/><br/>
     * If we specify that we only want to listen for a fluid type interaction, then
     * this listener will operate so that any other interactions for the same pair
     * of objects is ignored.]]></haxe_doc>
		</interactionType>
		<set_options2 get="inline" set="null" line="234"><f a="options2">
	<c path="nape.callbacks.OptionType"/>
	<c path="nape.callbacks.OptionType"/>
</f></set_options2>
		<get_options2 get="inline" set="null" line="231"><f a=""><c path="nape.callbacks.OptionType"/></f></get_options2>
		<options2 public="1" get="accessor" set="accessor">
			<c path="nape.callbacks.OptionType"/>
			<haxe_doc>* The OptionType used to match against Interactors for the second object.</haxe_doc>
		</options2>
		<set_options1 get="inline" set="null" line="220"><f a="options1">
	<c path="nape.callbacks.OptionType"/>
	<c path="nape.callbacks.OptionType"/>
</f></set_options1>
		<get_options1 get="inline" set="null" line="217"><f a=""><c path="nape.callbacks.OptionType"/></f></get_options1>
		<options1 public="1" get="accessor" set="accessor">
			<c path="nape.callbacks.OptionType"/>
			<haxe_doc>* The OptionType used to match against Interactors for the first object.</haxe_doc>
		</options1>
		<zpp_inner_zn public="1">
			<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner_zn>
		<new public="1" set="method" line="338">
			<f a="event:interactionType:options1:options2:handler:?precedence">
				<c path="nape.callbacks.CbEvent"/>
				<c path="nape.callbacks.InteractionType"/>
				<t path="Null"><d/></t>
				<t path="Null"><d/></t>
				<f a="">
					<c path="nape.callbacks.InteractionCallback"/>
					<x path="Void"/>
				</f>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Construct a new InteractionListener.
     * <br/><br/>
     * The possible event types are BEGIN, ONGOING and END.
     * <br/><br/>
     * The options arguments are typed Dynamic, and are permitted to be either an
     * <code>OptionType</code> or one of:
     * <code>CbType, CbTypeList, Array&lt;CbType&gt;, flash.Vector&lt;CbType&gt;</code>
     * In which case the input CbType's will be used to construct an OptionType
     * whose included types will be the set of CbTypes supplied.
     *
     * @param event The event type to listen for.
     * @param interactionType The interaction type to listen for.
     * @param options1 The OptionType to match first Interactor against, passing null
     *                will equate to an empty OptionType.
     * @param options2 The OptionType to match second Interactor against, passing null
     *                will equate to an empty OptionType.
     * @param handler The callback handler for this listener.
     * @param precedence The precedence of this listener used to sort
     *                   the order of callbacks in the case of more than
     *                   one suitable BodyListener existing for the same
     *                   event on the same Body. (default 0)
     * @return The newly constructed InteractionListener
     * @throws # If handler is null.
     * @throws # If the event type is not permitted for this listener.
     * @throws # If either option is not of the expected Type.]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Event listener for Interaction type events.
 * <br/><br/>
 * Interaction type events can occur between any two Interactors (whether they
 * be Shapes, Bodys, Compounds or a mix thereof).
 * <br/><br/>
 * The events that can be caught are BEGIN, ONGOING, and END type events.
 * Theses listeners will operate between pairs of Interactors.
 * <pre>
 *          _Space
 *         /      \
 *     Cmp1        Cmp3
 *    /    \         |
 * Body1  Cmp2     Body3
 *   |      |        |
 * Shp1   Body2    Shp3
 *          |
 *        Shp2
 * </pre>
 * The possible interactor pairs for callbacks are formed by finding the most
 * recent common ancestor in the world for the given pair of shapes and taking all
 * possible pairings. In the above situation we have:
 * <pre>
 * MRCA(Shp1, Shp2) = Cmp1  --> Possible pairings = [Shp1, Body1] x [Shp2, Body2, Cmp2]
 * MRCA(Shp1, Shp3) = Space --> Possible pairings = [Shp1, Body1, Cmp1] x [Shp3, Body3, Cmp3]
 * MRCA(Shp2, Shp3) = Space --> Possible pairings = [Shp2, Body2, Cmp2, Cmp1] x [Shp3, Body3, Cmp3]
 * </pre>
 * Of course, not all of these pairings will generate callbacks, only those for which
 * a valid listener exists for the event type, and for the cbtypes of each interactor.
 * <br/><br/>
 * Furthermore, the listener specifies an interaction type which works even in mixed
 * cases where many types of interaction between two objects is happening at once.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.callbacks.InteractionType" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/callbacks/InteractionType.hx">
		<COLLISION public="1" get="accessor" set="null" static="1">
			<c path="nape.callbacks.InteractionType"/>
			<haxe_doc>* Collision interaction type.</haxe_doc>
		</COLLISION>
		<get_COLLISION get="inline" set="null" line="203" static="1"><f a=""><c path="nape.callbacks.InteractionType"/></f></get_COLLISION>
		<SENSOR public="1" get="accessor" set="null" static="1">
			<c path="nape.callbacks.InteractionType"/>
			<haxe_doc>* Sensor interaction type.
    ""</haxe_doc>
		</SENSOR>
		<get_SENSOR get="inline" set="null" line="215" static="1"><f a=""><c path="nape.callbacks.InteractionType"/></f></get_SENSOR>
		<FLUID public="1" get="accessor" set="null" static="1">
			<c path="nape.callbacks.InteractionType"/>
			<haxe_doc>* Fluid interaction type.</haxe_doc>
		</FLUID>
		<get_FLUID get="inline" set="null" line="228" static="1"><f a=""><c path="nape.callbacks.InteractionType"/></f></get_FLUID>
		<ANY public="1" get="accessor" set="null" static="1">
			<c path="nape.callbacks.InteractionType"/>
			<haxe_doc>* Special enum corresponding to 'all' interaction types.</haxe_doc>
		</ANY>
		<get_ANY get="inline" set="null" line="241" static="1"><f a=""><c path="nape.callbacks.InteractionType"/></f></get_ANY>
		<toString public="1" set="method" line="189">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<new public="1" set="method" line="181">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc>* Enumeration of Interaction types.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.callbacks.ListenerIterator" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/callbacks/ListenerIterator.hx">
		<zpp_pool public="1" line="194" static="1">
			<c path="nape.callbacks.ListenerIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_pool>
		<get public="1" set="method" line="217" static="1">
			<f a="list">
				<c path="nape.callbacks.ListenerList"/>
				<c path="nape.callbacks.ListenerIterator"/>
			</f>
			<haxe_doc><![CDATA[* Create iterator for Nape list.
     * <br/><br/>
     * There is no specific reason to use this over: <code>list.iterator()</code>
     * especcialy since this requires writing the class name :)
     * (This function is used internally)
     *
     * @param list The Nape list to create iterator for.
     * @return     An iterator over the Nape list.]]></haxe_doc>
		</get>
		<next public="1" get="inline" set="null" line="264">
			<f a=""><c path="nape.callbacks.Listener"/></f>
			<haxe_doc>* Return next element in list.
     *
     * @return The next element in iteration.</haxe_doc>
		</next>
		<hasNext public="1" get="inline" set="null" line="240">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Check if there are any elements remaining.
     *
     * @return True if there are more elements to iterator over.</haxe_doc>
		</hasNext>
		<zpp_next public="1">
			<c path="nape.callbacks.ListenerIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_next>
		<zpp_critical public="1">
			<x path="Bool"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_critical>
		<zpp_i public="1">
			<x path="Int"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_i>
		<zpp_inner public="1">
			<c path="nape.callbacks.ListenerList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="202">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Haxe Iterator<T> compatible iterator over Nape list.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.callbacks.ListenerList" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/callbacks/ListenerList.hx">
		<fromArray public="1" set="method" line="304" static="1">
			<f a="array">
				<c path="Array"><c path="nape.callbacks.Listener"/></c>
				<c path="nape.callbacks.ListenerList"/>
			</f>
			<haxe_doc>* Convert standard Array to Nape list.
     *
     * @param array The array to be converted
     * @return An equivalent Nape list.
     * @throws If array argument is null.
     * @throws If array contains elements of type other than Listener</haxe_doc>
		</fromArray>
		<filter public="1" set="method" line="779">
			<f a="lambda">
				<f a="">
					<c path="nape.callbacks.Listener"/>
					<x path="Bool"/>
				</f>
				<c path="nape.callbacks.ListenerList"/>
			</f>
			<haxe_doc><![CDATA[* Iterate over list filtering elements.
     * <br/><br/>
     * The given function will be applied to each element, whenever the
     * function returns false, the element will be removed from the list.
     * <br/><br/>
     * Any exception thrown by the supplied function will be treat as a
     * signal to halt iteration acting as a 'break' statement.
     * <br/><br/>
     * This method is to be greatly preferred for filtering logic as
     * it is otherwise unsafe to modify the list during an iteration.
     * <br/><br/>
     * An example of using this method to clean up a list whilst performing
     * actions on the elements.
     * <pre>
     * list.filter(function (obj) {
     *    // perform clean up with obj
     *    return false; // remove from list.
     * });
     * </pre>
     *
     * @param lambda The function to apply to each argument, deciding if
     *               element should be removed.
     * @return A reference to 'this' list.
     * @throws # If lambda argument is null.]]></haxe_doc>
		</filter>
		<foreach public="1" get="inline" set="null" line="732">
			<f a="lambda">
				<f a="">
					<c path="nape.callbacks.Listener"/>
					<x path="Void"/>
				</f>
				<c path="nape.callbacks.ListenerList"/>
			</f>
			<haxe_doc><![CDATA[* Iterate over list applying function.
     * <br/><br/>
     * Any exception thrown by the supplied function will be treat as a
     * signal to halt iteration acting as a 'break' statement.
     * <br/><br/>
     * This method should be preferred to using standard haxe iteration
     * as there will be no allocation of an iterator object.
     * <pre>
     * list.foreach(function (obj) {
     *     if (ignore_object(obj)) return; //acts as a 'continue' statement
     *     if (halt_iteration(obj)) throw "": //acts as a 'break' statement
     * });
     * </pre>
     *
     * @param lambda The function to apply to each argument.
     * @return A reference to 'this' list.
     * @throws # If lambda argument is null.]]></haxe_doc>
		</foreach>
		<toString public="1" set="method" line="702">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<merge public="1" set="method" line="684">
			<f a="xs">
				<c path="nape.callbacks.ListenerList"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Merge given list into this one.
     * <br/><br/>
     * The result is that this list will have all objects from the argument
     * that were not already in the list inserted. You should make no
     * assumption about the order of these insertions.
     *
     * @param xs The list to merge.
     * @throws # If xs argument is null.]]></haxe_doc>
		</merge>
		<copy public="1" set="method" line="662">
			<f a="?deep">
				<x path="Bool"/>
				<c path="nape.callbacks.ListenerList"/>
			</f>
			<haxe_doc>* Produce a possibly deep copy of list.
     *
     * @param deep If true, then each element will have its own copy
     *             function called instead of simply having its
     *             reference copied over.
     * @return     The copied list.</haxe_doc>
		</copy>
		<iterator public="1" get="inline" set="null" line="647">
			<f a=""><c path="nape.callbacks.ListenerIterator"/></f>
			<haxe_doc><![CDATA[* Return Haxe iterator for list.
     * <br/><br/>
     * Use of this iterator, whilst stylistically better in Haxe should not
     * be used, in preference for use of the foreach function which will
     * not require allocation of an iterator object.
     * <br/><br/>
     * Equally in AS3, the foreach method should be the preferred way to iterate.]]></haxe_doc>
		</iterator>
		<empty public="1" get="inline" set="null" line="631">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Test if list is empty or not.
     *
     * @return True if list is empty.</haxe_doc>
		</empty>
		<clear public="1" set="method" line="614">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clear the list, removing all elements.
     *
     * @throws # If list is iummutable</haxe_doc>
		</clear>
		<remove public="1" set="method" line="576">
			<f a="obj">
				<c path="nape.callbacks.Listener"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Remove element from list.
     * <br/><br/>
     * This is a linear time operation.
     *
     * @param obj The object to remove
     * @return True if object was removed from list.
     * @throws # If list is immutable]]></haxe_doc>
		</remove>
		<add public="1" get="inline" set="null" line="563">
			<f a="obj">
				<c path="nape.callbacks.Listener"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Insert element into list in most effecient way.
     * <br/><br/>
     * This method will defer to either the push or unshift function
     * depending on which is most effecient in the context.
     * <br/><br/>
     * If order of elements is not important then you should always use
     * this function to insert elements.
     *
     * @param obj The object to insert.
     * @return True if object was successfuly inserted.
     * @throws # If list is immutable]]></haxe_doc>
		</add>
		<shift public="1" set="method" line="519">
			<f a=""><c path="nape.callbacks.Listener"/></f>
			<haxe_doc><![CDATA[* Pop element from front of list.
     * <br/><br/>
     * If you are wanting to clear a list, whilst operating on its elements,
     * consider use of the filter method instead.
     *
     * @returns The element removed from list.
     * @throws # If list is immutable.
     * @throws # If the list is empty.]]></haxe_doc>
		</shift>
		<pop public="1" set="method" line="478">
			<f a=""><c path="nape.callbacks.Listener"/></f>
			<haxe_doc><![CDATA[* Pop element from back of list.
     * <br/><br/>
     * If you are wanting to clear a list, whilst operating on its elements,
     * consider use of the filter method instead.
     *
     * @returns The element removed from list.
     * @throws # If list is immutable.
     * @throws # If the list is empty.]]></haxe_doc>
		</pop>
		<unshift public="1" set="method" line="447">
			<f a="obj">
				<c path="nape.callbacks.Listener"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Push element to front of list.
     * <br/><br/>
     * When the order of objects is not important, it is best to use the
     * add() method instead.
     *
     * @param obj The object to insert.
     * @returns True if object was successively inserted.
     * @throws # If list is immutable.]]></haxe_doc>
		</unshift>
		<push public="1" set="method" line="416">
			<f a="obj">
				<c path="nape.callbacks.Listener"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Push element to back of list.
     * <br/><br/>
     * When the order of objects is not important, it is best to use the
     * add() method instead.
     *
     * @param obj The object to insert.
     * @returns True if object was successively inserted.
     * @throws # If list is immutable.]]></haxe_doc>
		</push>
		<at public="1" set="method" line="363">
			<f a="index">
				<x path="Int"/>
				<c path="nape.callbacks.Listener"/>
			</f>
			<haxe_doc><![CDATA[* Random access to elements of list by index.
     * <br/><br/>
     * Under normal circumstances, accessing succesive elements via this
     * method will occur in constant time.
     *
     * @param index The index of the element in list to access.
     * @returns The element at the given index.
     * @throws # If index is out of bounds.]]></haxe_doc>
		</at>
		<has public="1" set="method" line="346">
			<f a="obj">
				<c path="nape.callbacks.Listener"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if element is already in the list
     *
     * @param obj The object to test.
     * @return True if object is in the list.</haxe_doc>
		</has>
		<get_length get="inline" set="null" line="244"><f a=""><x path="Int"/></f></get_length>
		<length public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Length of list.</haxe_doc>
		</length>
		<zpp_inner public="1">
			<c path="zpp_nape.util.ZPP_ListenerList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="695">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Construct a new list.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Nape list of Listener type objects
 * <br/><br/>
 * Internally this list is at present implemented as a linked list with
 * object pooled nodes and iterators with various fast paths made for
 * standard access patterns (For instance accessing successive elements
 * runs in constant time when using random access functions)
 * <br/><br/>
 * Iteration of this list can be done in various ways, but the preferred
 * way on all targets, is through use of the foreach function:
 * <pre>
 * list.foreach(function (obj) {
 * });
 * </pre>
 * This method is inlined so that in haxe no closure will need to be created.
 * <br/><br/>
 * In AS3, a closure would need to be created in general, so for performance
 * reasons you 'may' choose to use iteration as follows:
 * <pre>
 * for (var i:int = 0; i < list.length; i++) {
 *     var obj:Listener = list.at(i);
 * }
 * </pre>
 * <br/>
 * NOTE: It is 'not' safe to modify a list whilst iterating over it.
 * If you wish to remove elements during an iteration you should use the
 * filter method, for example:
 * <pre>
 * list.filter(function (obj) {
 *     // operate on object.
 *     // ...
 *     return (false if you want object to be removed);
 * });
 * </pre>
 * <br/><br/>
 * In AS3, if you wish to avoid a closure generation, you can perform such
 * an iteration in a safe manner as follows:
 * <pre>
 * var i:int = 0;
 * while (i < list.length) {
 *     var obj:Listener = list.at(i);
 *     // operate on object.
 *     // ...
 *     if (should remove obj) {
 *         list.remove(obj);
 *         continue;
 *     }
 *     else i++;
 * }
 * </pre>
 * Or if you are always clearing the list entirely you could write:
 * <pre>
 * while (!list.empty()) {
 *     var obj:Listener = list.pop();
 *     // operate on object.
 *     // ...
 * }
 * </pre>]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.callbacks.ListenerType" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/callbacks/ListenerType.hx">
		<BODY public="1" get="accessor" set="null" static="1">
			<c path="nape.callbacks.ListenerType"/>
			<haxe_doc>* Type for BodyListeners</haxe_doc>
		</BODY>
		<get_BODY get="inline" set="null" line="203" static="1"><f a=""><c path="nape.callbacks.ListenerType"/></f></get_BODY>
		<CONSTRAINT public="1" get="accessor" set="null" static="1">
			<c path="nape.callbacks.ListenerType"/>
			<haxe_doc>* Type for ConstraintListeners</haxe_doc>
		</CONSTRAINT>
		<get_CONSTRAINT get="inline" set="null" line="216" static="1"><f a=""><c path="nape.callbacks.ListenerType"/></f></get_CONSTRAINT>
		<INTERACTION public="1" get="accessor" set="null" static="1">
			<c path="nape.callbacks.ListenerType"/>
			<haxe_doc>* Type for InteractionListeners</haxe_doc>
		</INTERACTION>
		<get_INTERACTION get="inline" set="null" line="229" static="1"><f a=""><c path="nape.callbacks.ListenerType"/></f></get_INTERACTION>
		<PRE public="1" get="accessor" set="null" static="1">
			<c path="nape.callbacks.ListenerType"/>
			<haxe_doc>* Type for PreListeners</haxe_doc>
		</PRE>
		<get_PRE get="inline" set="null" line="242" static="1"><f a=""><c path="nape.callbacks.ListenerType"/></f></get_PRE>
		<toString public="1" set="method" line="189">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<new public="1" set="method" line="181">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc>* Enumeration of Listener types.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.callbacks.OptionType" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/callbacks/OptionType.hx">
		<toString public="1" set="method" line="292">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<excluding public="1" set="method" line="285">
			<f a="?excludes">
				<d/>
				<c path="nape.callbacks.OptionType"/>
			</f>
			<haxe_doc><![CDATA[* Append set of types to excludes list.
     * <br/><br/>
     * This method was originally named the more appropriate 'exclude'
     * but to match the necessary change for the include function, this was
     * renamed as excluding.
     * <br/><br/>
     * The argument is typed Dynamic, and is permitted to be one of:
     * <code>CbType, CbTypeList, Array&lt;CbType&gt; flash.Vector&lt;CbType&gt;</code>
     *
     * @param excludes The set of CbTypes to be excluded. (default null)
     * @return A reference to this OptionType.
     * @throws # If argument is not of the expected Type.]]></haxe_doc>
		</excluding>
		<including public="1" set="method" line="267">
			<f a="?includes">
				<d/>
				<c path="nape.callbacks.OptionType"/>
			</f>
			<haxe_doc><![CDATA[* Append set of types to includes list.
     * <br/><br/>
     * This method was originally named the more appropriate 'include'
     * but this conflicted with the AS3 keyword include and had to be
     * change.
     * <br/><br/>
     * The argument is typed Dynamic, and is permitted to be one of:
     * <code>CbType, CbTypeList, Array&lt;CbType&gt; flash.Vector&lt;CbType&gt;</code>
     *
     * @param includes The set of CbTypes to be included. (default null)
     * @return A reference to this OptionType.
     * @throws # If argument is not of the expected Type.]]></haxe_doc>
		</including>
		<get_excludes get="inline" set="null" line="228"><f a=""><c path="nape.callbacks.CbTypeList"/></f></get_excludes>
		<excludes public="1" get="accessor" set="null">
			<c path="nape.callbacks.CbTypeList"/>
			<haxe_doc><![CDATA[* List of excluded CbTypes.
     * <br/><br/>
     * This list is both readonly, and immutable. To remove an element
     * from this list you can use: <code>option.including(cbType)</code>
     *
     * @default []]]></haxe_doc>
		</excludes>
		<get_includes get="inline" set="null" line="214"><f a=""><c path="nape.callbacks.CbTypeList"/></f></get_includes>
		<includes public="1" get="accessor" set="null">
			<c path="nape.callbacks.CbTypeList"/>
			<haxe_doc><![CDATA[* List of included CbTypes.
     * <br/><br/>
     * This list is both readonly, and immutable. To remove an element
     * from this list you can use: <code>option.excluding(cbType)</code>
     *
     * @default []]]></haxe_doc>
		</includes>
		<zpp_inner public="1">
			<c path="zpp_nape.callbacks.ZPP_OptionType"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="247">
			<f a="?includes:?excludes">
				<d/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Construct a new OptionType.
     * <br/><br/>
     * The type of the arguments is Dynamic, and is permitted to be one of:
     * <code>CbType, CbTypeList, Array&lt;CbType&gt; flash.Vector&lt;CbType&gt;</code>
     *
     * @param includes The set of CbTypes to be included in the matching process.
     *                 (default null)
     * @param excludes The set of CbTypes to be excluded in the matching process.
     *                 (default null)
     * @return Return new OptionType with give sets of CbTypes.
     * @throws # If either argument is not of the expected Type.]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* OptionType representing matching behaviour for Listeners.
 * <br/><br/>
 * An object's set of CbType's 'matches' against an OptionType iff.
 * the OptionType's includes list intersects the object's set of CbTypes
 * and the OptionType's excludes list 'does not' intersect the object's set
 * of CbTypes.
 * <pre>
 * option = new OptionType([A, B], [C, D]);
 * obj.cbTypes = [] // => does not match option.
 * obj.cbTypes = [A] // => matches the option
 * obj.cbTypes = [A, C] // => does not match option.
 * </pre>
 * The optionType's includes and excludes list are managed to be always
 * disjoint: The action of including an already excluded type serves to
 * remove it from the excludes list, equalliy excluding an already included
 * type serves to remove it from the includes list.
 * <pre>
 * var option = new OptionType();
 * option.including(A); // option = {[A]:[]}
 * option.excluding(A); // option = {[]:[]}
 * option.excluding(A); // option = {[]:[A]}
 * option.including(A); // option = {[A]:[]}
 * </pre>]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.callbacks.PreCallback" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/callbacks/PreCallback.hx">
		<extends path="nape.callbacks.Callback"/>
		<toString public="1" set="method" line="238" override="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<get_swapped get="inline" set="null" line="232"><f a=""><x path="Bool"/></f></get_swapped>
		<swapped public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Describes how Arbiter's objects are related to int1/int2 properties
     * <br/><br/>
     * If true, then arbiter.shape1 will belong to callback.int2, and
     * arbiter.shape2 will belong to callback.int1.
     * <br/><br/>
     * If you take the arbiter's normal, then if swapped is true, the normal
     * will point from int2 towards int1 instead of from int1 towards int2.]]></haxe_doc>
		</swapped>
		<get_int2 get="inline" set="null" line="218"><f a=""><c path="nape.phys.Interactor"/></f></get_int2>
		<int2 public="1" get="accessor" set="null">
			<c path="nape.phys.Interactor"/>
			<haxe_doc><![CDATA[* Second Interactor involved in callback event.
     * <br/><br/>
     * This interactor will have CbType set matched by the second
     * OptionType in InteractionListener]]></haxe_doc>
		</int2>
		<get_int1 get="inline" set="null" line="207"><f a=""><c path="nape.phys.Interactor"/></f></get_int1>
		<int1 public="1" get="accessor" set="null">
			<c path="nape.phys.Interactor"/>
			<haxe_doc><![CDATA[* First Interactor involved in callback event.
     * <br/><br/>
     * This interactor will have CbType set matched by the first
     * OptionType in InteractionListener]]></haxe_doc>
		</int1>
		<get_arbiter get="inline" set="null" line="196"><f a=""><c path="nape.dynamics.Arbiter"/></f></get_arbiter>
		<arbiter public="1" get="accessor" set="null">
			<c path="nape.dynamics.Arbiter"/>
			<haxe_doc><![CDATA[* Arbiter related to callback event.
     * <br/><br/>
     * In the case that this pre-event occurs between two non-Shape's
     * then this is the first arbiter to be created for the related
     * interactionType]]></haxe_doc>
		</arbiter>
		<new public="1" set="method" line="184">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Callback object for Pre-Interaction type events.
 * <br/><br/>
 * This, like all other callback objects are automatically reused
 * and you should not keep any reference to them.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.callbacks.PreFlag" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/callbacks/PreFlag.hx">
		<ACCEPT public="1" get="accessor" set="null" static="1">
			<c path="nape.callbacks.PreFlag"/>
			<haxe_doc>* Value denotes interaction will occur, and Nape will not ask again.</haxe_doc>
		</ACCEPT>
		<get_ACCEPT get="inline" set="null" line="204" static="1"><f a=""><c path="nape.callbacks.PreFlag"/></f></get_ACCEPT>
		<IGNORE public="1" get="accessor" set="null" static="1">
			<c path="nape.callbacks.PreFlag"/>
			<haxe_doc>* Value denotes interaction will be ignored, and Nape will not ask again.</haxe_doc>
		</IGNORE>
		<get_IGNORE get="inline" set="null" line="217" static="1"><f a=""><c path="nape.callbacks.PreFlag"/></f></get_IGNORE>
		<ACCEPT_ONCE public="1" get="accessor" set="null" static="1">
			<c path="nape.callbacks.PreFlag"/>
			<haxe_doc>* Value denotes interaction will occur 'this' step, and Nape will ask what
     * to do again in the following step if interaction is still possible.</haxe_doc>
		</ACCEPT_ONCE>
		<get_ACCEPT_ONCE get="inline" set="null" line="231" static="1"><f a=""><c path="nape.callbacks.PreFlag"/></f></get_ACCEPT_ONCE>
		<IGNORE_ONCE public="1" get="accessor" set="null" static="1">
			<c path="nape.callbacks.PreFlag"/>
			<haxe_doc>* Value denotes interaction will be ignored 'this' step, and Nape will ask what
     * to do again in the following step if interaction is still possible.</haxe_doc>
		</IGNORE_ONCE>
		<get_IGNORE_ONCE get="inline" set="null" line="245" static="1"><f a=""><c path="nape.callbacks.PreFlag"/></f></get_IGNORE_ONCE>
		<toString public="1" set="method" line="190">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<new public="1" set="method" line="182">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc>* Enumeration of interaction states for arbiters. These values are returned
 * by PreListener callback handlers.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.callbacks.PreListener" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/callbacks/PreListener.hx">
		<extends path="nape.callbacks.Listener"/>
		<set_interactionType get="inline" set="null" line="295"><f a="interactionType">
	<c path="nape.callbacks.InteractionType"/>
	<c path="nape.callbacks.InteractionType"/>
</f></set_interactionType>
		<get_interactionType get="inline" set="null" line="287"><f a=""><c path="nape.callbacks.InteractionType"/></f></get_interactionType>
		<interactionType public="1" get="accessor" set="accessor">
			<c path="nape.callbacks.InteractionType"/>
			<haxe_doc><![CDATA[* The specific type of interaction that is to be listened for.
     * <br/><br/>
     * If we specify that we only want to listen for a fluid type interaction, then
     * this listener will operate so that any other interactions for the same pair
     * of objects is ignored.]]></haxe_doc>
		</interactionType>
		<set_pure get="inline" set="null" line="269"><f a="pure">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_pure>
		<get_pure get="inline" set="null" line="266"><f a=""><x path="Bool"/></f></get_pure>
		<pure public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Mark this listener as having a pure callback handler.
     * <br/><br/>
     * A pure callback handler is one which under no circumstances will change its behaviour.
     * In such a (favourable) instance, marking the callback as pure will allow Nape to permit
     * objects in interaction to go to sleep even if the handler returns an IGNORE_ONCE/ACCEPT_ONCE
     * PreFlag.
     *
     * @default false]]></haxe_doc>
		</pure>
		<set_handler get="inline" set="null" line="242"><f a="handler">
	<f a="">
		<c path="nape.callbacks.PreCallback"/>
		<t path="Null"><c path="nape.callbacks.PreFlag"/></t>
	</f>
	<f a="">
		<c path="nape.callbacks.PreCallback"/>
		<t path="Null"><c path="nape.callbacks.PreFlag"/></t>
	</f>
</f></set_handler>
		<get_handler get="inline" set="null" line="239"><f a=""><f a="">
	<c path="nape.callbacks.PreCallback"/>
	<t path="Null"><c path="nape.callbacks.PreFlag"/></t>
</f></f></get_handler>
		<handler public="1" get="accessor" set="accessor">
			<f a="">
				<c path="nape.callbacks.PreCallback"/>
				<t path="Null"><c path="nape.callbacks.PreFlag"/></t>
			</f>
			<haxe_doc><![CDATA[* Callback handler for this listener.
     * <br/><br/>
     * This callback handler returns a possibly null PreFlag object.
     * <br/>
     * Passing null is equivalent to telling nape 'ignore me' so that whatever existing
     * decision has been made regarding the interaction is not modified.
     * Otherwise returning a non-null PreFlag will change the current decision about what
     * to do with the interaction.
     * <br/><br/>
     * Returning ACCEPT/IGNORE inform nape to take control over all subsequent interaction
     * between the two objects until they seperate. Returning these will mean that the pre
     * listener will not be invoked again until the objects seperate, and then begin to interact
     * afresh.
     * <br/><br/>
     * Returning #_ONCE, the objects will only be effected for a single step, and the following
     * step should they still be candidates for interaction, this handler will be invoked again.
     * <br/>
     * In the case of a #_ONCE, PreFlag; Nape will 'not' permit the two objects to go to sleep
     * as Nape cannot know if this callback handler will suddenly changes its mind.
     * <br/>
     * If this handler is a 'pure' function, then you may mark it as such and Nape will keep you
     * to your word and permit the objects to sleep.]]></haxe_doc>
		</handler>
		<set_options2 get="inline" set="null" line="207"><f a="options2">
	<c path="nape.callbacks.OptionType"/>
	<c path="nape.callbacks.OptionType"/>
</f></set_options2>
		<get_options2 get="inline" set="null" line="204"><f a=""><c path="nape.callbacks.OptionType"/></f></get_options2>
		<options2 public="1" get="accessor" set="accessor">
			<c path="nape.callbacks.OptionType"/>
			<haxe_doc>* The OptionType used to match against Interactors for the second object.</haxe_doc>
		</options2>
		<set_options1 get="inline" set="null" line="193"><f a="options1">
	<c path="nape.callbacks.OptionType"/>
	<c path="nape.callbacks.OptionType"/>
</f></set_options1>
		<get_options1 get="inline" set="null" line="190"><f a=""><c path="nape.callbacks.OptionType"/></f></get_options1>
		<options1 public="1" get="accessor" set="accessor">
			<c path="nape.callbacks.OptionType"/>
			<haxe_doc>* The OptionType used to match against Interactors for the first object.</haxe_doc>
		</options1>
		<zpp_inner_zn public="1">
			<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner_zn>
		<new public="1" set="method" line="336">
			<f a="interactionType:options1:options2:handler:?precedence:?pure">
				<c path="nape.callbacks.InteractionType"/>
				<t path="Null"><d/></t>
				<t path="Null"><d/></t>
				<f a="">
					<c path="nape.callbacks.PreCallback"/>
					<t path="Null"><c path="nape.callbacks.PreFlag"/></t>
				</f>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Construct a new PreListener.
     * <br/><br/>
     * The options arguments are typed Dynamic, and are permitted to be either an
     * <code>OptionType</code> or one of:
     * <code>CbType, CbTypeList, Array&lt;CbType&gt;, flash.Vector&lt;CbType&gt;</code>
     * In which case the input CbType's will be used to construct an OptionType
     * whose included types will be the set of CbTypes supplied.
     *
     * @param interactionType The interaction type to listen for.
     * @param options1 The OptionType to match first Interactor against, passing null
     *                will equate to an empty OptionType.
     * @param options2 The OptionType to match second Interactor against, passing null
     *                will equate to an empty OptionType.
     * @param handler The callback handler for this listener.
     * @param precedence The precedence of this listener used to sort
     *                   the order of callbacks in the case of more than
     *                   one suitable BodyListener existing for the same
     *                   event on the same Body. (default 0)
     * @param pure If true, then the listener will be marked as having a pure handler.
     *             (default false)
     * @return The newly constructed InteractionListener
     * @throws # If handler is null.
     * @throws # If either option is not of the expected Type.]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Event listener for Pre-Interaction type events.
 * <br/><br/>
 * Pre-Interaction type events can occur between any two Interactors (whether they
 * be Shapes, Bodys, Compounds or a mix thereof).]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.constraint.Constraint" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/constraint/Constraint.hx">
		<copy public="1" set="method" line="661">
			<f a=""><c path="nape.constraint.Constraint"/></f>
			<haxe_doc><![CDATA[* Produce copy of constraint.
     * <br/><br/>
     * All constraint properties except for internal impulse cache
     * and userData field will be copied.
     *
     * @return The copied Constraint.]]></haxe_doc>
		</copy>
		<toString public="1" set="method" line="650">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<get_cbTypes get="inline" set="null" line="632"><f a=""><c path="nape.callbacks.CbTypeList"/></f></get_cbTypes>
		<cbTypes public="1" get="accessor" set="null">
			<c path="nape.callbacks.CbTypeList"/>
			<haxe_doc><![CDATA[* Set of CbTypes for this constraints for callbacks.
     * <br/><br/>
     * This value cannot at present be set, but can be modified.
     *
     * @default [CbType.ANY_CONSTRAINT]]]></haxe_doc>
		</cbTypes>
		<visitBodies public="1" set="method" line="622">
			<f a="lambda">
				<f a="">
					<c path="nape.phys.Body"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Apply given function to all Bodys linked to the constraint.
     * <br/><br/>
     * If a body is duplicated in a constraint then it will only
     * be visited once.
     *
     * @param lambda The function to apply to each Body.
     * @throws # If lambda is null.]]></haxe_doc>
		</visitBodies>
		<bodyImpulse public="1" set="method" line="610">
			<f a="body">
				<c path="nape.phys.Body"/>
				<c path="nape.geom.Vec3"/>
			</f>
			<haxe_doc><![CDATA[* Compute impulse that was applied to the given Body.
     * <br/><br/>
     * This impulse is the actual (mass weighted) change in velocity
     * that occured due to this constraint.
     *
     * @param body The Body to compute impulse for.
     * @return The impulse that was applied to the body in the previous step.
     * @throws # If Body is not related to the Constraint.]]></haxe_doc>
		</bodyImpulse>
		<impulse public="1" set="method" line="597">
			<f a=""><c path="nape.geom.MatMN"/></f>
			<haxe_doc>* Return the constraint-space impulse applied in previous step.
     *
     * @return A new MatMN representing the constraint space impulse.</haxe_doc>
		</impulse>
		<set_removeOnBreak get="inline" set="null" line="586"><f a="removeOnBreak">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_removeOnBreak>
		<get_removeOnBreak get="inline" set="null" line="583"><f a=""><x path="Bool"/></f></get_removeOnBreak>
		<removeOnBreak public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Whether constraint will be removed when it breaks.
     * <br/><br/>
     * If true, then when constraint is broken it will be removed from
     * the Space. Otherwise it will simple be made inactive.
     *
     * @default true]]></haxe_doc>
		</removeOnBreak>
		<set_breakUnderError get="inline" set="null" line="564"><f a="breakUnderError">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_breakUnderError>
		<get_breakUnderError get="inline" set="null" line="561"><f a=""><x path="Bool"/></f></get_breakUnderError>
		<breakUnderError public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Whether constraint will break once maxError is reached.
     * <br/><br/>
     * This property effects both stiff and non-stiff constraints.
     *
     * @default false]]></haxe_doc>
		</breakUnderError>
		<set_breakUnderForce get="inline" set="null" line="543"><f a="breakUnderForce">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_breakUnderForce>
		<get_breakUnderForce get="inline" set="null" line="540"><f a=""><x path="Bool"/></f></get_breakUnderForce>
		<breakUnderForce public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Whether constraint will break once maxForce is reached.
     * <br/><br/>
     * This property effects both stiff and non-stiff constraints, though
     * for the same reasons as those of maxForce, does not make much sense
     * to be used in stiff constraints.
     *
     * @default false]]></haxe_doc>
		</breakUnderForce>
		<set_maxError get="inline" set="null" line="512"><f a="maxError">
	<x path="Float"/>
	<x path="Float"/>
</f></set_maxError>
		<get_maxError get="inline" set="null" line="509"><f a=""><x path="Float"/></f></get_maxError>
		<maxError public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The maximum amount of error this constraint is allowed to use.
     * <br/><br/>
     * For stiff constraints, this value only serves to work in conjunction
     * with breakUnderError to permit breaking of the constraint.
     * <br/><br/>
     * For non-stiff constraints, this value will also effect how the constraint
     * behaves when breakUnderError is false by restricting the amount of error
     * that will be resolved; this will not work for stiff constraints.
     *
     * @default infinity]]></haxe_doc>
		</maxError>
		<set_maxForce get="inline" set="null" line="478"><f a="maxForce">
	<x path="Float"/>
	<x path="Float"/>
</f></set_maxForce>
		<get_maxForce get="inline" set="null" line="475"><f a=""><x path="Float"/></f></get_maxForce>
		<maxForce public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The maximum amount of force this constraint is allowed to use.
     * <br/><br/>
     * This value, whilst still used in a stiff constraint will not work
     * as you might hope for; since a stiff constraint resolves positional
     * error without using impulses, the maxForce will not have any effect
     * on how positional errors are resolved.
     * <br/><br/>
     * This value must be zero or positive.
     *
     * @default infinity]]></haxe_doc>
		</maxForce>
		<set_damping get="inline" set="null" line="442"><f a="damping">
	<x path="Float"/>
	<x path="Float"/>
</f></set_damping>
		<get_damping get="inline" set="null" line="439"><f a=""><x path="Float"/></f></get_damping>
		<damping public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Damping ratio of elastic properties of constraint.
     * <br/><br/>
     * This property only has an effect when constraint is not stiff.
     * <br/><br/>
     * This value corresponds to in the ideal situation, the damping
     * ratio of the constraints oscillations with 1 corresponding to
     * a total dampening, and values greater than one being over-dampening.
     * <br/><br/>
     * This value must be zero or positive.
     *
     * @default 1]]></haxe_doc>
		</damping>
		<set_frequency get="inline" set="null" line="405"><f a="frequency">
	<x path="Float"/>
	<x path="Float"/>
</f></set_frequency>
		<get_frequency get="inline" set="null" line="402"><f a=""><x path="Float"/></f></get_frequency>
		<frequency public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Frequency of elastic properties of constraint.
     * <br/><br/>
     * This property only has an effect when constraint is not stiff.
     * <br/><br/>
     * This value corresponds to in an ideal situation, the number of
     * spring like oscillations the constraint will make per second.
     * <br/><br/>
     * This value must be strictly positive (0 not allowed).
     *
     * @default 10]]></haxe_doc>
		</frequency>
		<set_stiff get="inline" set="null" line="379"><f a="stiff">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_stiff>
		<get_stiff get="inline" set="null" line="376"><f a=""><x path="Bool"/></f></get_stiff>
		<stiff public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Whether constraint is stiff, or elastic.
     * <br/><br/>
     * A stiff constraint has its positional error resolved directly
     * as with contact penetrations. This is generally a more stable
     * way of solving positional errors but has a side-effect that for example
     * changing the pivot point on a constraint used for mouse control will not
     * cause the objects to swing as the positional error is solved without
     * effecting the velocity of the object which may not be wanted.
     * <br/><br/>
     * If false, then the positional error of the constraint will be
     * resolved in an elastic way using changes in velocity.
     *
     * @default true]]></haxe_doc>
		</stiff>
		<set_ignore get="inline" set="null" line="350"><f a="ignore">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_ignore>
		<get_ignore get="inline" set="null" line="347"><f a=""><x path="Bool"/></f></get_ignore>
		<ignore public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Whether interactions between related Bodys will be ignored.
     * <br/><br/>
     * If true, then the Bodys related to this constraint will not
     * be permitted to interact in anyway, including callbacks.
     *
     * @default false]]></haxe_doc>
		</ignore>
		<set_active get="inline" set="null" line="312"><f a="active">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_active>
		<get_active get="inline" set="null" line="309"><f a=""><x path="Bool"/></f></get_active>
		<active public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Whether this constraint is active or not.
     * <br/><br/>
     * Setting a constraint to be no longer active is a useful way of
     * temporarigly disabling a constraint without having to remove it
     * from a Space.
     *
     * @default true]]></haxe_doc>
		</active>
		<get_isSleeping get="inline" set="null" line="290"><f a=""><x path="Bool"/></f></get_isSleeping>
		<isSleeping public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Whether this constraint is sleeping or not.
     * <br/><br/>
     * This property is only defined if the constraint is inside of a Space
     * and is active, otherwise an error will be thrown should you access this
     * property.
     * <br/><br/>
     * This value is immutable, In Nape you do not ever need to manually
     * wake up a Constraint. It will always be done automatically without error.
     * <br/><br/>
     * To manually put a Constraint to sleep is against the very nature of Nape
     * API and so is excluded from the core of Nape. If you really want to do this
     * you should make use of the nape-hacks module.]]></haxe_doc>
		</isSleeping>
		<set_space get="inline" set="null" line="251"><f a="space">
	<t path="Null"><c path="nape.space.Space"/></t>
	<t path="Null"><c path="nape.space.Space"/></t>
</f></set_space>
		<get_space get="inline" set="null" line="248"><f a=""><t path="Null"><c path="nape.space.Space"/></t></f></get_space>
		<space public="1" get="accessor" set="accessor">
			<t path="Null"><c path="nape.space.Space"/></t>
			<haxe_doc><![CDATA[* Space this constraint is inside of.
     * <br/><br/>
     * Whether this constraint is directly in a Space, or part of a Compound
     * which is inside of a space, this value will be equal to that Space.
     * <br/><br/>
     * If this constraint is inside of a Compound, then you cannot modify its
     * Space as the constraint belongs to that Compound.
     *
     * @default null]]></haxe_doc>
		</space>
		<set_compound get="inline" set="null" line="222"><f a="compound">
	<t path="Null"><c path="nape.phys.Compound"/></t>
	<t path="Null"><c path="nape.phys.Compound"/></t>
</f></set_compound>
		<get_compound get="inline" set="null" line="219"><f a=""><t path="Null"><c path="nape.phys.Compound"/></t></f></get_compound>
		<compound public="1" get="accessor" set="accessor">
			<t path="Null"><c path="nape.phys.Compound"/></t>
			<haxe_doc><![CDATA[* Compound this Constraints belong to.
     * <br/><br/>
     * If this constraint is in a Space or another Compound and you change
     * its compound, then it will be removed from that Space or Compound.
     *
     * @default null]]></haxe_doc>
		</compound>
		<debugDraw public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Set to disable debug drawing/
     * <br/><br/>
     * When true, this Constraint will not be drawn during debug draw operations
     * unless specifically given as argument to Debug draw() method.
     * @default true]]></haxe_doc>
		</debugDraw>
		<get_userData get="inline" set="null" line="195"><f a=""><d><d/></d></f></get_userData>
		<userData public="1" get="accessor" set="null">
			<d><d/></d>
			<haxe_doc><![CDATA[* Dynamic object for user to store additional data.
     * <br/><br/>
     * This object cannot be set, only its dynamically created
     * properties may be set. In AS3 the type of this property is &#42
     * <br/><br/>
     * This object will be lazily constructed so that until accessed
     * for the first time, will be null internally.
     *
     * @default {}]]></haxe_doc>
		</userData>
		<zpp_inner public="1">
			<c path="zpp_nape.constraint.ZPP_Constraint"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="641">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc>* Base type for all Nape joints and constraints</haxe_doc>
	</class>
	<class path="nape.constraint.AngleJoint" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/constraint/AngleJoint.hx">
		<extends path="nape.constraint.Constraint"/>
		<visitBodies public="1" set="method" line="427" override="1">
			<f a="lambda">
				<f a="">
					<c path="nape.phys.Body"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</visitBodies>
		<bodyImpulse public="1" set="method" line="408" override="1">
			<f a="body">
				<c path="nape.phys.Body"/>
				<c path="nape.geom.Vec3"/>
			</f>
			<haxe_doc><![CDATA[* @inheritDoc
     * <br/><br/>
     * For this constraint, only the z coordinate will be non-zero.]]></haxe_doc>
		</bodyImpulse>
		<impulse public="1" set="method" line="398" override="1">
			<f a=""><c path="nape.geom.MatMN"/></f>
			<haxe_doc><![CDATA[* @inheritDoc
     * <br/><br/>
     * For this constraint, the MatMN will be 1x1.]]></haxe_doc>
		</impulse>
		<isSlack public="1" get="inline" set="null" line="353">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[* Determine if constraint is slack.
     * <br/><br/>
     * This constraint is slack if the positional error is within
     * the bounds of (jointMin, jointMax).
     *
     * @return True if positional error of constraint is between the limits
     *              indicating that the constraint is not doing any work.
     * @throws # If either of the bodies is null.]]></haxe_doc>
		</isSlack>
		<set_ratio get="inline" set="null" line="327"><f a="ratio">
	<x path="Float"/>
	<x path="Float"/>
</f></set_ratio>
		<get_ratio get="inline" set="null" line="324"><f a=""><x path="Float"/></f></get_ratio>
		<ratio public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* Ratio property of constraint.
     *
     * @default 1</haxe_doc>
		</ratio>
		<set_jointMax get="inline" set="null" line="302"><f a="jointMax">
	<x path="Float"/>
	<x path="Float"/>
</f></set_jointMax>
		<get_jointMax get="inline" set="null" line="299"><f a=""><x path="Float"/></f></get_jointMax>
		<jointMax public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Upper bound for constraint.
     * <br/><br/>
     * This value must be greater than or equal to jointMin.
     *
     * @default infinity]]></haxe_doc>
		</jointMax>
		<set_jointMin get="inline" set="null" line="275"><f a="jointMin">
	<x path="Float"/>
	<x path="Float"/>
</f></set_jointMin>
		<get_jointMin get="inline" set="null" line="272"><f a=""><x path="Float"/></f></get_jointMin>
		<jointMin public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Lower bound for constraint.
     * <br/><br/>
     * This value must be less than or equal to jointMax.
     *
     * @default -infinity]]></haxe_doc>
		</jointMin>
		<set_body2 get="inline" set="null" line="236"><f a="body2">
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
</f></set_body2>
		<get_body2 get="inline" set="null" line="233"><f a=""><t path="Null"><c path="nape.phys.Body"/></t></f></get_body2>
		<body2 public="1" get="accessor" set="accessor">
			<t path="Null"><c path="nape.phys.Body"/></t>
			<haxe_doc><![CDATA[* Second Body in constraint.
     * <br/><br/>
     * This value may be null, but trying to simulate the constraint whilst
     * this body is null will result in an error.]]></haxe_doc>
		</body2>
		<set_body1 get="inline" set="null" line="198"><f a="body1">
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
</f></set_body1>
		<get_body1 get="inline" set="null" line="195"><f a=""><t path="Null"><c path="nape.phys.Body"/></t></f></get_body1>
		<body1 public="1" get="accessor" set="accessor">
			<t path="Null"><c path="nape.phys.Body"/></t>
			<haxe_doc><![CDATA[* First Body in constraint.
     * <br/><br/>
     * This value may be null, but trying to simulate the constraint whilst
     * this body is null will result in an error.]]></haxe_doc>
		</body1>
		<zpp_inner_zn public="1">
			<c path="zpp_nape.constraint.ZPP_AngleJoint"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner_zn>
		<new public="1" set="method" line="373">
			<f a="body1:body2:jointMin:jointMax:?ratio">
				<t path="Null"><c path="nape.phys.Body"/></t>
				<t path="Null"><c path="nape.phys.Body"/></t>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Construct a new AngleJoint.
     *
     * @param body1 The first body in AngleJoint.
     * @param body2 The second body in AngleJoint.
     * @param jointMin The lower bound for constraint.
     * @param jointMax The upper bound for constraint.
     * @param ratio The ratio of joint (default 1)
     * @return The constructed AngleJoint.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* AngleJoint constraining the relative angles of two Bodies.
 * <br/><br/>
 * The equation for this constraint is:
 * <pre>
 * jointMin <= ratio * body2.rotation - body1.rotation <= jointMax
 * </pre>]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.constraint.ConstraintIterator" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/constraint/ConstraintIterator.hx">
		<zpp_pool public="1" line="194" static="1">
			<c path="nape.constraint.ConstraintIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_pool>
		<get public="1" set="method" line="217" static="1">
			<f a="list">
				<c path="nape.constraint.ConstraintList"/>
				<c path="nape.constraint.ConstraintIterator"/>
			</f>
			<haxe_doc><![CDATA[* Create iterator for Nape list.
     * <br/><br/>
     * There is no specific reason to use this over: <code>list.iterator()</code>
     * especcialy since this requires writing the class name :)
     * (This function is used internally)
     *
     * @param list The Nape list to create iterator for.
     * @return     An iterator over the Nape list.]]></haxe_doc>
		</get>
		<next public="1" get="inline" set="null" line="264">
			<f a=""><c path="nape.constraint.Constraint"/></f>
			<haxe_doc>* Return next element in list.
     *
     * @return The next element in iteration.</haxe_doc>
		</next>
		<hasNext public="1" get="inline" set="null" line="240">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Check if there are any elements remaining.
     *
     * @return True if there are more elements to iterator over.</haxe_doc>
		</hasNext>
		<zpp_next public="1">
			<c path="nape.constraint.ConstraintIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_next>
		<zpp_critical public="1">
			<x path="Bool"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_critical>
		<zpp_i public="1">
			<x path="Int"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_i>
		<zpp_inner public="1">
			<c path="nape.constraint.ConstraintList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="202">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Haxe Iterator<T> compatible iterator over Nape list.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.constraint.ConstraintList" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/constraint/ConstraintList.hx">
		<fromArray public="1" set="method" line="304" static="1">
			<f a="array">
				<c path="Array"><c path="nape.constraint.Constraint"/></c>
				<c path="nape.constraint.ConstraintList"/>
			</f>
			<haxe_doc>* Convert standard Array to Nape list.
     *
     * @param array The array to be converted
     * @return An equivalent Nape list.
     * @throws If array argument is null.
     * @throws If array contains elements of type other than Constraint</haxe_doc>
		</fromArray>
		<filter public="1" set="method" line="779">
			<f a="lambda">
				<f a="">
					<c path="nape.constraint.Constraint"/>
					<x path="Bool"/>
				</f>
				<c path="nape.constraint.ConstraintList"/>
			</f>
			<haxe_doc><![CDATA[* Iterate over list filtering elements.
     * <br/><br/>
     * The given function will be applied to each element, whenever the
     * function returns false, the element will be removed from the list.
     * <br/><br/>
     * Any exception thrown by the supplied function will be treat as a
     * signal to halt iteration acting as a 'break' statement.
     * <br/><br/>
     * This method is to be greatly preferred for filtering logic as
     * it is otherwise unsafe to modify the list during an iteration.
     * <br/><br/>
     * An example of using this method to clean up a list whilst performing
     * actions on the elements.
     * <pre>
     * list.filter(function (obj) {
     *    // perform clean up with obj
     *    return false; // remove from list.
     * });
     * </pre>
     *
     * @param lambda The function to apply to each argument, deciding if
     *               element should be removed.
     * @return A reference to 'this' list.
     * @throws # If lambda argument is null.]]></haxe_doc>
		</filter>
		<foreach public="1" get="inline" set="null" line="732">
			<f a="lambda">
				<f a="">
					<c path="nape.constraint.Constraint"/>
					<x path="Void"/>
				</f>
				<c path="nape.constraint.ConstraintList"/>
			</f>
			<haxe_doc><![CDATA[* Iterate over list applying function.
     * <br/><br/>
     * Any exception thrown by the supplied function will be treat as a
     * signal to halt iteration acting as a 'break' statement.
     * <br/><br/>
     * This method should be preferred to using standard haxe iteration
     * as there will be no allocation of an iterator object.
     * <pre>
     * list.foreach(function (obj) {
     *     if (ignore_object(obj)) return; //acts as a 'continue' statement
     *     if (halt_iteration(obj)) throw "": //acts as a 'break' statement
     * });
     * </pre>
     *
     * @param lambda The function to apply to each argument.
     * @return A reference to 'this' list.
     * @throws # If lambda argument is null.]]></haxe_doc>
		</foreach>
		<toString public="1" set="method" line="702">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<merge public="1" set="method" line="684">
			<f a="xs">
				<c path="nape.constraint.ConstraintList"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Merge given list into this one.
     * <br/><br/>
     * The result is that this list will have all objects from the argument
     * that were not already in the list inserted. You should make no
     * assumption about the order of these insertions.
     *
     * @param xs The list to merge.
     * @throws # If xs argument is null.]]></haxe_doc>
		</merge>
		<copy public="1" set="method" line="662">
			<f a="?deep">
				<x path="Bool"/>
				<c path="nape.constraint.ConstraintList"/>
			</f>
			<haxe_doc>* Produce a possibly deep copy of list.
     *
     * @param deep If true, then each element will have its own copy
     *             function called instead of simply having its
     *             reference copied over.
     * @return     The copied list.</haxe_doc>
		</copy>
		<iterator public="1" get="inline" set="null" line="647">
			<f a=""><c path="nape.constraint.ConstraintIterator"/></f>
			<haxe_doc><![CDATA[* Return Haxe iterator for list.
     * <br/><br/>
     * Use of this iterator, whilst stylistically better in Haxe should not
     * be used, in preference for use of the foreach function which will
     * not require allocation of an iterator object.
     * <br/><br/>
     * Equally in AS3, the foreach method should be the preferred way to iterate.]]></haxe_doc>
		</iterator>
		<empty public="1" get="inline" set="null" line="631">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Test if list is empty or not.
     *
     * @return True if list is empty.</haxe_doc>
		</empty>
		<clear public="1" set="method" line="614">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clear the list, removing all elements.
     *
     * @throws # If list is iummutable</haxe_doc>
		</clear>
		<remove public="1" set="method" line="576">
			<f a="obj">
				<c path="nape.constraint.Constraint"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Remove element from list.
     * <br/><br/>
     * This is a linear time operation.
     *
     * @param obj The object to remove
     * @return True if object was removed from list.
     * @throws # If list is immutable]]></haxe_doc>
		</remove>
		<add public="1" get="inline" set="null" line="563">
			<f a="obj">
				<c path="nape.constraint.Constraint"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Insert element into list in most effecient way.
     * <br/><br/>
     * This method will defer to either the push or unshift function
     * depending on which is most effecient in the context.
     * <br/><br/>
     * If order of elements is not important then you should always use
     * this function to insert elements.
     *
     * @param obj The object to insert.
     * @return True if object was successfuly inserted.
     * @throws # If list is immutable]]></haxe_doc>
		</add>
		<shift public="1" set="method" line="519">
			<f a=""><c path="nape.constraint.Constraint"/></f>
			<haxe_doc><![CDATA[* Pop element from front of list.
     * <br/><br/>
     * If you are wanting to clear a list, whilst operating on its elements,
     * consider use of the filter method instead.
     *
     * @returns The element removed from list.
     * @throws # If list is immutable.
     * @throws # If the list is empty.]]></haxe_doc>
		</shift>
		<pop public="1" set="method" line="478">
			<f a=""><c path="nape.constraint.Constraint"/></f>
			<haxe_doc><![CDATA[* Pop element from back of list.
     * <br/><br/>
     * If you are wanting to clear a list, whilst operating on its elements,
     * consider use of the filter method instead.
     *
     * @returns The element removed from list.
     * @throws # If list is immutable.
     * @throws # If the list is empty.]]></haxe_doc>
		</pop>
		<unshift public="1" set="method" line="447">
			<f a="obj">
				<c path="nape.constraint.Constraint"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Push element to front of list.
     * <br/><br/>
     * When the order of objects is not important, it is best to use the
     * add() method instead.
     *
     * @param obj The object to insert.
     * @returns True if object was successively inserted.
     * @throws # If list is immutable.]]></haxe_doc>
		</unshift>
		<push public="1" set="method" line="416">
			<f a="obj">
				<c path="nape.constraint.Constraint"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Push element to back of list.
     * <br/><br/>
     * When the order of objects is not important, it is best to use the
     * add() method instead.
     *
     * @param obj The object to insert.
     * @returns True if object was successively inserted.
     * @throws # If list is immutable.]]></haxe_doc>
		</push>
		<at public="1" set="method" line="363">
			<f a="index">
				<x path="Int"/>
				<c path="nape.constraint.Constraint"/>
			</f>
			<haxe_doc><![CDATA[* Random access to elements of list by index.
     * <br/><br/>
     * Under normal circumstances, accessing succesive elements via this
     * method will occur in constant time.
     *
     * @param index The index of the element in list to access.
     * @returns The element at the given index.
     * @throws # If index is out of bounds.]]></haxe_doc>
		</at>
		<has public="1" set="method" line="346">
			<f a="obj">
				<c path="nape.constraint.Constraint"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if element is already in the list
     *
     * @param obj The object to test.
     * @return True if object is in the list.</haxe_doc>
		</has>
		<get_length get="inline" set="null" line="244"><f a=""><x path="Int"/></f></get_length>
		<length public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Length of list.</haxe_doc>
		</length>
		<zpp_inner public="1">
			<c path="zpp_nape.util.ZPP_ConstraintList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="695">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Construct a new list.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Nape list of Constraint type objects
 * <br/><br/>
 * Internally this list is at present implemented as a linked list with
 * object pooled nodes and iterators with various fast paths made for
 * standard access patterns (For instance accessing successive elements
 * runs in constant time when using random access functions)
 * <br/><br/>
 * Iteration of this list can be done in various ways, but the preferred
 * way on all targets, is through use of the foreach function:
 * <pre>
 * list.foreach(function (obj) {
 * });
 * </pre>
 * This method is inlined so that in haxe no closure will need to be created.
 * <br/><br/>
 * In AS3, a closure would need to be created in general, so for performance
 * reasons you 'may' choose to use iteration as follows:
 * <pre>
 * for (var i:int = 0; i < list.length; i++) {
 *     var obj:Constraint = list.at(i);
 * }
 * </pre>
 * <br/>
 * NOTE: It is 'not' safe to modify a list whilst iterating over it.
 * If you wish to remove elements during an iteration you should use the
 * filter method, for example:
 * <pre>
 * list.filter(function (obj) {
 *     // operate on object.
 *     // ...
 *     return (false if you want object to be removed);
 * });
 * </pre>
 * <br/><br/>
 * In AS3, if you wish to avoid a closure generation, you can perform such
 * an iteration in a safe manner as follows:
 * <pre>
 * var i:int = 0;
 * while (i < list.length) {
 *     var obj:Constraint = list.at(i);
 *     // operate on object.
 *     // ...
 *     if (should remove obj) {
 *         list.remove(obj);
 *         continue;
 *     }
 *     else i++;
 * }
 * </pre>
 * Or if you are always clearing the list entirely you could write:
 * <pre>
 * while (!list.empty()) {
 *     var obj:Constraint = list.pop();
 *     // operate on object.
 *     // ...
 * }
 * </pre>]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.constraint.DistanceJoint" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/constraint/DistanceJoint.hx">
		<extends path="nape.constraint.Constraint"/>
		<visitBodies public="1" set="method" line="456" override="1">
			<f a="lambda">
				<f a="">
					<c path="nape.phys.Body"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</visitBodies>
		<bodyImpulse public="1" set="method" line="437" override="1">
			<f a="body">
				<c path="nape.phys.Body"/>
				<c path="nape.geom.Vec3"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</bodyImpulse>
		<impulse public="1" set="method" line="429" override="1">
			<f a=""><c path="nape.geom.MatMN"/></f>
			<haxe_doc><![CDATA[* @inheritDoc
     * <br/><br/>
     * For this constraint, the MatMN will be 1x1.]]></haxe_doc>
		</impulse>
		<isSlack public="1" get="inline" set="null" line="382">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[* Determine if constraint is slack.
     * <br/><br/>
     * This constraint is slack if the positional error is within
     * the bounds of (jointMin, jointMax).
     *
     * @return True if positional error of constraint is between the limits
     *              indicating that the constraint is not doing any work.
     * @throws # If either of the bodies is null.]]></haxe_doc>
		</isSlack>
		<set_jointMax get="inline" set="null" line="353"><f a="jointMax">
	<x path="Float"/>
	<x path="Float"/>
</f></set_jointMax>
		<get_jointMax get="inline" set="null" line="350"><f a=""><x path="Float"/></f></get_jointMax>
		<jointMax public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Upper bound for constraint.
     * <br/><br/>
     * This value must be greater than or equal to jointMin.]]></haxe_doc>
		</jointMax>
		<set_jointMin get="inline" set="null" line="325"><f a="jointMin">
	<x path="Float"/>
	<x path="Float"/>
</f></set_jointMin>
		<get_jointMin get="inline" set="null" line="322"><f a=""><x path="Float"/></f></get_jointMin>
		<jointMin public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Lower bound for constraint.
     * <br/><br/>
     * This value must be less than or equal to jointMax, and greater equal to 0.]]></haxe_doc>
		</jointMin>
		<set_anchor2 get="inline" set="null" line="301"><f a="anchor2">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_anchor2>
		<get_anchor2 get="inline" set="null" line="297"><f a=""><c path="nape.geom.Vec2"/></f></get_anchor2>
		<anchor2 public="1" get="accessor" set="accessor">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* Anchor point on second Body.
     * <br/><br/>
     * This anchor point is defined in the local coordinate system of body2.]]></haxe_doc>
		</anchor2>
		<set_anchor1 get="inline" set="null" line="276"><f a="anchor1">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_anchor1>
		<get_anchor1 get="inline" set="null" line="272"><f a=""><c path="nape.geom.Vec2"/></f></get_anchor1>
		<anchor1 public="1" get="accessor" set="accessor">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* Anchor point on first Body.
     * <br/><br/>
     * This anchor point is defined in the local coordinate system of body1.]]></haxe_doc>
		</anchor1>
		<set_body2 get="inline" set="null" line="238"><f a="body2">
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
</f></set_body2>
		<get_body2 get="inline" set="null" line="235"><f a=""><t path="Null"><c path="nape.phys.Body"/></t></f></get_body2>
		<body2 public="1" get="accessor" set="accessor">
			<t path="Null"><c path="nape.phys.Body"/></t>
			<haxe_doc><![CDATA[* Second Body in constraint.
     * <br/><br/>
     * This value may be null, but trying to simulate the constraint whilst
     * this body is null will result in an error.]]></haxe_doc>
		</body2>
		<set_body1 get="inline" set="null" line="200"><f a="body1">
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
</f></set_body1>
		<get_body1 get="inline" set="null" line="197"><f a=""><t path="Null"><c path="nape.phys.Body"/></t></f></get_body1>
		<body1 public="1" get="accessor" set="accessor">
			<t path="Null"><c path="nape.phys.Body"/></t>
			<haxe_doc><![CDATA[* First Body in constraint.
     * <br/><br/>
     * This value may be null, but trying to simulate the constraint whilst
     * this body is null will result in an error.]]></haxe_doc>
		</body1>
		<zpp_inner_zn public="1">
			<c path="zpp_nape.constraint.ZPP_DistanceJoint"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner_zn>
		<new public="1" set="method" line="403">
			<f a="body1:body2:anchor1:anchor2:jointMin:jointMax">
				<t path="Null"><c path="nape.phys.Body"/></t>
				<t path="Null"><c path="nape.phys.Body"/></t>
				<c path="nape.geom.Vec2"/>
				<c path="nape.geom.Vec2"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Construct a new DistanceJoint.
     *
     * @param body1 The first body in DistanceJoint.
     * @param body2 The second body in DistanceJoint.
     * @param anchor1 The first local anchor for joint.
     * @param anchor2 The second local anchor for joint.
     * @param jointMin The lower bound for constraint.
     * @param jointMax The upper bound for constraint.
     * @return The constructed DistanceJoint.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* DistanceJoint limiting the distance between two local anchor points of Bodies.
 * <br/><br/>
 * The equation for this constraint could be written like:
 * <pre>
 * jointMin <= distance(body2.localPointToWorld(anchor2), body1.localPointToWorld(anchor1)) <= jointMax
 * </pre>
 * This joint is not designed to work when <code> jointMin = jointMax = 0 </code> and constraint is
 * stiff. In this instance you should use a PivotJoint instead.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.constraint.LineJoint" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/constraint/LineJoint.hx">
		<extends path="nape.constraint.Constraint"/>
		<visitBodies public="1" set="method" line="484" override="1">
			<f a="lambda">
				<f a="">
					<c path="nape.phys.Body"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</visitBodies>
		<bodyImpulse public="1" set="method" line="465" override="1">
			<f a="body">
				<c path="nape.phys.Body"/>
				<c path="nape.geom.Vec3"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</bodyImpulse>
		<impulse public="1" set="method" line="456" override="1">
			<f a=""><c path="nape.geom.MatMN"/></f>
			<haxe_doc><![CDATA[* @inheritDoc
     * <br/><br/>
     * For this constraint, the MatMN will be 2x1.]]></haxe_doc>
		</impulse>
		<set_jointMax get="inline" set="null" line="400"><f a="jointMax">
	<x path="Float"/>
	<x path="Float"/>
</f></set_jointMax>
		<get_jointMax get="inline" set="null" line="397"><f a=""><x path="Float"/></f></get_jointMax>
		<jointMax public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Upper bound for constraint.
     * <br/><br/>
     * This value must be greater than or equal to jointMin.]]></haxe_doc>
		</jointMax>
		<set_jointMin get="inline" set="null" line="375"><f a="jointMin">
	<x path="Float"/>
	<x path="Float"/>
</f></set_jointMin>
		<get_jointMin get="inline" set="null" line="372"><f a=""><x path="Float"/></f></get_jointMin>
		<jointMin public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Lower bound for constraint.
     * <br/><br/>
     * This value must be less than or equal to jointMax.]]></haxe_doc>
		</jointMin>
		<set_direction get="inline" set="null" line="351"><f a="direction">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_direction>
		<get_direction get="inline" set="null" line="347"><f a=""><c path="nape.geom.Vec2"/></f></get_direction>
		<direction public="1" get="accessor" set="accessor">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* Direction of line on first Body.
     * <br/><br/>
     * This direction is defined in the local coordinate system of body1 and
     * need not be normalised.]]></haxe_doc>
		</direction>
		<set_anchor2 get="inline" set="null" line="325"><f a="anchor2">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_anchor2>
		<get_anchor2 get="inline" set="null" line="321"><f a=""><c path="nape.geom.Vec2"/></f></get_anchor2>
		<anchor2 public="1" get="accessor" set="accessor">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* Anchor point on second Body.
     * <br/><br/>
     * This anchor point is defined in the local coordinate system of body2.]]></haxe_doc>
		</anchor2>
		<set_anchor1 get="inline" set="null" line="300"><f a="anchor1">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_anchor1>
		<get_anchor1 get="inline" set="null" line="296"><f a=""><c path="nape.geom.Vec2"/></f></get_anchor1>
		<anchor1 public="1" get="accessor" set="accessor">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* Anchor point on first Body, defining position on line.
     * <br/><br/>
     * This anchor point is defined in the local coordinate system of body1.]]></haxe_doc>
		</anchor1>
		<set_body2 get="inline" set="null" line="262"><f a="body2">
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
</f></set_body2>
		<get_body2 get="inline" set="null" line="259"><f a=""><t path="Null"><c path="nape.phys.Body"/></t></f></get_body2>
		<body2 public="1" get="accessor" set="accessor">
			<t path="Null"><c path="nape.phys.Body"/></t>
			<haxe_doc><![CDATA[* Second Body in constraint.
     * <br/><br/>
     * This value may be null, but trying to simulate the constraint whilst
     * this body is null will result in an error.]]></haxe_doc>
		</body2>
		<set_body1 get="inline" set="null" line="224"><f a="body1">
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
</f></set_body1>
		<get_body1 get="inline" set="null" line="221"><f a=""><t path="Null"><c path="nape.phys.Body"/></t></f></get_body1>
		<body1 public="1" get="accessor" set="accessor">
			<t path="Null"><c path="nape.phys.Body"/></t>
			<haxe_doc><![CDATA[* First Body in constraint, defining the line segment.
     * <br/><br/>
     * This value may be null, but trying to simulate the constraint whilst
     * this body is null will result in an error.]]></haxe_doc>
		</body1>
		<zpp_inner_zn public="1">
			<c path="zpp_nape.constraint.ZPP_LineJoint"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner_zn>
		<new public="1" set="method" line="429">
			<f a="body1:body2:anchor1:anchor2:direction:jointMin:jointMax">
				<t path="Null"><c path="nape.phys.Body"/></t>
				<t path="Null"><c path="nape.phys.Body"/></t>
				<c path="nape.geom.Vec2"/>
				<c path="nape.geom.Vec2"/>
				<c path="nape.geom.Vec2"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Construct a new LineJoint.
     *
     * @param body1 The first body in LineJoint.
     * @param body2 The second body in LineJoint.
     * @param anchor1 The first local anchor for joint.
     * @param anchor2 The second local anchor for joint.
     * @param direction The direction of local line for joint.
     * @param jointMin The lower bound for constraint.
     * @param jointMax The upper bound for constraint.
     * @return The constructed LineJoint.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* LineJoint constraining anchor of one body, to a line segment of the other.
 * <br/><br/>
 * The equation for this constraint could be written like:
 * <pre>
 *        0  = [dir.cross(delta)]  = 0
 * jointMin <= [dor.dot  (delta)] <= jointMax
 * </pre>
 * where:
 * <pre>
 * dir   = body1.localVectorToWorld(direction).unit();
 * delta = body2.localPointToWorld(anchor2).sub(body1.localPointToWorld(anchor1));
 * </pre>
 * This is a 2 dimensional constraint, and is (when at the limits) solved as a
 * block constraint for better stability. This is however not the most stable
 * of joint when chained and put under stress and is a rather rare case where
 * using a non-stiff joint can actually be more stable than
 * using a stiff one.
 * <br/><br/>
 * When <code> jointMin = jointMax </code>, it would be better to use a PivotJoint
 *instead with suitable
 * placed anchors.
 * <br/><br/>
 * The line segment is defined implicitly via the
 * <code>anchor1, direction, jointMin and jointMax</code> properties with end
 * points defined in local coordinate system of body1 like:
 * <pre>
 * start = anchor1.add(direction.unit().mul(jointMin))
 * end   = anchor1.add(direction.unit().mul(jointMax))
 * </pre>
 * The reason for this more general description of a line segment is that one or
 * both of jointMin, jointMax are permitted to be infinite and a line segment
 * defined with a start and end point is not sufficient to describe such lines.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.constraint.MotorJoint" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/constraint/MotorJoint.hx">
		<extends path="nape.constraint.Constraint"/>
		<visitBodies public="1" set="method" line="378" override="1">
			<f a="lambda">
				<f a="">
					<c path="nape.phys.Body"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</visitBodies>
		<bodyImpulse public="1" set="method" line="359" override="1">
			<f a="body">
				<c path="nape.phys.Body"/>
				<c path="nape.geom.Vec3"/>
			</f>
			<haxe_doc><![CDATA[* @inheritDoc
     * <br/><br/>
     * For this constraint, only the z coordinate will be non-zero.]]></haxe_doc>
		</bodyImpulse>
		<impulse public="1" set="method" line="349" override="1">
			<f a=""><c path="nape.geom.MatMN"/></f>
			<haxe_doc><![CDATA[* @inheritDoc
     * <br/><br/>
     * For this constraint, the MatMN will be 1x1.]]></haxe_doc>
		</impulse>
		<set_rate get="inline" set="null" line="299"><f a="rate">
	<x path="Float"/>
	<x path="Float"/>
</f></set_rate>
		<get_rate get="inline" set="null" line="296"><f a=""><x path="Float"/></f></get_rate>
		<rate public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* MotorJoint rate
     *
     * @default 0</haxe_doc>
		</rate>
		<set_ratio get="inline" set="null" line="274"><f a="ratio">
	<x path="Float"/>
	<x path="Float"/>
</f></set_ratio>
		<get_ratio get="inline" set="null" line="271"><f a=""><x path="Float"/></f></get_ratio>
		<ratio public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* MotorJoint ratio.
     *
     * @default 1</haxe_doc>
		</ratio>
		<set_body2 get="inline" set="null" line="237"><f a="body2">
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
</f></set_body2>
		<get_body2 get="inline" set="null" line="234"><f a=""><t path="Null"><c path="nape.phys.Body"/></t></f></get_body2>
		<body2 public="1" get="accessor" set="accessor">
			<t path="Null"><c path="nape.phys.Body"/></t>
			<haxe_doc><![CDATA[* Second Body in constraint.
     * <br/><br/>
     * This value may be null, but trying to simulate the constraint whilst
     * this body is null will result in an error.]]></haxe_doc>
		</body2>
		<set_body1 get="inline" set="null" line="199"><f a="body1">
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
</f></set_body1>
		<get_body1 get="inline" set="null" line="196"><f a=""><t path="Null"><c path="nape.phys.Body"/></t></f></get_body1>
		<body1 public="1" get="accessor" set="accessor">
			<t path="Null"><c path="nape.phys.Body"/></t>
			<haxe_doc><![CDATA[* First Body in constraint.
     * <br/><br/>
     * This value may be null, but trying to simulate the constraint whilst
     * this body is null will result in an error.]]></haxe_doc>
		</body1>
		<zpp_inner_zn public="1">
			<c path="zpp_nape.constraint.ZPP_MotorJoint"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner_zn>
		<new public="1" set="method" line="325">
			<f a="body1:body2:?rate:?ratio">
				<t path="Null"><c path="nape.phys.Body"/></t>
				<t path="Null"><c path="nape.phys.Body"/></t>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Construct a new MotorJoint
     *
     * @param body1 The first body in MotorJoint
     * @param body2 The second body in MotorJoint
     * @param rate The rate of motor. (default 0)
     * @param ratio The ratio of the motor. (default 1)
     * @return The constructed MotorJoint.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* MotorJoint constraining the angular velocities of two bodies
 * <br/><br/>
 * The equation for this constraint is:
 * <pre>
 * (ratio * body2.angularVel) - body1.angularVel = rate
 * </pre>
 * This constraint operates only on the velocities of objects.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.constraint.PivotJoint" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/constraint/PivotJoint.hx">
		<extends path="nape.constraint.Constraint"/>
		<visitBodies public="1" set="method" line="380" override="1">
			<f a="lambda">
				<f a="">
					<c path="nape.phys.Body"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</visitBodies>
		<bodyImpulse public="1" set="method" line="361" override="1">
			<f a="body">
				<c path="nape.phys.Body"/>
				<c path="nape.geom.Vec3"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</bodyImpulse>
		<impulse public="1" set="method" line="352" override="1">
			<f a=""><c path="nape.geom.MatMN"/></f>
			<haxe_doc><![CDATA[* @inheritDoc
     * <br/><br/>
     * For this constraint, the MatMN will be 2x1.]]></haxe_doc>
		</impulse>
		<set_anchor2 get="inline" set="null" line="303"><f a="anchor2">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_anchor2>
		<get_anchor2 get="inline" set="null" line="299"><f a=""><c path="nape.geom.Vec2"/></f></get_anchor2>
		<anchor2 public="1" get="accessor" set="accessor">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* Anchor point on second Body.
     * <br/><br/>
     * This anchor point is defined in the local coordinate system of body2.]]></haxe_doc>
		</anchor2>
		<set_anchor1 get="inline" set="null" line="278"><f a="anchor1">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_anchor1>
		<get_anchor1 get="inline" set="null" line="274"><f a=""><c path="nape.geom.Vec2"/></f></get_anchor1>
		<anchor1 public="1" get="accessor" set="accessor">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* Anchor point on first Body.
     * <br/><br/>
     * This anchor point is defined in the local coordinate system of body1.]]></haxe_doc>
		</anchor1>
		<set_body2 get="inline" set="null" line="240"><f a="body2">
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
</f></set_body2>
		<get_body2 get="inline" set="null" line="237"><f a=""><t path="Null"><c path="nape.phys.Body"/></t></f></get_body2>
		<body2 public="1" get="accessor" set="accessor">
			<t path="Null"><c path="nape.phys.Body"/></t>
			<haxe_doc><![CDATA[* Second Body in constraint.
     * <br/><br/>
     * This value may be null, but trying to simulate the constraint whilst
     * this body is null will result in an error.]]></haxe_doc>
		</body2>
		<set_body1 get="inline" set="null" line="202"><f a="body1">
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
</f></set_body1>
		<get_body1 get="inline" set="null" line="199"><f a=""><t path="Null"><c path="nape.phys.Body"/></t></f></get_body1>
		<body1 public="1" get="accessor" set="accessor">
			<t path="Null"><c path="nape.phys.Body"/></t>
			<haxe_doc><![CDATA[* First Body in constraint.
     * <br/><br/>
     * This value may be null, but trying to simulate the constraint whilst
     * this body is null will result in an error.]]></haxe_doc>
		</body1>
		<zpp_inner_zn public="1">
			<c path="zpp_nape.constraint.ZPP_PivotJoint"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner_zn>
		<new public="1" set="method" line="328">
			<f a="body1:body2:anchor1:anchor2">
				<t path="Null"><c path="nape.phys.Body"/></t>
				<t path="Null"><c path="nape.phys.Body"/></t>
				<c path="nape.geom.Vec2"/>
				<c path="nape.geom.Vec2"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Construct a new PivotJoint.
     *
     * @param body1 The first body in PivotJoint.
     * @param body2 The second body in PivotJoint.
     * @param anchor1 The first local anchor for joint.
     * @param anchor2 The second local anchor for joint.
     * @return The constructed PivotJoint.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* PivotJoint constraining two anchors points of bodies to be equal.
 * <br/><br/>
 * The equation for this constraint is:
 * <pre>
 * body2.localPointToWorld(anchor2) = body1.localPointToWorld(anchor1)
 * </pre>
 * You may view this constraint as being equal to the DistanceJoint constraint
 * when both its jointMin and jointMax are exactly 0 (In such a case a
 * DistanceJoint becomes degenerate). Compared to the DistanceJoint this is
 * a 2 dimensional constraint.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.constraint.PulleyJoint" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/constraint/PulleyJoint.hx">
		<extends path="nape.constraint.Constraint"/>
		<visitBodies public="1" set="method" line="620" override="1">
			<f a="lambda">
				<f a="">
					<c path="nape.phys.Body"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</visitBodies>
		<bodyImpulse public="1" set="method" line="601" override="1">
			<f a="body">
				<c path="nape.phys.Body"/>
				<c path="nape.geom.Vec3"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</bodyImpulse>
		<impulse public="1" set="method" line="593" override="1">
			<f a=""><c path="nape.geom.MatMN"/></f>
			<haxe_doc><![CDATA[* @inheritDoc
     * <br/><br/>
     * For this constraint, the MatMN will be 1x1.]]></haxe_doc>
		</impulse>
		<isSlack public="1" get="inline" set="null" line="536">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[* Determine if constraint is slack.
     * <br/><br/>
     * This constraint is slack if the positional error is within
     * the bounds of (jointMin, jointMax).
     *
     * @return True if positional error of constraint is between the limits
     *              indicating that the constraint is not doing any work.
     * @throws # If any of the bodies is null.]]></haxe_doc>
		</isSlack>
		<set_ratio get="inline" set="null" line="510"><f a="ratio">
	<x path="Float"/>
	<x path="Float"/>
</f></set_ratio>
		<get_ratio get="inline" set="null" line="507"><f a=""><x path="Float"/></f></get_ratio>
		<ratio public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* Ratio property of constraint.
     *
     * @default 1</haxe_doc>
		</ratio>
		<set_jointMax get="inline" set="null" line="482"><f a="jointMax">
	<x path="Float"/>
	<x path="Float"/>
</f></set_jointMax>
		<get_jointMax get="inline" set="null" line="479"><f a=""><x path="Float"/></f></get_jointMax>
		<jointMax public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Upper bound for constraint.
     * <br/><br/>
     * This value must be greater than or equal to jointMin.]]></haxe_doc>
		</jointMax>
		<set_jointMin get="inline" set="null" line="454"><f a="jointMin">
	<x path="Float"/>
	<x path="Float"/>
</f></set_jointMin>
		<get_jointMin get="inline" set="null" line="451"><f a=""><x path="Float"/></f></get_jointMin>
		<jointMin public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Lower bound for constraint.
     * <br/><br/>
     * This value must be less than or equal to jointMax, and greater equal to 0.]]></haxe_doc>
		</jointMin>
		<set_anchor4 get="inline" set="null" line="430"><f a="anchor4">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_anchor4>
		<get_anchor4 get="inline" set="null" line="426"><f a=""><c path="nape.geom.Vec2"/></f></get_anchor4>
		<anchor4 public="1" get="accessor" set="accessor">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* Anchor point on fourth Body.
     * <br/><br/>
     * This anchor point is defined in the local coordinate system of body4.]]></haxe_doc>
		</anchor4>
		<set_anchor3 get="inline" set="null" line="405"><f a="anchor3">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_anchor3>
		<get_anchor3 get="inline" set="null" line="401"><f a=""><c path="nape.geom.Vec2"/></f></get_anchor3>
		<anchor3 public="1" get="accessor" set="accessor">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* Anchor point on third Body.
     * <br/><br/>
     * This anchor point is defined in the local coordinate system of body3.]]></haxe_doc>
		</anchor3>
		<set_anchor2 get="inline" set="null" line="380"><f a="anchor2">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_anchor2>
		<get_anchor2 get="inline" set="null" line="376"><f a=""><c path="nape.geom.Vec2"/></f></get_anchor2>
		<anchor2 public="1" get="accessor" set="accessor">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* Anchor point on second Body.
     * <br/><br/>
     * This anchor point is defined in the local coordinate system of body2.]]></haxe_doc>
		</anchor2>
		<set_anchor1 get="inline" set="null" line="355"><f a="anchor1">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_anchor1>
		<get_anchor1 get="inline" set="null" line="351"><f a=""><c path="nape.geom.Vec2"/></f></get_anchor1>
		<anchor1 public="1" get="accessor" set="accessor">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* Anchor point on first Body.
     * <br/><br/>
     * This anchor point is defined in the local coordinate system of body1.]]></haxe_doc>
		</anchor1>
		<set_body4 get="inline" set="null" line="317"><f a="body4">
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
</f></set_body4>
		<get_body4 get="inline" set="null" line="314"><f a=""><t path="Null"><c path="nape.phys.Body"/></t></f></get_body4>
		<body4 public="1" get="accessor" set="accessor">
			<t path="Null"><c path="nape.phys.Body"/></t>
			<haxe_doc><![CDATA[* Fourth Body in constraint.
     * <br/><br/>
     * This value may be null, but trying to simulate the constraint whilst
     * this body is null will result in an error.]]></haxe_doc>
		</body4>
		<set_body3 get="inline" set="null" line="279"><f a="body3">
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
</f></set_body3>
		<get_body3 get="inline" set="null" line="276"><f a=""><t path="Null"><c path="nape.phys.Body"/></t></f></get_body3>
		<body3 public="1" get="accessor" set="accessor">
			<t path="Null"><c path="nape.phys.Body"/></t>
			<haxe_doc><![CDATA[* Third Body in constraint.
     * <br/><br/>
     * This value may be null, but trying to simulate the constraint whilst
     * this body is null will result in an error.]]></haxe_doc>
		</body3>
		<set_body2 get="inline" set="null" line="241"><f a="body2">
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
</f></set_body2>
		<get_body2 get="inline" set="null" line="238"><f a=""><t path="Null"><c path="nape.phys.Body"/></t></f></get_body2>
		<body2 public="1" get="accessor" set="accessor">
			<t path="Null"><c path="nape.phys.Body"/></t>
			<haxe_doc><![CDATA[* Second Body in constraint.
     * <br/><br/>
     * This value may be null, but trying to simulate the constraint whilst
     * this body is null will result in an error.]]></haxe_doc>
		</body2>
		<set_body1 get="inline" set="null" line="203"><f a="body1">
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
</f></set_body1>
		<get_body1 get="inline" set="null" line="200"><f a=""><t path="Null"><c path="nape.phys.Body"/></t></f></get_body1>
		<body1 public="1" get="accessor" set="accessor">
			<t path="Null"><c path="nape.phys.Body"/></t>
			<haxe_doc><![CDATA[* First Body in constraint.
     * <br/><br/>
     * This value may be null, but trying to simulate the constraint whilst
     * this body is null will result in an error.]]></haxe_doc>
		</body1>
		<zpp_inner_zn public="1">
			<c path="zpp_nape.constraint.ZPP_PulleyJoint"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner_zn>
		<new public="1" set="method" line="562">
			<f a="body1:body2:body3:body4:anchor1:anchor2:anchor3:anchor4:jointMin:jointMax:?ratio">
				<t path="Null"><c path="nape.phys.Body"/></t>
				<t path="Null"><c path="nape.phys.Body"/></t>
				<t path="Null"><c path="nape.phys.Body"/></t>
				<t path="Null"><c path="nape.phys.Body"/></t>
				<c path="nape.geom.Vec2"/>
				<c path="nape.geom.Vec2"/>
				<c path="nape.geom.Vec2"/>
				<c path="nape.geom.Vec2"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Construct a new PulleyJoint.
     *
     * @param body1 The first body in PulleyJoint.
     * @param body2 The second body in PulleyJoint.
     * @param body3 The third body in PulleyJoint.
     * @param body4 The fourth body in PulleyJoint.
     * @param anchor1 The first local anchor for joint.
     * @param anchor2 The second local anchor for joint.
     * @param anchor3 The third local anchor for joint.
     * @param anchor4 The fourth local anchor for joint.
     * @param jointMin The lower bound for constraint.
     * @param jointMax The upper bound for constraint.
     * @param ratio The ratio for constraint.
     * @return The constructed PulleyJoint.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* PulleyJoint limiting the weighted sum of distances between 2 pairs of 4 local anchor points of Bodies.
 * <br/><br/>
 * The equation for this constraint could be written like:
 * <pre>
 * jointMin <= distance(body2.localPointToWorld(anchor2), body1.localPointToWorld(anchor1))
 *   + ratio * distance(body4.localPointToWorld(anchor4), body3.localPointToWorld(anchor3)) <= jointMax
 * </pre>
 * This joint is not designed to work when either of these pairs achieves a distance of 0, it will still work
 * but may not be entirely ideal.
!1*<br/><br/> * This constraint can be used in a full 4-body set up, or a 3-body set up or a 2-body set up permitting
 * any arrangement as long as body1 != body2 and body3 != body4]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.constraint.UserConstraint" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/constraint/UserConstraint.hx">
		<extends path="nape.constraint.Constraint"/>
		<__registerBody public="1" set="method" line="504">
			<f a="oldBody:newBody">
				<t path="Null"><c path="nape.phys.Body"/></t>
				<t path="Null"><c path="nape.phys.Body"/></t>
				<t path="Null"><c path="nape.phys.Body"/></t>
			</f>
			<haxe_doc><![CDATA[* Internal method to register Body's with constraint.
     * <br/><br/>
     * This method should be hidden in your sub-type, and used to deal with
     * adding/removing objects from the constraint so that a functionally equivalent
     * constraint can be created (Dealing with all necessary side-effects etc).
     * <pre>
     * //Haxe
     * public var body1(default, set_body1):Null&lt;Body&gt;;
     * inline function set_body1(body1:Null&lt;Body&gt;) {
     *     return this.body1 = __registerBody(this.body1, body1);
     * }
     *
     * //AS3
     * private var _body1:Body;
     * public function get body1():Body {
     *     return _body1;
     * }
     * public function set body1(body1:Body):void {
     *     _body1 = __registerBody(_body1, body1);
     * }
     * </pre>
     *
     * @param oldBody The present value of body parameter.
     * @param newBody The new value for body parameter.
     * @return Returns newBody parameter.
     * @throws # If oldBody is not registered with constraint.
     * @throws # If you call this method in the middle of a space step.]]></haxe_doc>
		</__registerBody>
		<__invalidate public="1" set="method" line="469">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Internal method to invalidate constraint on property changes
     * <br/><br/>
     * This method should be hidden in your sub-type, and called by your
     * constraint's API when a property of the constraint has been changed.
     * <br/>
     * This does not need to be called for Vec2 properties created via
     * the bindVec2 method.
     *
     * @throws # If you call this method in the middle of a space step.]]></haxe_doc>
		</__invalidate>
		<visitBodies public="1" set="method" line="437" override="1">
			<f a="lambda">
				<f a="">
					<c path="nape.phys.Body"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>@inheritDoc</haxe_doc>
		</visitBodies>
		<bodyImpulse public="1" set="method" line="411" override="1">
			<f a="body">
				<c path="nape.phys.Body"/>
				<c path="nape.geom.Vec3"/>
			</f>
			<haxe_doc>@inheritDoc</haxe_doc>
		</bodyImpulse>
		<impulse public="1" set="method" line="401" override="1">
			<f a=""><c path="nape.geom.MatMN"/></f>
			<haxe_doc><![CDATA[@inheritDoc
     * <br/><br/>
     * For user-defined constraints, this will be a dimensions * 1 MatMN.]]></haxe_doc>
		</impulse>
		<__impulse public="1" set="method" line="358">
			<f a="imp:body:out">
				<t path="nape.TArray"><x path="Float"/></t>
				<c path="nape.phys.Body"/>
				<c path="nape.geom.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Internal application of impulse to body.
     * <br/><br/>
     * You should hide this method in your sub-type.
     *
     * @param imp The constraint space impulse to be applied to bodies.
     * @param body The body to apply impulse to.
     * @param out The Vec3 to store impulse on body to be applied. This
     *            should be in world space.]]></haxe_doc>
		</__impulse>
		<__clamp public="1" set="method" line="347">
			<f a="jAcc">
				<t path="nape.TArray"><x path="Float"/></t>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Internal, optional clamping of impulse for constraint.
     * <br/><br/>
     * You should hide this method in your sub-type.
     *
     * @param jAcc The constraint space impulse to be clamped.]]></haxe_doc>
		</__clamp>
		<__eff_mass public="1" set="method" line="335">
			<f a="eff">
				<t path="nape.TArray"><x path="Float"/></t>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Internal effective mass matrix function for constraint.
     * <br/><br/>
     * This array will be of size <code>dimension * (dimension - 1)</code> as a
     * compressed, symmetric matrix:
     * <pre>
     * // Assuming dimension of 3 for constraint:
     * [ eff[0] eff[1] eff[2] ]
     * [ eff[1] eff[3] eff[4] ]
     * [ eff[2] eff[4] eff[5] ]
     * </pre>
     * <br/><br/>
     * You should hide this method in your sub-type.
     *
     * @param eff The output array to store constraint space effective mass matrix.
     * @throws # If this method is not overriden.]]></haxe_doc>
		</__eff_mass>
		<__velocity public="1" set="method" line="313">
			<f a="err">
				<t path="nape.TArray"><x path="Float"/></t>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Internal velocity error function for constraint.
     * <br/><br/>
     * You should hide this method in your sub-type.
     *
     * @param err The output array to store constraint space velocity error.
     * @throws # If not overriden by sub-type.]]></haxe_doc>
		</__velocity>
		<__position public="1" set="method" line="300">
			<f a="err">
				<t path="nape.TArray"><x path="Float"/></t>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Internal positional error function for constraint.
     * <br/><br/>
     * You should hide this method in your sub-type.
     *
     * @param err The output array to store constraint space positional error.
     * @throws # If this is not a velocity-only constraint, and is not overriden.]]></haxe_doc>
		</__position>
		<__prepare public="1" set="method" line="291">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Internal position dependant calculations for constraint.
     * <br/><br/>
     * This method may be overriden to define extra computations that will
     * remain constant as long as a Body's position/rotation is not changed.
     * <br/><br/>
     * You should hide this method in your sub-type.]]></haxe_doc>
		</__prepare>
		<__draw public="1" set="method" line="282">
			<f a="debug">
				<c path="nape.util.Debug"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Internal debug drawing of constraint.
     * <br/><br/>
     * This method will be called by Nape debug draws when enabled to
     * draw your constraint. You do not need to override this method.
     * <br/><br/>
     * You should hide this method in your sub-type.
     *
     * @param debug Nape Debug draw to draw constraint to.]]></haxe_doc>
		</__draw>
		<__validate public="1" set="method" line="271">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Internal validation of constraint.
     * <br/><br/>
     * This method may be optionally overriden, and defines extra validation
     * steps to be made in validating your constraint integrity in terms of
     * property values. (Think things like standard nape errors if a body
     * is not in the same space as constraint).
     * <br/><br/>
     * This method will be called in all build types, not just debug and can also
     * be used to pre-compute values that will remain constant over an entire
     * time step and do not depend on the state of the Body's.
     * <br/><br/>
     * You should hide this method in your sub-type.]]></haxe_doc>
		</__validate>
		<__broken public="1" set="method" line="256">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Internal extra steps in breaking constraint
     * <br/><br/>
     * This method may be optionally overriden, and defines extra steps to
     * be taken when your constraint is broken. This will be called before
     * the constraint is removed or made inactive.
     * <br/><br/>
     * You should hide this method in your sub-type.]]></haxe_doc>
		</__broken>
		<__copy public="1" set="method" line="241">
			<f a=""><c path="nape.constraint.UserConstraint"/></f>
			<haxe_doc><![CDATA[* Internal copying of user defined constraint.
     * <br/><br/>
     * This method must be overriden, and defines how your customised constraint
     * is to be copied. Likely by simply calling your constructor with constraint
     * properties as argument.
     * <br/><br/>
     * You should hide this method in your sub-type.
     *
     * @return A copy of your constraint.
     * @throws # If not overriden by sub-type.]]></haxe_doc>
		</__copy>
		<__bindVec2 public="1" set="method" line="223">
			<f a=""><c path="nape.geom.Vec2"/></f>
			<haxe_doc><![CDATA[* Create a Vec2 property for user-constraint.
     * <br/><br/>
     * This method is used in creating a custom constraint, to create a
     * Vec2 property which will be tied to this constraint so that modifications
     * to the Vec2 will have the appropriate side effects on constraint.
     * <pre>
     * //Haxe (Cleanest way without using macros, clearly you must ensure this
     * //      is set at least once, likely in constructor)
     * public var property(default, set_property):Vec2;
     * inline function set_property(property:Vec2) {
     *     if (this.property == null) this.property = __bindVec2();
     *     return this.property.set(property);
     * }
     *
     * //AS3
     * private var _property:Vec2 = __bindVec2();
     * public function get property():Vec2 { return _property; }
     * public function set property(property:Vec2):void {
     *     _property.set(property);
     * }
     * </pre>
     * This bound Vec2 will behave like standard Nape anchor/direction Vec2's.
     * <br/><br/>
     * You should hide this method in your sub-type.]]></haxe_doc>
		</__bindVec2>
		<zpp_inner_zn public="1">
			<c path="zpp_nape.constraint.ZPP_UserConstraint"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner_zn>
		<new public="1" set="method" line="376">
			<f a="dimensions:?velocityOnly">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Base constructor for user constraints.
     * <br/><br/>
     * You should never call this function directly, only though use of
     * super(..) in sub-typed UserConstraint.
     *
     * @param dimensions The number of constraint space dimensions.
     * @param velocityOnly If true, then this constraint will be implemented
     *                     as a velocity-only constraint like the MotorJoint.
     * @throws # If dimensions < 1]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* UserConstraint providing a low-level API for user-defined Constraints.
 * <br/><br/>
 * This API is intended to be powerful enough to model any constraint that
 * Nape can handle, but not so low level as to be completely prohibitive.
 * <br/>
 * For instance, things like soft-constraints are automatically provided
 * by this API.
 * <br/><br/>
 * Working with this API will require mathematical skills. A full manual
 * for this API is provided at: http://deltaluca.me.uk/docnew/exgif/userdef_constraints.pdf
 * <br/><br/>
 * You may also be interested in the nape-symbolic module that is available
 * on github/haxelib/nape downloads. Which provides a run-time compiled DSL
 * using this API to make prototyping (or creating non-performance critical)
 * user-defined constraints simple without the need for great mathematical
 * skills as well as being much quicker to work with.]]></haxe_doc>
	</class>
	<class path="nape.constraint.WeldJoint" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/constraint/WeldJoint.hx">
		<extends path="nape.constraint.Constraint"/>
		<visitBodies public="1" set="method" line="414" override="1">
			<f a="lambda">
				<f a="">
					<c path="nape.phys.Body"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</visitBodies>
		<bodyImpulse public="1" set="method" line="395" override="1">
			<f a="body">
				<c path="nape.phys.Body"/>
				<c path="nape.geom.Vec3"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</bodyImpulse>
		<impulse public="1" set="method" line="385" override="1">
			<f a=""><c path="nape.geom.MatMN"/></f>
			<haxe_doc><![CDATA[* @inheritDoc
     * <br/><br/>
     * For this constraint, the MatMN will be 3x1.]]></haxe_doc>
		</impulse>
		<set_phase get="inline" set="null" line="333"><f a="phase">
	<x path="Float"/>
	<x path="Float"/>
</f></set_phase>
		<get_phase get="inline" set="null" line="330"><f a=""><x path="Float"/></f></get_phase>
		<phase public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* Angular phase of bodies in WeldJoint.
     *
     * @default 0</haxe_doc>
		</phase>
		<set_anchor2 get="inline" set="null" line="309"><f a="anchor2">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_anchor2>
		<get_anchor2 get="inline" set="null" line="305"><f a=""><c path="nape.geom.Vec2"/></f></get_anchor2>
		<anchor2 public="1" get="accessor" set="accessor">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* Anchor point on second Body.
     * <br/><br/>
     * This anchor point is defined in the local coordinate system of body2.]]></haxe_doc>
		</anchor2>
		<set_anchor1 get="inline" set="null" line="284"><f a="anchor1">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_anchor1>
		<get_anchor1 get="inline" set="null" line="280"><f a=""><c path="nape.geom.Vec2"/></f></get_anchor1>
		<anchor1 public="1" get="accessor" set="accessor">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* Anchor point on first Body.
     * <br/><br/>
     * This anchor point is defined in the local coordinate system of body1.]]></haxe_doc>
		</anchor1>
		<set_body2 get="inline" set="null" line="246"><f a="body2">
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
</f></set_body2>
		<get_body2 get="inline" set="null" line="243"><f a=""><t path="Null"><c path="nape.phys.Body"/></t></f></get_body2>
		<body2 public="1" get="accessor" set="accessor">
			<t path="Null"><c path="nape.phys.Body"/></t>
			<haxe_doc><![CDATA[* Second Body in constraint.
     * <br/><br/>
     * This value may be null, but trying to simulate the constraint whilst
     * this body is null will result in an error.]]></haxe_doc>
		</body2>
		<set_body1 get="inline" set="null" line="208"><f a="body1">
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
</f></set_body1>
		<get_body1 get="inline" set="null" line="205"><f a=""><t path="Null"><c path="nape.phys.Body"/></t></f></get_body1>
		<body1 public="1" get="accessor" set="accessor">
			<t path="Null"><c path="nape.phys.Body"/></t>
			<haxe_doc><![CDATA[* First Body in constraint.
     * <br/><br/>
     * This value may be null, but trying to simulate the constraint whilst
     * this body is null will result in an error.]]></haxe_doc>
		</body1>
		<zpp_inner_zn public="1">
			<c path="zpp_nape.constraint.ZPP_WeldJoint"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner_zn>
		<new public="1" set="method" line="360">
			<f a="body1:body2:anchor1:anchor2:?phase">
				<t path="Null"><c path="nape.phys.Body"/></t>
				<t path="Null"><c path="nape.phys.Body"/></t>
				<c path="nape.geom.Vec2"/>
				<c path="nape.geom.Vec2"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Construct a new WeldJoint.
     *
     * @param body1 The first body in WeldJoint.
     * @param body2 The second body in WeldJoint.
     * @param anchor1 The first local anchor for joint.
     * @param anchor2 The second local anchor for joint.
     * @param phase The angular phase of joint. (default 0)
     * @return The constructed WeldJoint.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* WeldJoint constraining two bodies to be exactly locked together.
 * <br/><br/>
 * The equation for this constraint is:
 * <pre>
 * [ body2.localPointToWorld(anchor2) ] = [ body1.localPointToWorld(anchor1) ]
 * [          body2.rotation          ]   [      body1.rotation + phase      ]
 * </pre>
 * This constraint is equivalent to using a PivotJoint and AngleJoint
 * together except that it is solved as a single constraint and thus
 * will be more stable.
 * <br/><br/>
 * This constraint is 3 dimensional.
 * <br/><br/>
 * Although this constraint is very stable, if you chain bodies together
 * using this constraint, you should except to see a small amount of rotation
 * about the anchor points so you should chose them accordingly.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.dynamics.Arbiter" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/dynamics/Arbiter.hx">
		<toString public="1" set="method" line="372">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<totalImpulse public="1" set="method" line="350">
			<f a="?body:?freshOnly">
				<c path="nape.phys.Body"/>
				<x path="Bool"/>
				<c path="nape.geom.Vec3"/>
			</f>
			<haxe_doc><![CDATA[* Evaluate the total impulse this arbiter applied to the given body for
     * the previous space step including angular impulse based on things like
     * contact position, or centre of buoyancy etc.
     * <br/><br/>
     * If body is null, then the constraint space impulse will be returned instead
     *
     * @param body The body to query impulse for. (default null)
     * @param freshOnly If true, then only 'new' contact points will be queried for
     *                  collision type arbiters. This field has no use on fluid type
     *                  arbiters. (default false)
     * @return The total impulse applied to the given body, or the constraint
     *         space impule if the body is null.
     * @throws # If body is non-null, but not related to this Arbiter.]]></haxe_doc>
		</totalImpulse>
		<get_state get="inline" set="null" line="323"><f a=""><c path="nape.callbacks.PreFlag"/></f></get_state>
		<state public="1" get="accessor" set="null">
			<c path="nape.callbacks.PreFlag"/>
			<haxe_doc><![CDATA[* The interaction state of this Arbiter.
     * <br/><br/>
     * This flag will, except for in a PreListener handler, always be either
     * <code>ImmState.ACCEPT</code> or <code>ImmState.IGNORE</code>
     * <br/>
     * During a PreListener handler, you can query this property to see what
     * the current state of the arbiter has been set to, and returning null from
     * the handler will keep the state unchanged.]]></haxe_doc>
		</state>
		<get_body2 get="inline" set="null" line="305"><f a=""><c path="nape.phys.Body"/></f></get_body2>
		<body2 public="1" get="accessor" set="null">
			<c path="nape.phys.Body"/>
			<haxe_doc><![CDATA[* The second body in Arbiter interaction.
     * <br/><br/>
     * It will always be the case that <code>arb.shape2.body == arb.body2</code>]]></haxe_doc>
		</body2>
		<get_body1 get="inline" set="null" line="292"><f a=""><c path="nape.phys.Body"/></f></get_body1>
		<body1 public="1" get="accessor" set="null">
			<c path="nape.phys.Body"/>
			<haxe_doc><![CDATA[* The first body in Arbiter interaction.
     * <br/><br/>
     * It will always be the case that <code>arb.shape1.body == arb.body1</code>]]></haxe_doc>
		</body1>
		<get_shape2 get="inline" set="null" line="279"><f a=""><c path="nape.shape.Shape"/></f></get_shape2>
		<shape2 public="1" get="accessor" set="null">
			<c path="nape.shape.Shape"/>
			<haxe_doc><![CDATA[* The second shape in Arbiter interaction.
     * <br/><br/>
     * It will always be the case that <code>arb.shape1.id < arb.shape2.id</code>]]></haxe_doc>
		</shape2>
		<get_shape1 get="inline" set="null" line="266"><f a=""><c path="nape.shape.Shape"/></f></get_shape1>
		<shape1 public="1" get="accessor" set="null">
			<c path="nape.shape.Shape"/>
			<haxe_doc><![CDATA[* The first shape in Arbiter interaction.
     * <br/><br/>
     * It will always be the case that <code>arb.shape1.id < arb.shape2.id</code>]]></haxe_doc>
		</shape1>
		<get_fluidArbiter get="inline" set="null" line="256"><f a=""><t path="Null"><c path="nape.dynamics.FluidArbiter"/></t></f></get_fluidArbiter>
		<fluidArbiter public="1" get="accessor" set="null">
			<t path="Null"><c path="nape.dynamics.FluidArbiter"/></t>
			<haxe_doc><![CDATA[* Fast equivalent to casting this object to a FluidArbiter.
     * <br/><br/>
     * This value is null when this arbiter is not a fluid type.]]></haxe_doc>
		</fluidArbiter>
		<get_collisionArbiter get="inline" set="null" line="246"><f a=""><t path="Null"><c path="nape.dynamics.CollisionArbiter"/></t></f></get_collisionArbiter>
		<collisionArbiter public="1" get="accessor" set="null">
			<t path="Null"><c path="nape.dynamics.CollisionArbiter"/></t>
			<haxe_doc><![CDATA[* Fast equivalent to casting this object to a CollisionArbiter.
     * <br/><br/>
     * This value is null when this arbiter is not a collision type.]]></haxe_doc>
		</collisionArbiter>
		<isSensorArbiter public="1" get="inline" set="null" line="236">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[* Equivalent to: <code>arb.type == ArbiterType.SENSOR</code>
     * </br><br/>
     *
     * @return True if this Arbiter is a Sensor type arbiter.]]></haxe_doc>
		</isSensorArbiter>
		<isFluidArbiter public="1" get="inline" set="null" line="225">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[* Equivalent to: <code>arb.type == ArbiterType.FLUID</code>
     * </br><br/>
     *
     * @return True if this Arbiter is a Fluid type arbiter.]]></haxe_doc>
		</isFluidArbiter>
		<isCollisionArbiter public="1" get="inline" set="null" line="214">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[* Equivalent to: <code>arb.type == ArbiterType.COLLISION</code>
     * </br><br/>
     *
     * @return True if this Arbiter is a Collision type arbiter.]]></haxe_doc>
		</isCollisionArbiter>
		<get_type get="inline" set="null" line="203"><f a=""><c path="nape.dynamics.ArbiterType"/></f></get_type>
		<type public="1" get="accessor" set="null">
			<c path="nape.dynamics.ArbiterType"/>
			<haxe_doc>* The type of this Arbiter.</haxe_doc>
		</type>
		<get_isSleeping get="inline" set="null" line="192"><f a=""><x path="Bool"/></f></get_isSleeping>
		<isSleeping public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Flag representing arbiter sleep state.
     * <br/><br/>
     * When true, this arbiter is sleeping.]]></haxe_doc>
		</isSleeping>
		<zpp_inner public="1">
			<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="362">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Arbiter representing the state of an interaction between two Bodys.
 * <br/><br/>
 * These objects are automatically reused, and you should not keep your own
 * references to them.]]></haxe_doc>
	</class>
	<class path="nape.dynamics.ArbiterIterator" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/dynamics/ArbiterIterator.hx">
		<zpp_pool public="1" line="194" static="1">
			<c path="nape.dynamics.ArbiterIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_pool>
		<get public="1" set="method" line="217" static="1">
			<f a="list">
				<c path="nape.dynamics.ArbiterList"/>
				<c path="nape.dynamics.ArbiterIterator"/>
			</f>
			<haxe_doc><![CDATA[* Create iterator for Nape list.
     * <br/><br/>
     * There is no specific reason to use this over: <code>list.iterator()</code>
     * especcialy since this requires writing the class name :)
     * (This function is used internally)
     *
     * @param list The Nape list to create iterator for.
     * @return     An iterator over the Nape list.]]></haxe_doc>
		</get>
		<next public="1" get="inline" set="null" line="264">
			<f a=""><c path="nape.dynamics.Arbiter"/></f>
			<haxe_doc>* Return next element in list.
     *
     * @return The next element in iteration.</haxe_doc>
		</next>
		<hasNext public="1" get="inline" set="null" line="240">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Check if there are any elements remaining.
     *
     * @return True if there are more elements to iterator over.</haxe_doc>
		</hasNext>
		<zpp_next public="1">
			<c path="nape.dynamics.ArbiterIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_next>
		<zpp_critical public="1">
			<x path="Bool"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_critical>
		<zpp_i public="1">
			<x path="Int"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_i>
		<zpp_inner public="1">
			<c path="nape.dynamics.ArbiterList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="202">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Haxe Iterator<T> compatible iterator over Nape list.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.dynamics.ArbiterList" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/dynamics/ArbiterList.hx">
		<fromArray public="1" set="method" line="304" static="1">
			<f a="array">
				<c path="Array"><c path="nape.dynamics.Arbiter"/></c>
				<c path="nape.dynamics.ArbiterList"/>
			</f>
			<haxe_doc>* Convert standard Array to Nape list.
     *
     * @param array The array to be converted
     * @return An equivalent Nape list.
     * @throws If array argument is null.
     * @throws If array contains elements of type other than Arbiter</haxe_doc>
		</fromArray>
		<filter public="1" set="method" line="779">
			<f a="lambda">
				<f a="">
					<c path="nape.dynamics.Arbiter"/>
					<x path="Bool"/>
				</f>
				<c path="nape.dynamics.ArbiterList"/>
			</f>
			<haxe_doc><![CDATA[* Iterate over list filtering elements.
     * <br/><br/>
     * The given function will be applied to each element, whenever the
     * function returns false, the element will be removed from the list.
     * <br/><br/>
     * Any exception thrown by the supplied function will be treat as a
     * signal to halt iteration acting as a 'break' statement.
     * <br/><br/>
     * This method is to be greatly preferred for filtering logic as
     * it is otherwise unsafe to modify the list during an iteration.
     * <br/><br/>
     * An example of using this method to clean up a list whilst performing
     * actions on the elements.
     * <pre>
     * list.filter(function (obj) {
     *    // perform clean up with obj
     *    return false; // remove from list.
     * });
     * </pre>
     *
     * @param lambda The function to apply to each argument, deciding if
     *               element should be removed.
     * @return A reference to 'this' list.
     * @throws # If lambda argument is null.]]></haxe_doc>
		</filter>
		<foreach public="1" set="method" line="732">
			<f a="lambda">
				<f a="">
					<c path="nape.dynamics.Arbiter"/>
					<x path="Void"/>
				</f>
				<c path="nape.dynamics.ArbiterList"/>
			</f>
			<haxe_doc><![CDATA[* Iterate over list applying function.
     * <br/><br/>
     * Any exception thrown by the supplied function will be treat as a
     * signal to halt iteration acting as a 'break' statement.
     * <br/><br/>
     * This method should be preferred to using standard haxe iteration
     * as there will be no allocation of an iterator object.
     * <pre>
     * list.foreach(function (obj) {
     *     if (ignore_object(obj)) return; //acts as a 'continue' statement
     *     if (halt_iteration(obj)) throw "": //acts as a 'break' statement
     * });
     * </pre>
     *
     * @param lambda The function to apply to each argument.
     * @return A reference to 'this' list.
     * @throws # If lambda argument is null.]]></haxe_doc>
		</foreach>
		<toString public="1" set="method" line="702">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<merge public="1" set="method" line="684">
			<f a="xs">
				<c path="nape.dynamics.ArbiterList"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Merge given list into this one.
     * <br/><br/>
     * The result is that this list will have all objects from the argument
     * that were not already in the list inserted. You should make no
     * assumption about the order of these insertions.
     *
     * @param xs The list to merge.
     * @throws # If xs argument is null.]]></haxe_doc>
		</merge>
		<copy public="1" set="method" line="662">
			<f a="?deep">
				<x path="Bool"/>
				<c path="nape.dynamics.ArbiterList"/>
			</f>
			<haxe_doc>* Produce a possibly deep copy of list.
     *
     * @param deep If true, then each element will have its own copy
     *             function called instead of simply having its
     *             reference copied over.
     * @return     The copied list.</haxe_doc>
		</copy>
		<iterator public="1" set="method" line="647">
			<f a=""><c path="nape.dynamics.ArbiterIterator"/></f>
			<haxe_doc><![CDATA[* Return Haxe iterator for list.
     * <br/><br/>
     * Use of this iterator, whilst stylistically better in Haxe should not
     * be used, in preference for use of the foreach function which will
     * not require allocation of an iterator object.
     * <br/><br/>
     * Equally in AS3, the foreach method should be the preferred way to iterate.]]></haxe_doc>
		</iterator>
		<empty public="1" set="method" line="631">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Test if list is empty or not.
     *
     * @return True if list is empty.</haxe_doc>
		</empty>
		<clear public="1" set="method" line="614">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clear the list, removing all elements.
     *
     * @throws # If list is iummutable</haxe_doc>
		</clear>
		<remove public="1" set="method" line="576">
			<f a="obj">
				<c path="nape.dynamics.Arbiter"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Remove element from list.
     * <br/><br/>
     * This is a linear time operation.
     *
     * @param obj The object to remove
     * @return True if object was removed from list.
     * @throws # If list is immutable]]></haxe_doc>
		</remove>
		<add public="1" set="method" line="563">
			<f a="obj">
				<c path="nape.dynamics.Arbiter"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Insert element into list in most effecient way.
     * <br/><br/>
     * This method will defer to either the push or unshift function
     * depending on which is most effecient in the context.
     * <br/><br/>
     * If order of elements is not important then you should always use
     * this function to insert elements.
     *
     * @param obj The object to insert.
     * @return True if object was successfuly inserted.
     * @throws # If list is immutable]]></haxe_doc>
		</add>
		<shift public="1" set="method" line="519">
			<f a=""><c path="nape.dynamics.Arbiter"/></f>
			<haxe_doc><![CDATA[* Pop element from front of list.
     * <br/><br/>
     * If you are wanting to clear a list, whilst operating on its elements,
     * consider use of the filter method instead.
     *
     * @returns The element removed from list.
     * @throws # If list is immutable.
     * @throws # If the list is empty.]]></haxe_doc>
		</shift>
		<pop public="1" set="method" line="478">
			<f a=""><c path="nape.dynamics.Arbiter"/></f>
			<haxe_doc><![CDATA[* Pop element from back of list.
     * <br/><br/>
     * If you are wanting to clear a list, whilst operating on its elements,
     * consider use of the filter method instead.
     *
     * @returns The element removed from list.
     * @throws # If list is immutable.
     * @throws # If the list is empty.]]></haxe_doc>
		</pop>
		<unshift public="1" set="method" line="447">
			<f a="obj">
				<c path="nape.dynamics.Arbiter"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Push element to front of list.
     * <br/><br/>
     * When the order of objects is not important, it is best to use the
     * add() method instead.
     *
     * @param obj The object to insert.
     * @returns True if object was successively inserted.
     * @throws # If list is immutable.]]></haxe_doc>
		</unshift>
		<push public="1" set="method" line="416">
			<f a="obj">
				<c path="nape.dynamics.Arbiter"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Push element to back of list.
     * <br/><br/>
     * When the order of objects is not important, it is best to use the
     * add() method instead.
     *
     * @param obj The object to insert.
     * @returns True if object was successively inserted.
     * @throws # If list is immutable.]]></haxe_doc>
		</push>
		<at public="1" set="method" line="363">
			<f a="index">
				<x path="Int"/>
				<c path="nape.dynamics.Arbiter"/>
			</f>
			<haxe_doc><![CDATA[* Random access to elements of list by index.
     * <br/><br/>
     * Under normal circumstances, accessing succesive elements via this
     * method will occur in constant time.
     *
     * @param index The index of the element in list to access.
     * @returns The element at the given index.
     * @throws # If index is out of bounds.]]></haxe_doc>
		</at>
		<has public="1" set="method" line="346">
			<f a="obj">
				<c path="nape.dynamics.Arbiter"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if element is already in the list
     *
     * @param obj The object to test.
     * @return True if object is in the list.</haxe_doc>
		</has>
		<zpp_vm public="1" set="method" line="291">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</zpp_vm>
		<zpp_gl public="1" set="method" line="269">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* @private</haxe_doc>
		</zpp_gl>
		<get_length get="inline" set="null" line="263"><f a=""><x path="Int"/></f></get_length>
		<length public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Length of list.</haxe_doc>
		</length>
		<zpp_inner public="1">
			<c path="zpp_nape.util.ZPP_ArbiterList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="695">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Construct a new list.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Nape list of Arbiter type objects
 * <br/><br/>
 * Internally this list is at present implemented as a linked list with
 * object pooled nodes and iterators with various fast paths made for
 * standard access patterns (For instance accessing successive elements
 * runs in constant time when using random access functions)
 * <br/><br/>
 * Iteration of this list can be done in various ways, but the preferred
 * way on all targets, is through use of the foreach function:
 * <pre>
 * list.foreach(function (obj) {
 * });
 * </pre>
 * This method is inlined so that in haxe no closure will need to be created.
 * <br/><br/>
 * In AS3, a closure would need to be created in general, so for performance
 * reasons you 'may' choose to use iteration as follows:
 * <pre>
 * for (var i:int = 0; i < list.length; i++) {
 *     var obj:Arbiter = list.at(i);
 * }
 * </pre>
 * <br/>
 * NOTE: It is 'not' safe to modify a list whilst iterating over it.
 * If you wish to remove elements during an iteration you should use the
 * filter method, for example:
 * <pre>
 * list.filter(function (obj) {
 *     // operate on object.
 *     // ...
 *     return (false if you want object to be removed);
 * });
 * </pre>
 * <br/><br/>
 * In AS3, if you wish to avoid a closure generation, you can perform such
 * an iteration in a safe manner as follows:
 * <pre>
 * var i:int = 0;
 * while (i < list.length) {
 *     var obj:Arbiter = list.at(i);
 *     // operate on object.
 *     // ...
 *     if (should remove obj) {
 *         list.remove(obj);
 *         continue;
 *     }
 *     else i++;
 * }
 * </pre>
 * Or if you are always clearing the list entirely you could write:
 * <pre>
 * while (!list.empty()) {
 *     var obj:Arbiter = list.pop();
 *     // operate on object.
 *     // ...
 * }
 * </pre>]]></haxe_doc>
	</class>
	<class path="nape.dynamics.ArbiterType" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/dynamics/ArbiterType.hx">
		<COLLISION public="1" get="accessor" set="null" static="1">
			<c path="nape.dynamics.ArbiterType"/>
			<haxe_doc>* Collision type Arbiter.</haxe_doc>
		</COLLISION>
		<get_COLLISION get="inline" set="null" line="202" static="1"><f a=""><c path="nape.dynamics.ArbiterType"/></f></get_COLLISION>
		<SENSOR public="1" get="accessor" set="null" static="1">
			<c path="nape.dynamics.ArbiterType"/>
			<haxe_doc>* Sensor type Arbiter.</haxe_doc>
		</SENSOR>
		<get_SENSOR get="inline" set="null" line="215" static="1"><f a=""><c path="nape.dynamics.ArbiterType"/></f></get_SENSOR>
		<FLUID public="1" get="accessor" set="null" static="1">
			<c path="nape.dynamics.ArbiterType"/>
			<haxe_doc>* Fluid type Arbiter.</haxe_doc>
		</FLUID>
		<get_FLUID get="inline" set="null" line="228" static="1"><f a=""><c path="nape.dynamics.ArbiterType"/></f></get_FLUID>
		<toString public="1" set="method" line="189">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<new public="1" set="method" line="181">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc>* Enumeration of Arbiter types.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.dynamics.CollisionArbiter" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/dynamics/CollisionArbiter.hx">
		<extends path="nape.dynamics.Arbiter"/>
		<set_rollingFriction get="inline" set="null" line="709"><f a="rollingFriction">
	<x path="Float"/>
	<x path="Float"/>
</f></set_rollingFriction>
		<get_rollingFriction get="inline" set="null" line="701"><f a=""><x path="Float"/></f></get_rollingFriction>
		<rollingFriction public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Coeffecient of combined rolling friction for collision interaction.
     * <br/><br/>
     * The value is computed as the square root of the product of the Shape
     * Material's rollingFriction coeffecients.
     * <br/><br/>
     * This value may be modified only during a PreListener, and once modified
     * will no longer be under Nape's control. Values must not be negative.]]></haxe_doc>
		</rollingFriction>
		<set_staticFriction get="inline" set="null" line="674"><f a="staticFriction">
	<x path="Float"/>
	<x path="Float"/>
</f></set_staticFriction>
		<get_staticFriction get="inline" set="null" line="666"><f a=""><x path="Float"/></f></get_staticFriction>
		<staticFriction public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Coeffecient of combined static friction for collision interaction.
     * <br/><br/>
     * The value is computed as the square root of the product of the Shape
     * Material's staticFriction coeffecients.
     * <br/><br/>
     * This value may be modified only during a PreListener, and once modified
     * will no longer be under Nape's control. Values must not be negative.]]></haxe_doc>
		</staticFriction>
		<set_dynamicFriction get="inline" set="null" line="639"><f a="dynamicFriction">
	<x path="Float"/>
	<x path="Float"/>
</f></set_dynamicFriction>
		<get_dynamicFriction get="inline" set="null" line="631"><f a=""><x path="Float"/></f></get_dynamicFriction>
		<dynamicFriction public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Coeffecient of combined dynamic friction for collision interaction.
     * <br/><br/>
     * The value is computed as the square root of the product of the Shape
     * Material's dynamicFriction coeffecients.
     * <br/><br/>
     * This value may be modified only during a PreListener, and once modified
     * will no longer be under Nape's control. Values must not be negative.]]></haxe_doc>
		</dynamicFriction>
		<set_elasticity get="inline" set="null" line="604"><f a="elasticity">
	<x path="Float"/>
	<x path="Float"/>
</f></set_elasticity>
		<get_elasticity get="inline" set="null" line="596"><f a=""><x path="Float"/></f></get_elasticity>
		<elasticity public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Coeffecient of combined elasticity for collision interaction.
     * <br/><br/>
     * The value is computed as the average of the Shape Material's elasticities
     * clamped to be in the range [0,1]
     * <br/><br/>
     * This value may be modified only during a PreListener, and once modified
     * will no longer be under Nape's control. Values must be in the range 0
     * to 1.]]></haxe_doc>
		</elasticity>
		<rollingImpulse public="1" set="method" line="573">
			<f a="?body:?freshOnly">
				<c path="nape.phys.Body"/>
				<x path="Bool"/>
				<x path="Float"/>
			</f>
			<haxe_doc><![CDATA[* Evaluate rolling friction impulses for collision interaction.
     * <br/><br/>
     * If body argument is null, then the sum of the rolling impulses of each contact will be returned
     * instead of the angular impulse applied to the specific body as a result of the rolling impulses.
     *
     * @param body The Body to query rolling impulse for. (default null)
     * @param freshOnly If true, then only 'new' contact points will be considered in computation.
     *                  (default false)
     * @return The angular impulse applied to the given body.
     * @throws # If body is non-null, and unrelated to this Arbiter.]]></haxe_doc>
		</rollingImpulse>
		<totalImpulse public="1" set="method" line="485" override="1">
			<f a="?body:?freshOnly">
				<c path="nape.phys.Body"/>
				<x path="Bool"/>
				<c path="nape.geom.Vec3"/>
			</f>
			<haxe_doc><![CDATA[* Evaluate total contact impulses for collision interaction.
     * <br/><br/>
     * If body argument is null, then this will return the sum of linear contact impulses, and the sum
     * of contact rolling impulses.
     * <br/>
     * When body argument is non-null, this impulse will be the actual change in (mass weighted)
     * velocity that this collision caused to the Body in the previous time step.
     *
     * @param body The Body to query total impulse for. (default null)
     * @param freshOnly If true, then only 'new' contact points will be considered in computation.
     *                  (default false)
     * @return The impulse applied to the given body
     * @throws # If body is non-null, and unrelated to this Arbiter.]]></haxe_doc>
		</totalImpulse>
		<tangentImpulse public="1" set="method" line="394">
			<f a="?body:?freshOnly">
				<c path="nape.phys.Body"/>
				<x path="Bool"/>
				<c path="nape.geom.Vec3"/>
			</f>
			<haxe_doc><![CDATA[* Evaluate tangent impulses for collision interaction.
     * <br/><br/>
     * If body argument is null, then the sum of the contact friction impulses is returned with
     * no angular impulse derivable, the direction of this impulse will be against the relative
     * velocity of the first body against the second.
     * <br/>
     * If the body argument is non-null, then the actual impulse applied to that body due to tangent
     * frictino impulses will be returned, including angular effects due to contact positions and normal.
     * <br/><br/>
     * These tangent impulses correspond to the forces of static and dynamic friction.
     *
     * @param body The Body to query tangent impulse for. (default null)
     * @param freshOnly If true, then only 'new' contact points will be considered in computation.
     *                  (default false)
     * @return The impulse applied to the given body, considering standard frictional forces.
     * @throws # If body is non-null, and unrelated to this Arbiter.]]></haxe_doc>
		</tangentImpulse>
		<normalImpulse public="1" set="method" line="300">
			<f a="?body:?freshOnly">
				<c path="nape.phys.Body"/>
				<x path="Bool"/>
				<c path="nape.geom.Vec3"/>
			</f>
			<haxe_doc><![CDATA[* Evaluate normal reactive impulses for collision interaction for a given body.
     * <br/><br/>
     * If body argument is null, then the sum of the contact normal impulses will be returned instead
     * with no angular impulse derivable, the direction of this impulse will be the direction of the normal.
     * <br/>
     * If body argument is not null, then this will return the actual impulse applied to that specific body
     * rather than simply the sum of contact normal impulses, this will include angular impulses due to
     * positions of contact points and normal.
     *
     * @param body The Body to query normal impulse for. (default null)
     * @param freshOnly If true, then only 'new' contact points will be considered in computation.
     *                  (default false)
     * @return The impulse applied to the given body, considering normal reactive forces.
     * @throws # If body is non-null, and unrelated to this Arbiter.]]></haxe_doc>
		</normalImpulse>
		<secondVertex public="1" set="method" line="276">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[* Check if colliding Circle hit second vertex of reference edge.
     * <br/><br/>
     * In the case that we have a Circle-Polygon collision, then this
     * function will return true, if the circle collided with the second
     * vertex of edge.
     * <br/><br/>
     * If both firstVertex() and secondVertex() are false, it indicates
     * the Circle collided with the edge.
     *
     * @returns True if Circle collided with second reference vertex.]]></haxe_doc>
		</secondVertex>
		<firstVertex public="1" set="method" line="257">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[* In the case that we have a Circle-Polygon collision, then this
     * function will return true, if the circle collided with the first
     * vertex of edge.
     * <br/><br/>
     * If both firstVertex() and secondVertex() are false, it indicates
     * the Circle collided with the edge.
     *
     * @returns True if Circle collided with first reference vertex.]]></haxe_doc>
		</firstVertex>
		<get_referenceEdge2 get="inline" set="null" line="239"><f a=""><t path="Null"><c path="nape.shape.Edge"/></t></f></get_referenceEdge2>
		<referenceEdge2 public="1" get="accessor" set="null">
			<t path="Null"><c path="nape.shape.Edge"/></t>
			<haxe_doc>* The reference edge for the collision on the second Polygon
     * If the second shape in Arbiter is a Circle this value is null.</haxe_doc>
		</referenceEdge2>
		<get_referenceEdge1 get="inline" set="null" line="225"><f a=""><t path="Null"><c path="nape.shape.Edge"/></t></f></get_referenceEdge1>
		<referenceEdge1 public="1" get="accessor" set="null">
			<t path="Null"><c path="nape.shape.Edge"/></t>
			<haxe_doc>* The reference edge for the collision on the first Polygon
     * If the first shape in Arbiter is a Circle this value is null.</haxe_doc>
		</referenceEdge1>
		<get_radius get="inline" set="null" line="213"><f a=""><x path="Float"/></f></get_radius>
		<radius public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* This radius property describes the sum of the circle's radii for the pair of shapes, with
     * a Polygon having 0 radius. This value is used in positional iterations to resolve penetrations
     * between the Shapes.</haxe_doc>
		</radius>
		<get_normal get="inline" set="null" line="199"><f a=""><c path="nape.geom.Vec2"/></f></get_normal>
		<normal public="1" get="accessor" set="null">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* Normal of contact for collision interaction.
     * <br/><br/>
     * This normal will always point from arbiter's shape1, towards shape2 and
     * corresponds to the direction of the normal before positional integration
     * and erorr resolvement took place (Correct at time of pre-listener).]]></haxe_doc>
		</normal>
		<get_contacts get="inline" set="null" line="183"><f a=""><c path="nape.dynamics.ContactList"/></f></get_contacts>
		<contacts public="1" get="accessor" set="null">
			<c path="nape.dynamics.ContactList"/>
			<haxe_doc>* Set of contact points for the related pairs of shapes.</haxe_doc>
		</contacts>
		<new public="1" set="method" line="728">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc>* Arbiter sub type for collision interactions.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.dynamics.Contact" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/dynamics/Contact.hx">
		<toString public="1" set="method" line="403">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<get_friction get="inline" set="null" line="386"><f a=""><x path="Float"/></f></get_friction>
		<friction public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The specific coeffecient of friction for this contact.
     * <br/><br/>
     * This value is equal either to the static or dynamic friction coeffecient of the arbiter
     * based on the relative velocity at contact point.
     * <br/><br/>
     * This value cannot be set, though you may implicitly set it exactly by modifying
     * the arbiter to have the same static and dynamic friction in the PreListener.]]></haxe_doc>
		</friction>
		<totalImpulse public="1" set="method" line="337">
			<f a="?body">
				<c path="nape.phys.Body"/>
				<c path="nape.geom.Vec3"/>
			</f>
			<haxe_doc><![CDATA[* Evaluate total contact impulse for a given body.
     * <br/><br/>
     * If body argument is null, then this will return the sum of normal and tangent contact impulse, and the contact
     * rolling impulse.
     * <br/>
     * When body argument is non-null, this impulse will be the actual change in (mass weighted)
     * velocity that this contact caused to the Body in the previous time step.
     *
     * @param body The Body to query total impulse for. (default null)
     * @return The impulse applied to the given body
     * @throws # If body is non-null, and unrelated to this Contact.]]></haxe_doc>
		</totalImpulse>
		<rollingImpulse public="1" set="method" line="308">
			<f a="?body">
				<c path="nape.phys.Body"/>
				<x path="Float"/>
			</f>
			<haxe_doc><![CDATA[* Evaluate rolling friction impulses for this contact for a given body.
     * <br/><br/>
     * If body argument is null, then the rolling impulse of this contact will be returned
     * instead of the angular impulse applied to the specific body as a result of the rolling impulse.
     *
     * @param body The Body to query rolling impulse for. (default null)
     * @return The angular impulse applied to the given body.
     * @throws # If body is non-null, and unrelated to this Contact.]]></haxe_doc>
		</rollingImpulse>
		<tangentImpulse public="1" set="method" line="281">
			<f a="?body">
				<c path="nape.phys.Body"/>
				<c path="nape.geom.Vec3"/>
			</f>
			<haxe_doc><![CDATA[* Evaluate tangent impulses for this contact for a given body.
     * <br/><br/>
     * If body argument is null, then the contact friction impulses is returned with
     * no angular impulse derivable, the direction of this impulse will be against the relative
     * velocity of the first body against the second.
     * <br/>
     * If the body argument is non-null, then the actual impulse applied to that body due to tangent
     * frictino impulses will be returned, including angular effects due to contact position and normal.
     * <br/><br/>
     * These tangent impulses correspond to the forces of static and dynamic friction for this contact.
     *
     * @param body The Body to query tangent impulse for. (default null)
     * @return The impulse applied to the given body, considering standard frictional forces.
     * @throws # If body is non-null, and unrelated to this Contact.]]></haxe_doc>
		</tangentImpulse>
		<normalImpulse public="1" set="method" line="248">
			<f a="?body">
				<c path="nape.phys.Body"/>
				<c path="nape.geom.Vec3"/>
			</f>
			<haxe_doc><![CDATA[* Evaluate normal reactive impulses for this contact for a given body.
     * <br/><br/>
     * If body argument is null, then the contact normal impulses will be returned instead
     * with no angular impulse derivable, the direction of this impulse will be the direction of the normal.
     * <br/>
     * If body argument is not null, then this will return the actual impulse applied to that specific body
     * for this contact this will include angular impulses due to position of contact point and normal.
     *
     * @param body The Body to query normal impulse for. (default null)
     * @return The impulse applied to the given body, considering normal reactive forces.
     * @throws # If body is non-null, and unrelated to this Contact.]]></haxe_doc>
		</normalImpulse>
		<get_fresh get="inline" set="null" line="228"><f a=""><x path="Bool"/></f></get_fresh>
		<fresh public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>* Whether this contact is newly generated, or persistant from previous step.</haxe_doc>
		</fresh>
		<get_position get="inline" set="null" line="216"><f a=""><c path="nape.geom.Vec2"/></f></get_position>
		<position public="1" get="accessor" set="null">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* The world-space position of contact.
     * <br/><br/>
     * This value corresponds to the position
     * of the contact point before positional integration and error resolvement
     * took place (correct at time of pre-listeners).]]></haxe_doc>
		</position>
		<get_penetration get="inline" set="null" line="201"><f a=""><x path="Float"/></f></get_penetration>
		<penetration public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Penetration of bodies along normal for this contact.
     * <br/><br/>
     * This value may be negative and corresponds to the penetration (if at all)
     * of the contact point before positional integration and error resolvement
     * took place (correct at time of pre-listeners).]]></haxe_doc>
		</penetration>
		<get_arbiter get="inline" set="null" line="189"><f a=""><c path="nape.dynamics.CollisionArbiter"/></f></get_arbiter>
		<arbiter public="1" get="accessor" set="null">
			<c path="nape.dynamics.CollisionArbiter"/>
			<haxe_doc>* Reference to the CollisionArbiter this contact belongs to</haxe_doc>
		</arbiter>
		<zpp_inner public="1">
			<c path="zpp_nape.dynamics.ZPP_Contact"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="395">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Contact point for collision interactions
 * <br/><br/>
 * These objects are automatically reused and you should not keep references to them.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.dynamics.ContactIterator" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/dynamics/ContactIterator.hx">
		<zpp_pool public="1" line="194" static="1">
			<c path="nape.dynamics.ContactIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_pool>
		<get public="1" set="method" line="217" static="1">
			<f a="list">
				<c path="nape.dynamics.ContactList"/>
				<c path="nape.dynamics.ContactIterator"/>
			</f>
			<haxe_doc><![CDATA[* Create iterator for Nape list.
     * <br/><br/>
     * There is no specific reason to use this over: <code>list.iterator()</code>
     * especcialy since this requires writing the class name :)
     * (This function is used internally)
     *
     * @param list The Nape list to create iterator for.
     * @return     An iterator over the Nape list.]]></haxe_doc>
		</get>
		<next public="1" get="inline" set="null" line="264">
			<f a=""><c path="nape.dynamics.Contact"/></f>
			<haxe_doc>* Return next element in list.
     *
     * @return The next element in iteration.</haxe_doc>
		</next>
		<hasNext public="1" get="inline" set="null" line="240">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Check if there are any elements remaining.
     *
     * @return True if there are more elements to iterator over.</haxe_doc>
		</hasNext>
		<zpp_next public="1">
			<c path="nape.dynamics.ContactIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_next>
		<zpp_critical public="1">
			<x path="Bool"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_critical>
		<zpp_i public="1">
			<x path="Int"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_i>
		<zpp_inner public="1">
			<c path="nape.dynamics.ContactList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="202">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Haxe Iterator<T> compatible iterator over Nape list.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.dynamics.ContactList" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/dynamics/ContactList.hx">
		<fromArray public="1" set="method" line="304" static="1">
			<f a="array">
				<c path="Array"><c path="nape.dynamics.Contact"/></c>
				<c path="nape.dynamics.ContactList"/>
			</f>
			<haxe_doc>* Convert standard Array to Nape list.
     *
     * @param array The array to be converted
     * @return An equivalent Nape list.
     * @throws If array argument is null.
     * @throws If array contains elements of type other than Contact</haxe_doc>
		</fromArray>
		<filter public="1" set="method" line="779">
			<f a="lambda">
				<f a="">
					<c path="nape.dynamics.Contact"/>
					<x path="Bool"/>
				</f>
				<c path="nape.dynamics.ContactList"/>
			</f>
			<haxe_doc><![CDATA[* Iterate over list filtering elements.
     * <br/><br/>
     * The given function will be applied to each element, whenever the
     * function returns false, the element will be removed from the list.
     * <br/><br/>
     * Any exception thrown by the supplied function will be treat as a
     * signal to halt iteration acting as a 'break' statement.
     * <br/><br/>
     * This method is to be greatly preferred for filtering logic as
     * it is otherwise unsafe to modify the list during an iteration.
     * <br/><br/>
     * An example of using this method to clean up a list whilst performing
     * actions on the elements.
     * <pre>
     * list.filter(function (obj) {
     *    // perform clean up with obj
     *    return false; // remove from list.
     * });
     * </pre>
     *
     * @param lambda The function to apply to each argument, deciding if
     *               element should be removed.
     * @return A reference to 'this' list.
     * @throws # If lambda argument is null.]]></haxe_doc>
		</filter>
		<foreach public="1" get="inline" set="null" line="732">
			<f a="lambda">
				<f a="">
					<c path="nape.dynamics.Contact"/>
					<x path="Void"/>
				</f>
				<c path="nape.dynamics.ContactList"/>
			</f>
			<haxe_doc><![CDATA[* Iterate over list applying function.
     * <br/><br/>
     * Any exception thrown by the supplied function will be treat as a
     * signal to halt iteration acting as a 'break' statement.
     * <br/><br/>
     * This method should be preferred to using standard haxe iteration
     * as there will be no allocation of an iterator object.
     * <pre>
     * list.foreach(function (obj) {
     *     if (ignore_object(obj)) return; //acts as a 'continue' statement
     *     if (halt_iteration(obj)) throw "": //acts as a 'break' statement
     * });
     * </pre>
     *
     * @param lambda The function to apply to each argument.
     * @return A reference to 'this' list.
     * @throws # If lambda argument is null.]]></haxe_doc>
		</foreach>
		<toString public="1" set="method" line="702">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<merge public="1" set="method" line="684">
			<f a="xs">
				<c path="nape.dynamics.ContactList"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Merge given list into this one.
     * <br/><br/>
     * The result is that this list will have all objects from the argument
     * that were not already in the list inserted. You should make no
     * assumption about the order of these insertions.
     *
     * @param xs The list to merge.
     * @throws # If xs argument is null.]]></haxe_doc>
		</merge>
		<copy public="1" set="method" line="662">
			<f a="?deep">
				<x path="Bool"/>
				<c path="nape.dynamics.ContactList"/>
			</f>
			<haxe_doc>* Produce a possibly deep copy of list.
     *
     * @param deep If true, then each element will have its own copy
     *             function called instead of simply having its
     *             reference copied over.
     * @return     The copied list.</haxe_doc>
		</copy>
		<iterator public="1" get="inline" set="null" line="647">
			<f a=""><c path="nape.dynamics.ContactIterator"/></f>
			<haxe_doc><![CDATA[* Return Haxe iterator for list.
     * <br/><br/>
     * Use of this iterator, whilst stylistically better in Haxe should not
     * be used, in preference for use of the foreach function which will
     * not require allocation of an iterator object.
     * <br/><br/>
     * Equally in AS3, the foreach method should be the preferred way to iterate.]]></haxe_doc>
		</iterator>
		<empty public="1" get="inline" set="null" line="631">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Test if list is empty or not.
     *
     * @return True if list is empty.</haxe_doc>
		</empty>
		<clear public="1" set="method" line="614">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clear the list, removing all elements.
     *
     * @throws # If list is iummutable</haxe_doc>
		</clear>
		<remove public="1" set="method" line="576">
			<f a="obj">
				<c path="nape.dynamics.Contact"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Remove element from list.
     * <br/><br/>
     * This is a linear time operation.
     *
     * @param obj The object to remove
     * @return True if object was removed from list.
     * @throws # If list is immutable]]></haxe_doc>
		</remove>
		<add public="1" get="inline" set="null" line="563">
			<f a="obj">
				<c path="nape.dynamics.Contact"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Insert element into list in most effecient way.
     * <br/><br/>
     * This method will defer to either the push or unshift function
     * depending on which is most effecient in the context.
     * <br/><br/>
     * If order of elements is not important then you should always use
     * this function to insert elements.
     *
     * @param obj The object to insert.
     * @return True if object was successfuly inserted.
     * @throws # If list is immutable]]></haxe_doc>
		</add>
		<shift public="1" set="method" line="519">
			<f a=""><c path="nape.dynamics.Contact"/></f>
			<haxe_doc><![CDATA[* Pop element from front of list.
     * <br/><br/>
     * If you are wanting to clear a list, whilst operating on its elements,
     * consider use of the filter method instead.
     *
     * @returns The element removed from list.
     * @throws # If list is immutable.
     * @throws # If the list is empty.]]></haxe_doc>
		</shift>
		<pop public="1" set="method" line="478">
			<f a=""><c path="nape.dynamics.Contact"/></f>
			<haxe_doc><![CDATA[* Pop element from back of list.
     * <br/><br/>
     * If you are wanting to clear a list, whilst operating on its elements,
     * consider use of the filter method instead.
     *
     * @returns The element removed from list.
     * @throws # If list is immutable.
     * @throws # If the list is empty.]]></haxe_doc>
		</pop>
		<unshift public="1" set="method" line="447">
			<f a="obj">
				<c path="nape.dynamics.Contact"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Push element to front of list.
     * <br/><br/>
     * When the order of objects is not important, it is best to use the
     * add() method instead.
     *
     * @param obj The object to insert.
     * @returns True if object was successively inserted.
     * @throws # If list is immutable.]]></haxe_doc>
		</unshift>
		<push public="1" set="method" line="416">
			<f a="obj">
				<c path="nape.dynamics.Contact"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Push element to back of list.
     * <br/><br/>
     * When the order of objects is not important, it is best to use the
     * add() method instead.
     *
     * @param obj The object to insert.
     * @returns True if object was successively inserted.
     * @throws # If list is immutable.]]></haxe_doc>
		</push>
		<at public="1" set="method" line="363">
			<f a="index">
				<x path="Int"/>
				<c path="nape.dynamics.Contact"/>
			</f>
			<haxe_doc><![CDATA[* Random access to elements of list by index.
     * <br/><br/>
     * Under normal circumstances, accessing succesive elements via this
     * method will occur in constant time.
     *
     * @param index The index of the element in list to access.
     * @returns The element at the given index.
     * @throws # If index is out of bounds.]]></haxe_doc>
		</at>
		<has public="1" set="method" line="346">
			<f a="obj">
				<c path="nape.dynamics.Contact"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if element is already in the list
     *
     * @param obj The object to test.
     * @return True if object is in the list.</haxe_doc>
		</has>
		<get_length get="inline" set="null" line="244"><f a=""><x path="Int"/></f></get_length>
		<length public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Length of list.</haxe_doc>
		</length>
		<zpp_inner public="1">
			<c path="zpp_nape.util.ZPP_ContactList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="695">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Construct a new list.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Nape list of Contact type objects
 * <br/><br/>
 * Internally this list is at present implemented as a linked list with
 * object pooled nodes and iterators with various fast paths made for
 * standard access patterns (For instance accessing successive elements
 * runs in constant time when using random access functions)
 * <br/><br/>
 * Iteration of this list can be done in various ways, but the preferred
 * way on all targets, is through use of the foreach function:
 * <pre>
 * list.foreach(function (obj) {
 * });
 * </pre>
 * This method is inlined so that in haxe no closure will need to be created.
 * <br/><br/>
 * In AS3, a closure would need to be created in general, so for performance
 * reasons you 'may' choose to use iteration as follows:
 * <pre>
 * for (var i:int = 0; i < list.length; i++) {
 *     var obj:Contact = list.at(i);
 * }
 * </pre>
 * <br/>
 * NOTE: It is 'not' safe to modify a list whilst iterating over it.
 * If you wish to remove elements during an iteration you should use the
 * filter method, for example:
 * <pre>
 * list.filter(function (obj) {
 *     // operate on object.
 *     // ...
 *     return (false if you want object to be removed);
 * });
 * </pre>
 * <br/><br/>
 * In AS3, if you wish to avoid a closure generation, you can perform such
 * an iteration in a safe manner as follows:
 * <pre>
 * var i:int = 0;
 * while (i < list.length) {
 *     var obj:Contact = list.at(i);
 *     // operate on object.
 *     // ...
 *     if (should remove obj) {
 *         list.remove(obj);
 *         continue;
 *     }
 *     else i++;
 * }
 * </pre>
 * Or if you are always clearing the list entirely you could write:
 * <pre>
 * while (!list.empty()) {
 *     var obj:Contact = list.pop();
 *     // operate on object.
 *     // ...
 * }
 * </pre>]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.dynamics.FluidArbiter" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/dynamics/FluidArbiter.hx">
		<extends path="nape.dynamics.Arbiter"/>
		<totalImpulse public="1" set="method" line="298" override="1">
			<f a="?body:?freshOnly">
				<c path="nape.phys.Body"/>
				<x path="Bool"/>
				<c path="nape.geom.Vec3"/>
			</f>
			<haxe_doc><![CDATA[* Determine total impulse on a given body due to fluid interaction.
     * <br/><br/>
     * If the body is null, then the total impulse will be computed without consideration to any specific
     * body involved, and no angular impulses can be derived for the linear portion of the impulses.
     *
     * @param body The body to query impulse for. (default null)
     * @param freshOnly This parameter is unused for FluidArbiters. (default false)
     * @return The total impulse for given body.
     * @throws # If body is non-null, and unrelated to this Arbiter.]]></haxe_doc>
		</totalImpulse>
		<dragImpulse public="1" set="method" line="275">
			<f a="?body">
				<c path="nape.phys.Body"/>
				<c path="nape.geom.Vec3"/>
			</f>
			<haxe_doc><![CDATA[* Determine impulse on a given body due to fluid drag.
     * <br/><br/>
     * If the body is null, then the drag impulse will be returned without consideration to any specific
     * body involved.
     *
     * @param body The body to query impulse for. (default null)
     * @return The drag impulse for given body.
     * @throws # If body is non-null, and unrelated to this Arbiter.]]></haxe_doc>
		</dragImpulse>
		<buoyancyImpulse public="1" set="method" line="246">
			<f a="?body">
				<c path="nape.phys.Body"/>
				<c path="nape.geom.Vec3"/>
			</f>
			<haxe_doc><![CDATA[* Determine impulse on a given body due to buoyancy.
     * <br/><br/>
     * If the body is null, then the buoyancy impulse will be returned without consideration to any specific
     * body involved, and no angular impulses can be derived.
     *
     * @param body The body to query impulse for. (default null)
     * @return The buoyancy impulse for given body.
     * @throws # If body is non-null, and unrelated to this Arbiter.]]></haxe_doc>
		</buoyancyImpulse>
		<set_overlap get="inline" set="null" line="220"><f a="overlap">
	<x path="Float"/>
	<x path="Float"/>
</f></set_overlap>
		<get_overlap get="inline" set="null" line="214"><f a=""><x path="Float"/></f></get_overlap>
		<overlap public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Overlap area of Shapes in fluid interaction.
     * <br/><br/>
     * This value is strictly positive, and represents the amount of overlap between the Shapes
     * used in buoyancy computations.
     * <br/><br/>
     * This value can be modified during a related PreListener handler.]]></haxe_doc>
		</overlap>
		<set_position get="inline" set="null" line="192"><f a="position">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_position>
		<get_position get="inline" set="null" line="185"><f a=""><c path="nape.geom.Vec2"/></f></get_position>
		<position public="1" get="accessor" set="accessor">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* Centre of buoyancy for fluid interaction.
     * <br/><br/>
     * This value can be modified during a related PreListener handler.]]></haxe_doc>
		</position>
		<new public="1" set="method" line="316">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc>* Fluid interaction subtype for Arbiter.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.dynamics.InteractionFilter" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/dynamics/InteractionFilter.hx">
		<toString public="1" set="method" line="451">
			<f a=""><c path="String"/></f>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<copy public="1" set="method" line="444">
			<f a=""><c path="nape.dynamics.InteractionFilter"/></f>
			<haxe_doc>* Produce a copy of this InteractionFilter
     *
     * @return The copy of this filter.</haxe_doc>
		</copy>
		<shouldFlow public="1" set="method" line="432">
			<f a="filter">
				<c path="nape.dynamics.InteractionFilter"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Determine if objects are permitted to interact as fluids based on InteractionFilters
     * <br/><br/>
     * A fluid type interaction can occur only if this returns True.
     *
     * @param filter The filter to evaluate possibility of fluid with.
     * @return True, if based on interaction filters only the two objects would be able to interact as fluids.
     * @throws # If filter is null.]]></haxe_doc>
		</shouldFlow>
		<shouldSense public="1" set="method" line="416">
			<f a="filter">
				<c path="nape.dynamics.InteractionFilter"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Determine if objects are permitted to sense based on InteractionFilters
     * <br/><br/>
     * A sensor type interaction can occur only if this returns True.
     *
     * @param filter The filter to evaluate possibility of sensor with.
     * @return True, if based on interaction filters only the two objects would be able to sense.
     * @throws # If filter is null.]]></haxe_doc>
		</shouldSense>
		<shouldCollide public="1" set="method" line="400">
			<f a="filter">
				<c path="nape.dynamics.InteractionFilter"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Determine if objects are permitted to collide based on InteractionFilters
     * <br/><br/>
     * A collision type interaction can occur only if this returns True.
     *
     * @param filter The filter to evaluate possibility of collision with.
     * @return True, if based on interaction filters only the two objects would be able to collide.
     * @throws # If filter is null.]]></haxe_doc>
		</shouldCollide>
		<set_fluidMask get="inline" set="null" line="342"><f a="fluidMask">
	<x path="Int"/>
	<x path="Int"/>
</f></set_fluidMask>
		<get_fluidMask get="inline" set="null" line="339"><f a=""><x path="Int"/></f></get_fluidMask>
		<fluidMask public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc>* Mask bitfield for Fluid type interactions.
     * @default -1 (all bits set)</haxe_doc>
		</fluidMask>
		<set_fluidGroup get="inline" set="null" line="324"><f a="fluidGroup">
	<x path="Int"/>
	<x path="Int"/>
</f></set_fluidGroup>
		<get_fluidGroup get="inline" set="null" line="321"><f a=""><x path="Int"/></f></get_fluidGroup>
		<fluidGroup public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc>* Group bitfield for Fluid type interactions.
     * @default 1</haxe_doc>
		</fluidGroup>
		<set_sensorMask get="inline" set="null" line="306"><f a="sensorMask">
	<x path="Int"/>
	<x path="Int"/>
</f></set_sensorMask>
		<get_sensorMask get="inline" set="null" line="303"><f a=""><x path="Int"/></f></get_sensorMask>
		<sensorMask public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc>* Mask bitfield for Sensor type interactions.
     * @default -1 (all bits set)</haxe_doc>
		</sensorMask>
		<set_sensorGroup get="inline" set="null" line="288"><f a="sensorGroup">
	<x path="Int"/>
	<x path="Int"/>
</f></set_sensorGroup>
		<get_sensorGroup get="inline" set="null" line="285"><f a=""><x path="Int"/></f></get_sensorGroup>
		<sensorGroup public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc>* Group bitfield for Sensor type interactions.
     * @default 1</haxe_doc>
		</sensorGroup>
		<set_collisionMask get="inline" set="null" line="270"><f a="collisionMask">
	<x path="Int"/>
	<x path="Int"/>
</f></set_collisionMask>
		<get_collisionMask get="inline" set="null" line="267"><f a=""><x path="Int"/></f></get_collisionMask>
		<collisionMask public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc>* Mask bitfield for Collision type interactions.
     * @default -1 (all bits set)</haxe_doc>
		</collisionMask>
		<set_collisionGroup get="inline" set="null" line="252"><f a="collisionGroup">
	<x path="Int"/>
	<x path="Int"/>
</f></set_collisionGroup>
		<get_collisionGroup get="inline" set="null" line="249"><f a=""><x path="Int"/></f></get_collisionGroup>
		<collisionGroup public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc>* Group bitfield for Collision type interactions.
     * @default 1</haxe_doc>
		</collisionGroup>
		<get_shapes get="inline" set="null" line="239"><f a=""><c path="nape.shape.ShapeList"/></f></get_shapes>
		<shapes public="1" get="accessor" set="null">
			<c path="nape.shape.ShapeList"/>
			<haxe_doc><![CDATA[* Set of all active shapes using this object.
     * <br/><br/>
     * Activeness of a shape in the sense that the Shape's Body is inside of a Space.
     * <br/><br/>
     * This list is immutable.]]></haxe_doc>
		</shapes>
		<get_userData get="inline" set="null" line="224"><f a=""><d><d/></d></f></get_userData>
		<userData public="1" get="accessor" set="null">
			<d><d/></d>
			<haxe_doc><![CDATA[* Dynamic object for user to store additional data.
     * <br/><br/>
     * This object cannot be set, only its dynamically created
     * properties may be set. In AS3 the type of this property is &#42
     * <br/><br/>
     * This object will be lazily constructed so that until accessed
     * for the first time, will be null internally.
     *
     * @default {}]]></haxe_doc>
		</userData>
		<zpp_inner public="1">
			<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="364">
			<f a="?collisionGroup:?collisionMask:?sensorGroup:?sensorMask:?fluidGroup:?fluidMask">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Construct a new InteractionFilter.
     *
     * @param collisionGroup The Group bitfield for Collision interactions. (default 1)
     * @param collisionMask  The Mask bitfield for Collision interactions. (default -1)
     * @param sensorGroup    The Group bitfield for Sensor interactions. (default 1)
     * @param sensorMask     The Mask bitfield for Sensor interactions. (default -1)
     * @param fluidGroup     The Group bitfield for Fluid interactions. (default 1)
     * @param fluidMask      The Mask bitfield for Fluid interactions. (default -1)
     * @return The newly constructed InteractionFilter.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* InteractionFilter provides bit flags for low-level filtering of interactions.
 * <br/><br/>
 * For a given interaction type, two Shapes will be permitted to interact only if
 * <code>(shape1.group & shape2.mask) != 0 && (shape2.group & shape1.mask) != 0</code>
 * <br/><br/>
 * There are 32 real groups corresponding to a set bit in the group/mask fields. For instance
 * a group value of 0x120 corresponds to the 'real' groups 5 and 8 as <code>0x120 = (1<<5) | (1<<8)</code>
 * <br/><br/>
 * Nape provides group/mask for each interaction type. The actual precedence of interactions
 * is further defined simply as: Sensor > Fluid > Collision.
 * <br/>
 * Two static bodies can never interact, and with the exception of sensor interaction, at least one
 * of the two bodies must be dynamic.
 * <br/>
 * Sensor interactions have the highest precedence, followed by fluid and then collisions.
 * Sensor interaction is permitted only if one of the shapes is sensorEnabled, whilst fluid
 * is permitted only if one of the shapes is fluidEnabled.
 * <pre>
 * if ((shapeA.sensorEnabled || shapeB.sensorEnabled) && shapeA.filter.shouldSense(shapeB.filter)) {
 *     SENSOR INTERACTION!!
 * }
 * else if (bodyA.isDynamic() || bodyB.isDynamic()) {
 *     if ((shapeA.fluidEnabled || shapeB.fluidEnabled) && shapeA.filter.shouldFlow(shapeB.filter)) {
 *         FLUID INTERACTION!!
 *     }
 *     else if (shapeA.filter.shouldCollide(shapeB.filter)) {
 *         COLLISION INTERACTION!!
 *     }
 * }
 * </pre>]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.dynamics.InteractionGroup" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/dynamics/InteractionGroup.hx">
		<toString public="1" set="method" line="299">
			<f a=""><c path="String"/></f>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<get_groups get="inline" set="null" line="282"><f a=""><c path="nape.dynamics.InteractionGroupList"/></f></get_groups>
		<groups public="1" get="accessor" set="null">
			<c path="nape.dynamics.InteractionGroupList"/>
			<haxe_doc><![CDATA[* Immutable set of children of Interaction groups.
     * <br/><br/>
     * You cannot assign or remove children in this manner, you must do it via setting
     * the childs parent group to this/null.
     * <br/><br/>
     * This list is immutable.]]></haxe_doc>
		</groups>
		<get_interactors get="inline" set="null" line="268"><f a=""><c path="nape.phys.InteractorList"/></f></get_interactors>
		<interactors public="1" get="accessor" set="null">
			<c path="nape.phys.InteractorList"/>
			<haxe_doc><![CDATA[* Set of active interactors using this group.
     * <br/><br/>
     * Active interactors meaning those that are part of a Space.
     * <br/><br/>
     * This list is immutable.]]></haxe_doc>
		</interactors>
		<set_ignore get="inline" set="null" line="250"><f a="ignore">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_ignore>
		<get_ignore get="inline" set="null" line="247"><f a=""><x path="Bool"/></f></get_ignore>
		<ignore public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Ignore property, set to true so that objects will not interact.
     * @default false</haxe_doc>
		</ignore>
		<set_group get="inline" set="null" line="232"><f a="group">
	<t path="Null"><c path="nape.dynamics.InteractionGroup"/></t>
	<t path="Null"><c path="nape.dynamics.InteractionGroup"/></t>
</f></set_group>
		<get_group get="inline" set="null" line="229"><f a=""><t path="Null"><c path="nape.dynamics.InteractionGroup"/></t></f></get_group>
		<group public="1" get="accessor" set="accessor">
			<t path="Null"><c path="nape.dynamics.InteractionGroup"/></t>
			<haxe_doc>* Parent group in InteractionGroup tree.
     * @default null</haxe_doc>
		</group>
		<zpp_inner public="1">
			<c path="zpp_nape.dynamics.ZPP_InteractionGroup"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="291">
			<f a="?ignore">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Construct a new InteractionGroup.
     *
     * @param ignore Whether interactors should be ignored. (default false)</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* InteractionGroups are another way of filtering interactions.
 * <br/><br/>
 * InteractionGroups form tree structures which are checked along side InteractionFilters
 * when deciding if two Shapes should interact.
 * <br/><br/>
 * InteractionGroups are assigned to any Interactor (not just Shapes), and two Shapes will
 * interact only if the most recent common ancestor in the InteractionGroup tree permits it.
 * <br/><br/>
 * For the purposes of the search, if any Interactor has no InteractionGroup assigned, we
 * search up the Compound tree first.
 * <pre>
 *            _Group1
 *           /   |
 *          /  Group2      Group3
 *         /    |    \       |                 Group1
 *     Body1   /      Cmp1   |                 /   \           Group3
 *    /    \  /      /    \  |      ==>    Shp1    Group2        |
 * Shp1   Shp2   Body2     Cmp2                    /    \      Shp4
 *                 |         |                  Shp2    Shp3
 *                Shp3     Body3
 *                           |
 *                         Shp4
 * </pre>
 * If we look at which InteractionGroup is used for which Shape following this rule, then
 * the left graph can be transformed into an InteractionGroup tree on the right and we get
 * that the MRCA (Most recent common ancestors) are such that:
 * <pre>
 * MRCA(Shp1, Shp3) == Group1;
 * MRCA(Shp2, Shp3) == Group2;
 * MRCA(Shp4,   # ) == null;
 * </pre>
 * If we were to set up the groups such that <code>Group1.ignore = false</code> and
 * <code>Group2.ignore = true</code>; then shapes 1 and 3 would not be permitted to
 * interact, whilst shapes 2 and 3 would be permitted.
 * <br/>
 * As the MRCA for shape 4 with any other is null, then the value of Group3's ignore field
 * is irrelevant, but the existance of Group3 is not as it serves to otherwise prevent Shape 4
 * from being permitted to interact with shapes 2 and 3.
 * <br/><br/>
 * InteractionGroup's can be fairly expressive, but they are strictly less powerful than
 * InteractionFilters. InteractionGroup's have their place however as there is no limit
 * to the number of Groups you can use.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.dynamics.InteractionGroupIterator" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/dynamics/InteractionGroupIterator.hx">
		<zpp_pool public="1" line="194" static="1">
			<c path="nape.dynamics.InteractionGroupIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_pool>
		<get public="1" set="method" line="217" static="1">
			<f a="list">
				<c path="nape.dynamics.InteractionGroupList"/>
				<c path="nape.dynamics.InteractionGroupIterator"/>
			</f>
			<haxe_doc><![CDATA[* Create iterator for Nape list.
     * <br/><br/>
     * There is no specific reason to use this over: <code>list.iterator()</code>
     * especcialy since this requires writing the class name :)
     * (This function is used internally)
     *
     * @param list The Nape list to create iterator for.
     * @return     An iterator over the Nape list.]]></haxe_doc>
		</get>
		<next public="1" get="inline" set="null" line="264">
			<f a=""><c path="nape.dynamics.InteractionGroup"/></f>
			<haxe_doc>* Return next element in list.
     *
     * @return The next element in iteration.</haxe_doc>
		</next>
		<hasNext public="1" get="inline" set="null" line="240">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Check if there are any elements remaining.
     *
     * @return True if there are more elements to iterator over.</haxe_doc>
		</hasNext>
		<zpp_next public="1">
			<c path="nape.dynamics.InteractionGroupIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_next>
		<zpp_critical public="1">
			<x path="Bool"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_critical>
		<zpp_i public="1">
			<x path="Int"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_i>
		<zpp_inner public="1">
			<c path="nape.dynamics.InteractionGroupList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="202">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Haxe Iterator<T> compatible iterator over Nape list.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.dynamics.InteractionGroupList" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/dynamics/InteractionGroupList.hx">
		<fromArray public="1" set="method" line="304" static="1">
			<f a="array">
				<c path="Array"><c path="nape.dynamics.InteractionGroup"/></c>
				<c path="nape.dynamics.InteractionGroupList"/>
			</f>
			<haxe_doc>* Convert standard Array to Nape list.
     *
     * @param array The array to be converted
     * @return An equivalent Nape list.
     * @throws If array argument is null.
     * @throws If array contains elements of type other than InteractionGroup</haxe_doc>
		</fromArray>
		<filter public="1" set="method" line="779">
			<f a="lambda">
				<f a="">
					<c path="nape.dynamics.InteractionGroup"/>
					<x path="Bool"/>
				</f>
				<c path="nape.dynamics.InteractionGroupList"/>
			</f>
			<haxe_doc><![CDATA[* Iterate over list filtering elements.
     * <br/><br/>
     * The given function will be applied to each element, whenever the
     * function returns false, the element will be removed from the list.
     * <br/><br/>
     * Any exception thrown by the supplied function will be treat as a
     * signal to halt iteration acting as a 'break' statement.
     * <br/><br/>
     * This method is to be greatly preferred for filtering logic as
     * it is otherwise unsafe to modify the list during an iteration.
     * <br/><br/>
     * An example of using this method to clean up a list whilst performing
     * actions on the elements.
     * <pre>
     * list.filter(function (obj) {
     *    // perform clean up with obj
     *    return false; // remove from list.
     * });
     * </pre>
     *
     * @param lambda The function to apply to each argument, deciding if
     *               element should be removed.
     * @return A reference to 'this' list.
     * @throws # If lambda argument is null.]]></haxe_doc>
		</filter>
		<foreach public="1" get="inline" set="null" line="732">
			<f a="lambda">
				<f a="">
					<c path="nape.dynamics.InteractionGroup"/>
					<x path="Void"/>
				</f>
				<c path="nape.dynamics.InteractionGroupList"/>
			</f>
			<haxe_doc><![CDATA[* Iterate over list applying function.
     * <br/><br/>
     * Any exception thrown by the supplied function will be treat as a
     * signal to halt iteration acting as a 'break' statement.
     * <br/><br/>
     * This method should be preferred to using standard haxe iteration
     * as there will be no allocation of an iterator object.
     * <pre>
     * list.foreach(function (obj) {
     *     if (ignore_object(obj)) return; //acts as a 'continue' statement
     *     if (halt_iteration(obj)) throw "": //acts as a 'break' statement
     * });
     * </pre>
     *
     * @param lambda The function to apply to each argument.
     * @return A reference to 'this' list.
     * @throws # If lambda argument is null.]]></haxe_doc>
		</foreach>
		<toString public="1" set="method" line="702">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<merge public="1" set="method" line="684">
			<f a="xs">
				<c path="nape.dynamics.InteractionGroupList"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Merge given list into this one.
     * <br/><br/>
     * The result is that this list will have all objects from the argument
     * that were not already in the list inserted. You should make no
     * assumption about the order of these insertions.
     *
     * @param xs The list to merge.
     * @throws # If xs argument is null.]]></haxe_doc>
		</merge>
		<copy public="1" set="method" line="662">
			<f a="?deep">
				<x path="Bool"/>
				<c path="nape.dynamics.InteractionGroupList"/>
			</f>
			<haxe_doc>* Produce a possibly deep copy of list.
     *
     * @param deep If true, then each element will have its own copy
     *             function called instead of simply having its
     *             reference copied over.
     * @return     The copied list.</haxe_doc>
		</copy>
		<iterator public="1" get="inline" set="null" line="647">
			<f a=""><c path="nape.dynamics.InteractionGroupIterator"/></f>
			<haxe_doc><![CDATA[* Return Haxe iterator for list.
     * <br/><br/>
     * Use of this iterator, whilst stylistically better in Haxe should not
     * be used, in preference for use of the foreach function which will
     * not require allocation of an iterator object.
     * <br/><br/>
     * Equally in AS3, the foreach method should be the preferred way to iterate.]]></haxe_doc>
		</iterator>
		<empty public="1" get="inline" set="null" line="631">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Test if list is empty or not.
     *
     * @return True if list is empty.</haxe_doc>
		</empty>
		<clear public="1" set="method" line="614">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clear the list, removing all elements.
     *
     * @throws # If list is iummutable</haxe_doc>
		</clear>
		<remove public="1" set="method" line="576">
			<f a="obj">
				<c path="nape.dynamics.InteractionGroup"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Remove element from list.
     * <br/><br/>
     * This is a linear time operation.
     *
     * @param obj The object to remove
     * @return True if object was removed from list.
     * @throws # If list is immutable]]></haxe_doc>
		</remove>
		<add public="1" get="inline" set="null" line="563">
			<f a="obj">
				<c path="nape.dynamics.InteractionGroup"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Insert element into list in most effecient way.
     * <br/><br/>
     * This method will defer to either the push or unshift function
     * depending on which is most effecient in the context.
     * <br/><br/>
     * If order of elements is not important then you should always use
     * this function to insert elements.
     *
     * @param obj The object to insert.
     * @return True if object was successfuly inserted.
     * @throws # If list is immutable]]></haxe_doc>
		</add>
		<shift public="1" set="method" line="519">
			<f a=""><c path="nape.dynamics.InteractionGroup"/></f>
			<haxe_doc><![CDATA[* Pop element from front of list.
     * <br/><br/>
     * If you are wanting to clear a list, whilst operating on its elements,
     * consider use of the filter method instead.
     *
     * @returns The element removed from list.
     * @throws # If list is immutable.
     * @throws # If the list is empty.]]></haxe_doc>
		</shift>
		<pop public="1" set="method" line="478">
			<f a=""><c path="nape.dynamics.InteractionGroup"/></f>
			<haxe_doc><![CDATA[* Pop element from back of list.
     * <br/><br/>
     * If you are wanting to clear a list, whilst operating on its elements,
     * consider use of the filter method instead.
     *
     * @returns The element removed from list.
     * @throws # If list is immutable.
     * @throws # If the list is empty.]]></haxe_doc>
		</pop>
		<unshift public="1" set="method" line="447">
			<f a="obj">
				<c path="nape.dynamics.InteractionGroup"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Push element to front of list.
     * <br/><br/>
     * When the order of objects is not important, it is best to use the
     * add() method instead.
     *
     * @param obj The object to insert.
     * @returns True if object was successively inserted.
     * @throws # If list is immutable.]]></haxe_doc>
		</unshift>
		<push public="1" set="method" line="416">
			<f a="obj">
				<c path="nape.dynamics.InteractionGroup"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Push element to back of list.
     * <br/><br/>
     * When the order of objects is not important, it is best to use the
     * add() method instead.
     *
     * @param obj The object to insert.
     * @returns True if object was successively inserted.
     * @throws # If list is immutable.]]></haxe_doc>
		</push>
		<at public="1" set="method" line="363">
			<f a="index">
				<x path="Int"/>
				<c path="nape.dynamics.InteractionGroup"/>
			</f>
			<haxe_doc><![CDATA[* Random access to elements of list by index.
     * <br/><br/>
     * Under normal circumstances, accessing succesive elements via this
     * method will occur in constant time.
     *
     * @param index The index of the element in list to access.
     * @returns The element at the given index.
     * @throws # If index is out of bounds.]]></haxe_doc>
		</at>
		<has public="1" set="method" line="346">
			<f a="obj">
				<c path="nape.dynamics.InteractionGroup"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if element is already in the list
     *
     * @param obj The object to test.
     * @return True if object is in the list.</haxe_doc>
		</has>
		<get_length get="inline" set="null" line="244"><f a=""><x path="Int"/></f></get_length>
		<length public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Length of list.</haxe_doc>
		</length>
		<zpp_inner public="1">
			<c path="zpp_nape.util.ZPP_InteractionGroupList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="695">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Construct a new list.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Nape list of InteractionGroup type objects
 * <br/><br/>
 * Internally this list is at present implemented as a linked list with
 * object pooled nodes and iterators with various fast paths made for
 * standard access patterns (For instance accessing successive elements
 * runs in constant time when using random access functions)
 * <br/><br/>
 * Iteration of this list can be done in various ways, but the preferred
 * way on all targets, is through use of the foreach function:
 * <pre>
 * list.foreach(function (obj) {
 * });
 * </pre>
 * This method is inlined so that in haxe no closure will need to be created.
 * <br/><br/>
 * In AS3, a closure would need to be created in general, so for performance
 * reasons you 'may' choose to use iteration as follows:
 * <pre>
 * for (var i:int = 0; i < list.length; i++) {
 *     var obj:InteractionGroup = list.at(i);
 * }
 * </pre>
 * <br/>
 * NOTE: It is 'not' safe to modify a list whilst iterating over it.
 * If you wish to remove elements during an iteration you should use the
 * filter method, for example:
 * <pre>
 * list.filter(function (obj) {
 *     // operate on object.
 *     // ...
 *     return (false if you want object to be removed);
 * });
 * </pre>
 * <br/><br/>
 * In AS3, if you wish to avoid a closure generation, you can perform such
 * an iteration in a safe manner as follows:
 * <pre>
 * var i:int = 0;
 * while (i < list.length) {
 *     var obj:InteractionGroup = list.at(i);
 *     // operate on object.
 *     // ...
 *     if (should remove obj) {
 *         list.remove(obj);
 *         continue;
 *     }
 *     else i++;
 * }
 * </pre>
 * Or if you are always clearing the list entirely you could write:
 * <pre>
 * while (!list.empty()) {
 *     var obj:InteractionGroup = list.pop();
 *     // operate on object.
 *     // ...
 * }
 * </pre>]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.geom.AABB" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/geom/AABB.hx">
		<toString public="1" set="method" line="493">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<set_height get="inline" set="null" line="468"><f a="height">
	<x path="Float"/>
	<x path="Float"/>
</f></set_height>
		<get_height get="inline" set="null" line="464"><f a=""><x path="Float"/></f></get_height>
		<height public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* height of AABB.
     * <br/><br/>
     * This value is and must always be positive.
     * @default 0]]></haxe_doc>
		</height>
		<set_width get="inline" set="null" line="434"><f a="width">
	<x path="Float"/>
	<x path="Float"/>
</f></set_width>
		<get_width get="inline" set="null" line="430"><f a=""><x path="Float"/></f></get_width>
		<width public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* width of AABB.
     * <br/><br/>
     * This value is and must always be positive.
     * @default 0]]></haxe_doc>
		</width>
		<set_y get="inline" set="null" line="404"><f a="y">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<get_y get="inline" set="null" line="400"><f a=""><x path="Float"/></f></get_y>
		<y public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The y coordinate of the AABB's top-left corner.
     * <br/><br/>
     * Equivalent to accessing/mutating min.y.
     * @default 0]]></haxe_doc>
		</y>
		<set_x get="inline" set="null" line="374"><f a="x">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<get_x get="inline" set="null" line="370"><f a=""><x path="Float"/></f></get_x>
		<x public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The x coordinate of the AABB's top-left corner.
     * <br/><br/>
     * Equivalent to accessing/mutating min.x.
     * @default 0]]></haxe_doc>
		</x>
		<set_max get="inline" set="null" line="332"><f a="max">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_max>
		<get_max get="inline" set="null" line="329"><f a=""><c path="nape.geom.Vec2"/></f></get_max>
		<max public="1" get="accessor" set="accessor">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* The maximum bounds for the AABB.
     * <br/><br/>
     * Euivalent to the bottom-right corner.
     * <br/>
     * This Vec2 is intrinsically linked to the AABB so that modifications
     * to this object are reflected in changes to the AABB and vice-versa.
     * <br/><br/>
     * If the AABB is immutable, then this Vec2 will also be immutable.
     * <br/><br/>
     * This value can be set with the = operator, equivalent to performing
     * <code>aabb.max.set(value)</code>.
     * @default (0, 0)]]></haxe_doc>
		</max>
		<set_min get="inline" set="null" line="283"><f a="min">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_min>
		<get_min get="inline" set="null" line="280"><f a=""><c path="nape.geom.Vec2"/></f></get_min>
		<min public="1" get="accessor" set="accessor">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* The minimum bounds for the AABB.
     * <br/><br/>
     * Euivalent to the top-left corner.
     * <br/>
     * This Vec2 is intrinsically linked to the AABB so that modifications
     * to this object are reflected in changes to the AABB and vice-versa.
     * <br/><br/>
     * If the AABB is immutable, then this Vec2 will also be immutable.
     * <br/><br/>
     * This value can be set with the = operator, equivalent to performing
     * <code>aabb.min.set(value)</code>.
     * @default (0, 0)]]></haxe_doc>
		</min>
		<copy public="1" set="method" line="226">
			<f a=""><c path="nape.geom.AABB"/></f>
			<haxe_doc><![CDATA[* Produce a copy of this AABB.
     * <br/><br/>
     * As would be expected, if you produce a copy of an 'immutable' AABB then
     * the copy will be 'mutable'.
     *
     * @return The copy of this AABB.]]></haxe_doc>
		</copy>
		<zpp_inner public="1">
			<c path="zpp_nape.geom.ZPP_AABB"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="205">
			<f a="?x:?y:?width:?height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Construct a new AABB.
     * <br/><br/>
     * As input width/height are permitted to be negative it is not guaranteed
     * that the resultant AABB will have the same parameters as those
     * specified as the AABB parameters are guaranteed to always have positive
     * width/height, and for x/y to always be the top-left corner.
     *
     * @param x      The x coordinate of the top-left corner of the AABB.
     *               (default 0)
     * @param y      The y coordinate of the top-left corner of the AABB
     *               (default 0)
     * @param width  The width of the AABB. This value may be negative.
     *               (default 0)
     * @param height The height of the AABB. This value may be negative.
     *               (default 0)
     * @return       The newly constructed AABB object.]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Axis Aligned Bounding Box (AABB)
 * <br/><br/>
 * Note that in many cases of an AABB object being returned by a Nape function
 * the AABB object will be marked internally as an 'immutable' AABB. This will
 * always be documented and trying to mutate such an AABB will result in an
 * error being thrown.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.geom.ConvexResult" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/geom/ConvexResult.hx">
		<toString public="1" set="method" line="252">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<dispose public="1" get="inline" set="null" line="243">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Release ConvexResult object to pool.</haxe_doc>
		</dispose>
		<get_shape get="inline" set="null" line="223"><f a=""><c path="nape.shape.Shape"/></f></get_shape>
		<shape public="1" get="accessor" set="null">
			<c path="nape.shape.Shape"/>
			<haxe_doc>* The shape which was collided against.</haxe_doc>
		</shape>
		<get_toi get="inline" set="null" line="212"><f a=""><x path="Float"/></f></get_toi>
		<toi public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* The time of impact to the collision</haxe_doc>
		</toi>
		<get_position get="inline" set="null" line="201"><f a=""><c path="nape.geom.Vec2"/></f></get_position>
		<position public="1" get="accessor" set="null">
			<c path="nape.geom.Vec2"/>
			<haxe_doc>* The position of the collision.</haxe_doc>
		</position>
		<get_normal get="inline" set="null" line="190"><f a=""><c path="nape.geom.Vec2"/></f></get_normal>
		<normal public="1" get="accessor" set="null">
			<c path="nape.geom.Vec2"/>
			<haxe_doc>* The normal of the surface at collision.</haxe_doc>
		</normal>
		<zpp_inner public="1">
			<c path="zpp_nape.geom.ZPP_ConvexRayResult"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="234">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Class representing the results of a convex cast operation.
 * <br/><br/>
 * These objects are allocated from an object pool and can
 * be released back to that pool by calling its dispose method.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.geom.ConvexResultIterator" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/geom/ConvexResultIterator.hx">
		<zpp_pool public="1" line="194" static="1">
			<c path="nape.geom.ConvexResultIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_pool>
		<get public="1" set="method" line="217" static="1">
			<f a="list">
				<c path="nape.geom.ConvexResultList"/>
				<c path="nape.geom.ConvexResultIterator"/>
			</f>
			<haxe_doc><![CDATA[* Create iterator for Nape list.
     * <br/><br/>
     * There is no specific reason to use this over: <code>list.iterator()</code>
     * especcialy since this requires writing the class name :)
     * (This function is used internally)
     *
     * @param list The Nape list to create iterator for.
     * @return     An iterator over the Nape list.]]></haxe_doc>
		</get>
		<next public="1" get="inline" set="null" line="264">
			<f a=""><c path="nape.geom.ConvexResult"/></f>
			<haxe_doc>* Return next element in list.
     *
     * @return The next element in iteration.</haxe_doc>
		</next>
		<hasNext public="1" get="inline" set="null" line="240">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Check if there are any elements remaining.
     *
     * @return True if there are more elements to iterator over.</haxe_doc>
		</hasNext>
		<zpp_next public="1">
			<c path="nape.geom.ConvexResultIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_next>
		<zpp_critical public="1">
			<x path="Bool"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_critical>
		<zpp_i public="1">
			<x path="Int"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_i>
		<zpp_inner public="1">
			<c path="nape.geom.ConvexResultList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="202">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Haxe Iterator<T> compatible iterator over Nape list.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.geom.ConvexResultList" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/geom/ConvexResultList.hx">
		<fromArray public="1" set="method" line="304" static="1">
			<f a="array">
				<c path="Array"><c path="nape.geom.ConvexResult"/></c>
				<c path="nape.geom.ConvexResultList"/>
			</f>
			<haxe_doc>* Convert standard Array to Nape list.
     *
     * @param array The array to be converted
     * @return An equivalent Nape list.
     * @throws If array argument is null.
     * @throws If array contains elements of type other than ConvexResult</haxe_doc>
		</fromArray>
		<filter public="1" set="method" line="779">
			<f a="lambda">
				<f a="">
					<c path="nape.geom.ConvexResult"/>
					<x path="Bool"/>
				</f>
				<c path="nape.geom.ConvexResultList"/>
			</f>
			<haxe_doc><![CDATA[* Iterate over list filtering elements.
     * <br/><br/>
     * The given function will be applied to each element, whenever the
     * function returns false, the element will be removed from the list.
     * <br/><br/>
     * Any exception thrown by the supplied function will be treat as a
     * signal to halt iteration acting as a 'break' statement.
     * <br/><br/>
     * This method is to be greatly preferred for filtering logic as
     * it is otherwise unsafe to modify the list during an iteration.
     * <br/><br/>
     * An example of using this method to clean up a list whilst performing
     * actions on the elements.
     * <pre>
     * list.filter(function (obj) {
     *    // perform clean up with obj
     *    return false; // remove from list.
     * });
     * </pre>
     *
     * @param lambda The function to apply to each argument, deciding if
     *               element should be removed.
     * @return A reference to 'this' list.
     * @throws # If lambda argument is null.]]></haxe_doc>
		</filter>
		<foreach public="1" get="inline" set="null" line="732">
			<f a="lambda">
				<f a="">
					<c path="nape.geom.ConvexResult"/>
					<x path="Void"/>
				</f>
				<c path="nape.geom.ConvexResultList"/>
			</f>
			<haxe_doc><![CDATA[* Iterate over list applying function.
     * <br/><br/>
     * Any exception thrown by the supplied function will be treat as a
     * signal to halt iteration acting as a 'break' statement.
     * <br/><br/>
     * This method should be preferred to using standard haxe iteration
     * as there will be no allocation of an iterator object.
     * <pre>
     * list.foreach(function (obj) {
     *     if (ignore_object(obj)) return; //acts as a 'continue' statement
     *     if (halt_iteration(obj)) throw "": //acts as a 'break' statement
     * });
     * </pre>
     *
     * @param lambda The function to apply to each argument.
     * @return A reference to 'this' list.
     * @throws # If lambda argument is null.]]></haxe_doc>
		</foreach>
		<toString public="1" set="method" line="702">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<merge public="1" set="method" line="684">
			<f a="xs">
				<c path="nape.geom.ConvexResultList"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Merge given list into this one.
     * <br/><br/>
     * The result is that this list will have all objects from the argument
     * that were not already in the list inserted. You should make no
     * assumption about the order of these insertions.
     *
     * @param xs The list to merge.
     * @throws # If xs argument is null.]]></haxe_doc>
		</merge>
		<copy public="1" set="method" line="662">
			<f a="?deep">
				<x path="Bool"/>
				<c path="nape.geom.ConvexResultList"/>
			</f>
			<haxe_doc>* Produce a possibly deep copy of list.
     *
     * @param deep If true, then each element will have its own copy
     *             function called instead of simply having its
     *             reference copied over.
     * @return     The copied list.</haxe_doc>
		</copy>
		<iterator public="1" get="inline" set="null" line="647">
			<f a=""><c path="nape.geom.ConvexResultIterator"/></f>
			<haxe_doc><![CDATA[* Return Haxe iterator for list.
     * <br/><br/>
     * Use of this iterator, whilst stylistically better in Haxe should not
     * be used, in preference for use of the foreach function which will
     * not require allocation of an iterator object.
     * <br/><br/>
     * Equally in AS3, the foreach method should be the preferred way to iterate.]]></haxe_doc>
		</iterator>
		<empty public="1" get="inline" set="null" line="631">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Test if list is empty or not.
     *
     * @return True if list is empty.</haxe_doc>
		</empty>
		<clear public="1" set="method" line="614">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clear the list, removing all elements.
     *
     * @throws # If list is iummutable</haxe_doc>
		</clear>
		<remove public="1" set="method" line="576">
			<f a="obj">
				<c path="nape.geom.ConvexResult"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Remove element from list.
     * <br/><br/>
     * This is a linear time operation.
     *
     * @param obj The object to remove
     * @return True if object was removed from list.
     * @throws # If list is immutable]]></haxe_doc>
		</remove>
		<add public="1" get="inline" set="null" line="563">
			<f a="obj">
				<c path="nape.geom.ConvexResult"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Insert element into list in most effecient way.
     * <br/><br/>
     * This method will defer to either the push or unshift function
     * depending on which is most effecient in the context.
     * <br/><br/>
     * If order of elements is not important then you should always use
     * this function to insert elements.
     *
     * @param obj The object to insert.
     * @return True if object was successfuly inserted.
     * @throws # If list is immutable]]></haxe_doc>
		</add>
		<shift public="1" set="method" line="519">
			<f a=""><c path="nape.geom.ConvexResult"/></f>
			<haxe_doc><![CDATA[* Pop element from front of list.
     * <br/><br/>
     * If you are wanting to clear a list, whilst operating on its elements,
     * consider use of the filter method instead.
     *
     * @returns The element removed from list.
     * @throws # If list is immutable.
     * @throws # If the list is empty.]]></haxe_doc>
		</shift>
		<pop public="1" set="method" line="478">
			<f a=""><c path="nape.geom.ConvexResult"/></f>
			<haxe_doc><![CDATA[* Pop element from back of list.
     * <br/><br/>
     * If you are wanting to clear a list, whilst operating on its elements,
     * consider use of the filter method instead.
     *
     * @returns The element removed from list.
     * @throws # If list is immutable.
     * @throws # If the list is empty.]]></haxe_doc>
		</pop>
		<unshift public="1" set="method" line="447">
			<f a="obj">
				<c path="nape.geom.ConvexResult"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Push element to front of list.
     * <br/><br/>
     * When the order of objects is not important, it is best to use the
     * add() method instead.
     *
     * @param obj The object to insert.
     * @returns True if object was successively inserted.
     * @throws # If list is immutable.]]></haxe_doc>
		</unshift>
		<push public="1" set="method" line="416">
			<f a="obj">
				<c path="nape.geom.ConvexResult"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Push element to back of list.
     * <br/><br/>
     * When the order of objects is not important, it is best to use the
     * add() method instead.
     *
     * @param obj The object to insert.
     * @returns True if object was successively inserted.
     * @throws # If list is immutable.]]></haxe_doc>
		</push>
		<at public="1" set="method" line="363">
			<f a="index">
				<x path="Int"/>
				<c path="nape.geom.ConvexResult"/>
			</f>
			<haxe_doc><![CDATA[* Random access to elements of list by index.
     * <br/><br/>
     * Under normal circumstances, accessing succesive elements via this
     * method will occur in constant time.
     *
     * @param index The index of the element in list to access.
     * @returns The element at the given index.
     * @throws # If index is out of bounds.]]></haxe_doc>
		</at>
		<has public="1" set="method" line="346">
			<f a="obj">
				<c path="nape.geom.ConvexResult"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if element is already in the list
     *
     * @param obj The object to test.
     * @return True if object is in the list.</haxe_doc>
		</has>
		<get_length get="inline" set="null" line="244"><f a=""><x path="Int"/></f></get_length>
		<length public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Length of list.</haxe_doc>
		</length>
		<zpp_inner public="1">
			<c path="zpp_nape.util.ZPP_ConvexResultList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="695">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Construct a new list.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Nape list of ConvexResult type objects
 * <br/><br/>
 * Internally this list is at present implemented as a linked list with
 * object pooled nodes and iterators with various fast paths made for
 * standard access patterns (For instance accessing successive elements
 * runs in constant time when using random access functions)
 * <br/><br/>
 * Iteration of this list can be done in various ways, but the preferred
 * way on all targets, is through use of the foreach function:
 * <pre>
 * list.foreach(function (obj) {
 * });
 * </pre>
 * This method is inlined so that in haxe no closure will need to be created.
 * <br/><br/>
 * In AS3, a closure would need to be created in general, so for performance
 * reasons you 'may' choose to use iteration as follows:
 * <pre>
 * for (var i:int = 0; i < list.length; i++) {
 *     var obj:ConvexResult = list.at(i);
 * }
 * </pre>
 * <br/>
 * NOTE: It is 'not' safe to modify a list whilst iterating over it.
 * If you wish to remove elements during an iteration you should use the
 * filter method, for example:
 * <pre>
 * list.filter(function (obj) {
 *     // operate on object.
 *     // ...
 *     return (false if you want object to be removed);
 * });
 * </pre>
 * <br/><br/>
 * In AS3, if you wish to avoid a closure generation, you can perform such
 * an iteration in a safe manner as follows:
 * <pre>
 * var i:int = 0;
 * while (i < list.length) {
 *     var obj:ConvexResult = list.at(i);
 *     // operate on object.
 *     // ...
 *     if (should remove obj) {
 *         list.remove(obj);
 *         continue;
 *     }
 *     else i++;
 * }
 * </pre>
 * Or if you are always clearing the list entirely you could write:
 * <pre>
 * while (!list.empty()) {
 *     var obj:ConvexResult = list.pop();
 *     // operate on object.
 *     // ...
 * }
 * </pre>]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.geom.Geom" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/geom/Geom.hx">
		<distanceBody public="1" set="method" line="223" static="1">
			<f a="body1:body2:out1:out2">
				<c path="nape.phys.Body"/>
				<c path="nape.phys.Body"/>
				<c path="nape.geom.Vec2"/>
				<c path="nape.geom.Vec2"/>
				<x path="Float"/>
			</f>
			<haxe_doc><![CDATA[* Determine distance and closest points between two Bodies.
     * <br/><br/>
     * If the bodies are intersecting, then a negative value is returned
     * equal to the penetration of the bodies, and the out1/out2 vectors
     * will still be meaningful with their difference being the minimum
     * translational vector to seperate the intersecting shapes of the bodies.
     * (This may not be a global seperation vector as it is considering only
     *  one pair of shapes at a time).
     * <br/><br/>
     * As the out1/out2 vectors are used to return values from the function,
     * this is one of the rare cases where should out1/out2 be weak Vec2's
     * they will 'not' be sent to the global object pool on being passed to
     * this function.
     * <pre>
     * var closest1 = Vec2.get();
     * var closest2 = Vec2.get();
     * var distance = Geom.distanceBody(body1, body2, out1, out2);
     * if (distance < 0) {
     *     trace("Bodies intersect and penetration distance is " +
     *           (-distance) + " with witness points " + closest1.toString() +
     *           " <-> " + closest2.toString());
     * }else {
     *     trace("Bodies do not intersect and distance betweem them is " +
     *           distance + " with closest points " + closest1.toString() +
     *           " <-> " + closest2.toString());
     * }
     * </pre>
     * This algorithm is able to take shortcuts in culling pair tests between Shapes
     * based on the current state of the search, and will be more effecient than
     * a custom implementation that uses Geom.distance(..) method.
     *
     * @param body1 First input Body.
     * @param body2 Second input Body.
     * @param out1 This Vec2 object will be populated with coordinates of
     *             closest point on body1.
     * @param out2 This Vec2 object will be populated with coordinates of
     *             closest point on body2.
     * @return The distance between the two bodies if seperated, or the
     *         penetration distance (negative) if intersecting.
     * @throws # If either body has no shapes.
     * @throws # If out1 or out2 has been disposed.
     * @throws # If out1 or out2 is immutable.]]></haxe_doc>
		</distanceBody>
		<distance public="1" set="method" line="301" static="1">
			<f a="shape1:shape2:out1:out2">
				<c path="nape.shape.Shape"/>
				<c path="nape.shape.Shape"/>
				<c path="nape.geom.Vec2"/>
				<c path="nape.geom.Vec2"/>
				<x path="Float"/>
			</f>
			<haxe_doc><![CDATA[* Determine distance and closest points between two Shapes.
     * <br/><br/>
     * The input Shapes must belong to a Body so that their world positions
     * and orientations are defined; these Bodies need not be different nor
     * part of any Space.
     * <br/><br/>
     * If the shapes are intersecting, then a negative value is returned
     * equal to the penetration of the shapes, and the out1/out2 vectors
     * will still be meaningful with their difference being the minimum
     * translational vector to seperate the Shapes.
     * <br/><br/>
     * As the out1/out2 vectors are used to return values from the function,
     * this is one of the rare cases where should out1/out2 be weak Vec2's
     * they will 'not' be sent to the global object pool on being passed to
     * this function.
     * <pre>
     * var closest1 = Vec2.get();
     * var closest2 = Vec2.get();
     * var distance = Geom.distance(shape1, shape2, out1, out2);
     * if (distance < 0) {
     *     trace("Shapes intersect and penetration distance is " +
     *           (-distance) + " with witness points " + closest1.toString() +
     *           " <-> " + closest2.toString());
     * }else {
     *     trace("Shapes do not intersect and distance betweem them is " +
     *           distance + " with closest points " + closest1.toString() +
     *           " <-> " + closest2.toString());
     * }
     * </pre>
     *
     * @param shape1 this shape must belong to a Body.
     * @param shape2 this shape must belong to a Body.
     * @param out1 This Vec2 object will be populated with coordinates of
     *             closest point on shape1.
     * @param out2 This Vec2 object will be populated with coordinates of
     *             closest point on shape2.
     * @return The distance between the two shapes if seperated, or the
     *         penetration distance (negative) if intersecting.
     * @throws # If shape1.body is null or shape2.body is null.
     * @throws # If out1 or out2 has been disposed.
     * @throws # If out1 or out2 is immutable.]]></haxe_doc>
		</distance>
		<intersectsBody public="1" set="method" line="370" static="1">
			<f a="body1:body2">
				<c path="nape.phys.Body"/>
				<c path="nape.phys.Body"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Determine if two Bodies intersect.
     * <br/><br/>
     * If you do not need distance/penetration information,
     * then using this method will be more effecient than testing for a negative
     * value using the distance method.
     *
     * @param body1 First input Body .
     * @param body2 Second input Body.
     * @return True if the Bodies are intersecting.
     * @throws # If either body has no shapes.]]></haxe_doc>
		</intersectsBody>
		<intersects public="1" set="method" line="435" static="1">
			<f a="shape1:shape2">
				<c path="nape.shape.Shape"/>
				<c path="nape.shape.Shape"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Determine if two Shapes intersect.
     * <br/><br/>
     * The input Shapes must belong to a Body so that their world positions
     * and orientations are defined; these Bodies need not be different nor
     * part of any Space.
     * <br/><br/>
     * If you do not need distance/penetration information,
     * then using this method will be more effecient than testing for a negative
     * value using the distance method.
     *
     * @param shape1 this shape must belong to a Body.
     * @param shape2 this shape must belong to a Body.
     * @return True if the shapes are intersecting in world space.
     * @throws # If shape1.body or shape2.body is null.]]></haxe_doc>
		</intersects>
		<contains public="1" set="method" line="456" static="1">
			<f a="shape1:shape2">
				<c path="nape.shape.Shape"/>
				<c path="nape.shape.Shape"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Determine if one Shape is entirely contained within another.
     * <br/><br/>
     * The input Shapes must belong to a Body so that their world positions
     * and orientations are defined; these Bodies need not be different nor
     * part of any Space.
     *
     * @param shape1 this shape must belong to a Body.
     * @param shape2 this shape must belong to a Body.
     * @return True if shape2 is completely contained within shape1.
     * @throws # If shape1.body or shape2.body is null.]]></haxe_doc>
		</contains>
		<haxe_doc>* Geom class provides interface to collision detection routines in nape.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.geom.GeomPoly" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/geom/GeomPoly.hx">
		<get public="1" set="method" line="1175" static="1">
			<f a="?vertices">
				<d/>
				<c path="nape.geom.GeomPoly"/>
			</f>
			<haxe_doc><![CDATA[* Allocate GeomPoly from object pool.
     * <br/><br/>
     * The vertices argument is typed Dynamic (* in AS3), and is permitted
     * to be one of: <code>Array&lt;Vec2&gt;, flash.Vector&lt;Vec2&gt;, Vec2List, GeomPoly</code>
     * <br/><br/>
     * The input will be used to initialise the vertices of the polygon with
     * the head of the polygon pointing to the first vertex in input with vertices
     * inserted in forward order.
     *
     * @param vertices Vertex data to initialise polygon, or null for empty polygon.
     * @return New GeomPoly representing input vertex data, allocated from object pool.
     * @throws # If input data is not of an expected Type.]]></haxe_doc>
		</get>
		<right public="1" set="method" line="2770">
			<f a=""><c path="nape.geom.Vec2"/></f>
			<haxe_doc><![CDATA[* Find right most vertex of polygon.
     * <br/><br/>
     * If there is more than one such vertex then the result is indeterminate.
     * <br/><br/>
     * The Vec2 returned is intrinsically tied to the inner vertex like that
     * returned by current(). This method will not alter the current vertex.
     * This Vec2 is not able to be disposed of.
     *
     * @return A Vec2 representing the right most vertex.
     * @throws # If polygon is empty.
     * @throws # If this GeomPoly has been disposed.]]></haxe_doc>
		</right>
		<left public="1" set="method" line="2728">
			<f a=""><c path="nape.geom.Vec2"/></f>
			<haxe_doc><![CDATA[* Find left most vertex of polygon.
     * <br/><br/>
     * If there is more than one such vertex then the result is indeterminate.
     * <br/><br/>
     * The Vec2 returned is intrinsically tied to the inner vertex like that
     * returned by current(). This method will not alter the current vertex.
     * This Vec2 is not able to be disposed of.
     *
     * @return A Vec2 representing the left most vertex.
     * @throws # If polygon is empty.
     * @throws # If this GeomPoly has been disposed.]]></haxe_doc>
		</left>
		<bottom public="1" set="method" line="2686">
			<f a=""><c path="nape.geom.Vec2"/></f>
			<haxe_doc><![CDATA[* Find bottom most vertex of polygon.
     * <br/><br/>
     * If there is more than one such vertex then the result is indeterminate.
     * <br/><br/>
     * The Vec2 returned is intrinsically tied to the inner vertex like that
     * returned by current(). This method will not alter the current vertex.
     * This Vec2 is not able to be disposed of.
     *
     * @return A Vec2 representing the bottom most vertex.
     * @throws # If polygon is empty.
     * @throws # If this GeomPoly has been disposed.]]></haxe_doc>
		</bottom>
		<top public="1" set="method" line="2644">
			<f a=""><c path="nape.geom.Vec2"/></f>
			<haxe_doc><![CDATA[* Find top most vertex of polygon.
     * <br/><br/>
     * If there is more than one such vertex then the result is indeterminate.
     * <br/><br/>
     * The Vec2 returned is intrinsically tied to the inner vertex like that
     * returned by current(). This method will not alter the current vertex.
     * This Vec2 is not able to be disposed of.
     *
     * @return A Vec2 representing the top most vertex.
     * @throws # If polygon is empty.
     * @throws # If this GeomPoly has been disposed.]]></haxe_doc>
		</top>
		<bounds public="1" set="method" line="2562">
			<f a=""><c path="nape.geom.AABB"/></f>
			<haxe_doc>* Determine bounds of polygon.
     *
     * @return A new AABB representing bounds of polygon.
     * @throws # If polygon is empty.
     * @throws # If this GeomPoly has been disposed.</haxe_doc>
		</bounds>
		<transform public="1" set="method" line="2521">
			<f a="matrix">
				<c path="nape.geom.Mat23"/>
				<c path="nape.geom.GeomPoly"/>
			</f>
			<haxe_doc><![CDATA[* Transform polygon by given matrix.
     * <br/><br/>
     * Any transformation (not just equiorthogonal ones) are permitted, though
     * a transformation that causes polygon to be come degenerate is a bit
     * pointless.
     *
     * @param matrix The matrix to transform polygon by.
     * @return A reference to this polygon.
     * @throws # If matrix is null.
     * @throws # If this GeomPoly has been disposed.]]></haxe_doc>
		</transform>
		<cut public="1" set="method" line="2460">
			<f a="start:end:?boundedStart:?boundedEnd:?output">
				<c path="nape.geom.Vec2"/>
				<c path="nape.geom.Vec2"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="nape.geom.GeomPolyList"/>
				<c path="nape.geom.GeomPolyList"/>
			</f>
			<haxe_doc><![CDATA[* Cut simple polygon with line.
     * <br/><br/>
     * The result of this operation will be a list of new GeomPoly representing
     * the connected regions of the polygon after an imaginary cut is made.
     * <pre>
     * (Result of cut assuming
     *  boundedStart = true)       _
     *   /&#92;    _             /&#92;   / &#92;
     *  /  &#92;  / &#92;           /  &#92; '---'
     * / o--&#92;/---&#92;-->  =>  /    &#92;,---,
     * &#92;_________/         &#92;_________/
     * </pre>
     * This algorithm runs in average case O(n.log(n)) time and worst case O(n^2).
     * For convex polygons, this algorithm runs in guaranteed O(n) time.
     *
     * @param start The start point for line segment
     * @param end The end point for line segment.
     * @param boundedStart If true, then the cut will not extend
     *                     beyond the start of the line segment.
     *                     (default false)
     * @param boundedEnd   If true, then the cut will not extend
     *                     beyond the end of the line segment.
     *                     (default false)
     * @param output A GeomPolyList to append results to if supplied,
     *               otherwise a new list is created (default null)
     * @return A list of GeomPoly representing the result of the cut.
     * @throws # If polygon is not simple.
     * @throws # If start or end Vec2 are null or disposed of.
     * @throws # If this GeomPoly has been disposed.]]></haxe_doc>
		</cut>
		<inflate public="1" set="method" line="2227">
			<f a="inflation">
				<x path="Float"/>
				<c path="nape.geom.GeomPoly"/>
			</f>
			<haxe_doc><![CDATA[* Inflate/Deflate polygon.
     * <br/><br/>
     * This algorithm does not attempt to deal with any self-intersections which may
     * result from the process. Gaps are joined with a miter joint.
     * <br/><br/>
     * This algorithm will work for self-intersecting polygons, though the results
     * may not be what you expect; some parts will be inflated, and some deflated
     * depending on the local winding. You should probably avoid using this on
     * self-intersecting polygons.
     *
     * @param inflation The number of pixels to inflate polygon by. To deflate
     *                  use a negative value.
     * @return The inflated polygon.
     * @throws # If this GeomPoly has been disposed.]]></haxe_doc>
		</inflate>
		<triangularDecomposition public="1" set="method" line="2154">
			<f a="?delaunay:?output">
				<x path="Bool"/>
				<c path="nape.geom.GeomPolyList"/>
				<c path="nape.geom.GeomPolyList"/>
			</f>
			<haxe_doc><![CDATA[* Produce a decomposition of weakly-simple polygon into triangles.
     * <br/><br/>
     * This algorithm 'should' be 100% robust and has been well test on for
     * example, the output of the Marching Squars utility which produces many
     * degenerate cases of weakly-simple polygons that have not yet broken this
     * algorithm!.
     * <br/><br/>
     * This algorithm operates in O(n.log(n)) time.
     * <br/><br/>
     * Vertices may be stripped from the polygon that are found to not be
     * necessary as part of making this algorithm robust.
     *
     * @param delaunay If true, then an O(n^2) pass will be made to mutate the original
     *                 triangulation to push it into a delanuay triangulation. (default false)
     * @param output If supplied, polygons will be appended to this list via 'add'
     *        instead of a new list being constructed.
     * @return A Nape list of GeomPoly's defining the decomposition.
     * @throws # If polygon is degenerate.
     * @throws # If this GeomPoly has been disposed.]]></haxe_doc>
		</triangularDecomposition>
		<convexDecomposition public="1" set="method" line="2075">
			<f a="?delaunay:?output">
				<x path="Bool"/>
				<c path="nape.geom.GeomPolyList"/>
				<c path="nape.geom.GeomPolyList"/>
			</f>
			<haxe_doc><![CDATA[* Produce a decomposition of weakly-simple polygon into convex components.
     * <br/><br/>
     * This algorithm 'should' be 100% robust and has been well test on for
     * example, the output of the Marching Squars utility which produces many
     * degenerate cases of weakly-simple polygons that have not yet broken this
     * algorithm!.
     * <br/><br/>
     * This algorithm operates in O(n.log(n)) time and will produce no more than
     * 4 times the number of convex poylgons in a minimal decomposition in the
     * worst case scenario.
     * <br/><br/>
     * Vertices may be stripped from the polygon that are found to not be
     * necessary as part of making this algorithm robust.
     *
     * @param delaunay This algorithm first performs a triangulation, if this field
     *                 is true, then this triangulation will be made delaunay and may
     *                 produce better convex polygons resultanly (default false).
     * @param output If supplied, polygons will be appended to this list via 'add'
     *        instead of a new list being constructed.
     * @return A Nape list of GeomPoly's defining the decomposition.
     * @throws # If polygon is degenerate.
     * @throws # If this GeomPoly has been disposed.]]></haxe_doc>
		</convexDecomposition>
		<monotoneDecomposition public="1" set="method" line="2019">
			<f a="?output">
				<c path="nape.geom.GeomPolyList"/>
				<c path="nape.geom.GeomPolyList"/>
			</f>
			<haxe_doc><![CDATA[* Produce a decomposition of weakly-simple polygon into monotone components.
     * <br/><br/>
     * This algorithm 'should' be 100% robust and has been well tested on for
     * example, the output of the Marching Squares utility which produces many
     * degenerate cases of weakly-simple polygons that have not yet broken this
     * algorithm!.
     * <br/><br/>
     * This algorithm operates in O(n.log(n)) time and may strip vertices from
     * the polygon in degenerate cases where vertex is not needed to define the
     * polygon.
     * <br/><br/>
     * This algorithm is an improved version of the one presented in: Mark de
     * Berg, Marc van Kreveld, Mark Overmars, and Otfried Schwarzkopf.
     * Computational Geometry: Algorithms and Applications. Springer-Verlag,
     * Berlin, 1997.
    
     * @param output If supplied, polygons will be appended to this list via 'add'
     *        instead of a new list being constructed.
     * @return A Nape list of GeomPoly's defining the decomposition.
     * @throws # If polygon is degenerate.
     * @throws # If this GeomPoly has been disposed.]]></haxe_doc>
		</monotoneDecomposition>
		<simpleDecomposition public="1" set="method" line="1973">
			<f a="?output">
				<c path="nape.geom.GeomPolyList"/>
				<c path="nape.geom.GeomPolyList"/>
			</f>
			<haxe_doc><![CDATA[* Produce a decomposition of complex polygon into simple components.
     * <br/><br/>
     * WARNING: This method is 'not' 100% robust. It may fail!
     * <br/><br/>
     * Produce a decomposition of a self intersecting, complex polygon into
     * a set of weakly-simple components.
     * <br/><br/>
     * This algorithm operates in O(n.log(n)) time and is based on the
     * Bentley-Ottmann algorithm.
     *
     * @param output If supplied, polygons will be appended to this list via 'add'
     *        instead of a new list being constructed.
     * @return A Nape list of GeomPoly's representing the decomposition.
     * @throws # If polygon is degenerate.
     * @throws # Any other error may be thrown if algorithm has failed, even
     *           in release builds!
     * @throws # If this GeomPoly has been disposed.]]></haxe_doc>
		</simpleDecomposition>
		<simplify public="1" set="method" line="1931">
			<f a="epsilon">
				<x path="Float"/>
				<c path="nape.geom.GeomPoly"/>
			</f>
			<haxe_doc><![CDATA[* Simplify polygon.
     * <br/><br/>
     * Simplification is performed with an implementation of the Ramer-Douglas-Peucker
     * algorithm. The output polygon is formed via subset of the vertices in
     * the input polygon such that any discarded vertex is at most 'epsilon' pixels
     * away from the local output polygon.
     * <br/><br/>
     * This algorithm works on both simple and complex polygons, but please note
     * that this algorithm makes no guarantees on a simple polygon remaining simple
     * after simplification. This should not generally be a problem unless the epsilon
     * value is large with respect to the size of the features on the polygon.
     * <br/><br/>
     * Many of the geometric algorithms will mark vertices as important, such that
     * they will be guaranteed to exist after simplification (Such as preventing
     * gaps from opening up in marching squares when simplifying output polygons).
     * <br/><br/>
     * The average runtime of this algorithm is O(n.log(n)). This algorithm is
     * not stable in the sense that adding a new vertex to the polygon may drastically
     * change the result of simplifying the polygon.
     *
     * @param epsilon The distance from polygon at which vertices are ignored.
     * @return A new GeomPoly representing the result of the simplification.
     * @throws # If epsilon is <= 0.
     * @throws # If this GeomPoly has been disposed.]]></haxe_doc>
		</simplify>
		<isDegenerate public="1" get="inline" set="null" line="1895">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[* Determine if weakly-simple polygon is degenerate.
     * <br/><br/>
     * Degeneracy is determined by having a zero area, if polygon is complex,
     * then this function may report degeneracy erroneously.
     *
     * @return True if polygon is degenerate.
     * @throws # If this GeomPoly has been disposed.]]></haxe_doc>
		</isDegenerate>
		<isMonotone public="1" get="inline" set="null" line="1875">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[* Determine if polygon is y-monotone.
     * <br/><br/>
     * To be classed as y-monotone, the polygon must be such that any horizontal
     * line intersects the polygon in at most 2 intersections.
     * <pre>
     *  ___
     * |   |
     * |   |  <-- y-monotone
     * |___|
     *
     * |&#92;
     * | &#92;/|  <-- not y-monotone, offending vertex at bottom of the V.
     * |___|
     * </pre>
     * This algorithm operates in O(n) time.
     *
     * @return True if polygon is y-monotone.
     * @throws # If this GeomPoly has been disposed.]]></haxe_doc>
		</isMonotone>
		<isSimple public="1" get="inline" set="null" line="1844">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[* Determine if polygon is strictly simple.
     * <br/><br/>
     * By strict simplicity, we refer to not permitting 'glancing'
     * self intersections (where boundary of polygon 'touches' but does not
     * pass through another area of the polygon's boundary). This property
     * is instead referred to as being 'weakly simple' for which there is no
     * easy test!
     * <pre>
     *  _______
     * |   __  |  <-- strictly simple polygon.
     * |   &#92; &#92;_|
     *  &#92;__/
     *  _______
     * |   |   |
     * |  /_&#92;  | <-- weakly simple polygon.
     *  &#92;_____/
     *  ____
     * | __/
     *  X_  __   <-- complex polygon.
     * |  &#92;/  &#92;
     * &#92;__/&#92;__|
     * </pre>
     * This algorithm operates in O(n.log(n)) time.
     *
     * @return True if polygon is strictly simple.
     * @throws # If this GeomPoly has been disposed.]]></haxe_doc>
		</isSimple>
		<isConvex public="1" set="method" line="1735">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[* Determine if weakly-simple polygon is convex.
     * <br/><br/>
     * This algorithm assumes that the polygon is weakly-simple. Otherwise it may
     * fail (It is very easy to construct a self intersecting polygon which
     * will return True for isConvex()).
     * <br/><br/>
     * You may wish to instead use <code>isSimple() && isConvex()</code> if
     * you cannot be sure of the polygon being simple, noting that this will
     * of course return false in the case of a weakly-simple polygon.
     * <pre>
     *  _____
     * |     |
     * |     |  <-- convex
     * |____/
     *  __
     * |  &#92;___
     * |     /  <-- concave
     * |____/
     * </pre>
     * This algorithm operates in O(n) time.
     *
     * @return True if polygon is found to be convex.
     * @throws # If this GeomPoly has been disposed.]]></haxe_doc>
		</isConvex>
		<isClockwise public="1" get="inline" set="null" line="1707">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[* Determine if polygon is clockwise wound.
     * <br/><br/>
     * This is equivalent to <code>poly.winding() == Winding.CLOCKWISE</code>.
     *
     * @return True if polygon is clockwise wound.
     * @throws # If this GeomPoly has been disposed.]]></haxe_doc>
		</isClockwise>
		<contains public="1" set="method" line="1641">
			<f a="point">
				<c path="nape.geom.Vec2"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Determine if point is contained in polygon.
     * <br/><br/>
     * Polygon containment is performed with a ray cast through polygon
     * from the vertex and counting the number of intersections. In this
     * way containment will be defined for self-intersecting polygons based
     * on how such a polygon would be rendered with areas of self-intersection
     * treat as being 'outside' the polygon.
     * <br/><br/>
     * This algorithm operates in O(n) time.
     *
     * @param point The point to test for containment.
     * @return True if point is contained in the polygon.
     * @throws # If point is null or has been disposed.
     * @throws # If this GeomPoly has been disposed.]]></haxe_doc>
		</contains>
		<winding public="1" set="method" line="1565">
			<f a=""><c path="nape.geom.Winding"/></f>
			<haxe_doc><![CDATA[* Compute the winding order for this polygon.
     * <br/><br/>
     * The winding order can be conceptualised by thinking of an analog
     * clock face, if your polygon is the numbers on the clock then a
     * clockwise winding would have your polygon's vertices in numerical
     * order.
     * <br/><br/>
     * In the case of a non-simple polygon with self intersections then the
     * winding order is decided by how 'much' of the polygon is locally
     * clockwise wound, and how much is locally anti-clockwise wound.
     * <br/>
     * (Think of a figure 8 style polygon where one loop is larger than the
     * other. This larger loop will dictate the winding of the polygon.)
     * <br/><br/>
     * If no winding can be computed, then <code>Winding.UNDEFINED</code>
     * will be returned.
     *
     * @return The winding of the polygon.
     * @throws # If this GeomPoly has been disposed.]]></haxe_doc>
		</winding>
		<area public="1" set="method" line="1487">
			<f a=""><x path="Float"/></f>
			<haxe_doc><![CDATA[* Compute area of weakly-simple polygon.
     * <br/><br/>
     * For complex polygons, this function will return an underestimate
     * to the true area.
     *
     * @return The area of the polygon.
     * @throws # If this GeomPoly has been disposed.]]></haxe_doc>
		</area>
		<toString public="1" set="method" line="1454">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<dispose public="1" set="method" line="1416">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Release this GeomPoly to global object pool.
     * <br/><br/>
     * Once disposed this GeomPoly will be accessible to Nape internals for re-allocation
     * and should not be touched (Good practice would be to set any references to this
     * GeomPoly to null to help ensure this).
     * <br/><br/>
     * In debug mode, should you attempt to access this GeomPoly after disposal
     * and the GeomPoly is still in the object pool, you will be given an Error.
     * The object pool operates on a First-In-Last-Out principal in debug mode to help
     * catch these sort of errors.
     * @throws # If this GeomPoly has already been disposed.]]></haxe_doc>
		</dispose>
		<copy public="1" set="method" line="902">
			<f a=""><c path="nape.geom.GeomPoly"/></f>
			<haxe_doc><![CDATA[* Copy this polygon.
     * <br/><br/>
     * The copy will have its vertices in the same order as 'this' polygon.
     * It will also have its current vertex at head, as the same vertex
     * this polygon has.
     * <br/><br/>
     * This polygon will not be modified in any way.
     * <pre>
     * poly := -> A <-> B <-> C <-> D <-> E <-
     *                (head)
     *
     * poly2 = poly.copy();
     *
     * poly2 := -> A' <-> B' <-> C' <-> D' <-> E' <-
     *                  (head)
     * </pre>
     *
     * @return The new GeomPoly representing the copy.
     * @throws # If this GeomPoly has been disposed.]]></haxe_doc>
		</copy>
		<clear public="1" set="method" line="827">
			<f a=""><c path="nape.geom.GeomPoly"/></f>
			<haxe_doc><![CDATA[* Clear all vertices from polygon.
     * <br/><br/>
     * All of the vertices will be released to the global object pool.
     *
     * @return A reference to this polygon.
     * @throws # If this GeomPoly has been disposed.]]></haxe_doc>
		</clear>
		<erase public="1" set="method" line="737">
			<f a="count">
				<x path="Int"/>
				<c path="nape.geom.GeomPoly"/>
			</f>
			<haxe_doc><![CDATA[* Erase count number of elements
     * <br/><br/>
     * For positive values of count, this is equivalent to successive
     * unshift operations.
     * <br/><br/>
     * For negative values of count, this is equivalent to successive
     * pop operations.
     * <pre>
     * poly := -> A <-> B <-> C <-> D <-> E <-> F <-> G <-
     *                (head)
     *
     * poly.erase(2);
     *
     * poly := -> A <-> D <-> E <-> F <-> G <-
     *                (head)
     *
     * poly.erase(-3);
     *
     * poly := -> E <-> F <-
     *                (head)
     * </pre>
     * In this case that the specified number of elements to erase is
     * greater than the size of the polygon, the method will simply
     * terminate with the polygon being empty.
     *
     * @param count The number of vertices to erase, with sign indicating
     *              the direction for erasing.
     * @return A reference to this polygon.
     * @throws # If this GeomPoly has been disposed.]]></haxe_doc>
		</erase>
		<skipBackwards public="1" get="inline" set="null" line="698">
			<f a="times">
				<x path="Int"/>
				<c path="nape.geom.GeomPoly"/>
			</f>
			<haxe_doc><![CDATA[* Advance head of polygon backwards.
     * <br/><br/>
     * The current head of polygon will be moved backwards
     * the given number of times, with a negative value
     * being equivalent to performing a forwards advance.
     * <br/><br/>
     * <code>poly.skip_backwards(times)</code> is equivalent to
     * <code>poly.skip_forwards(-times)</code>
     * <pre>
     * poly := -> A <-> B <-> C <-> D <-> E <-
     *                (head)
     *
     * poly.skipBackwards(2);
     *
     * poly := -> A <-> B <-> C <-> D <-> E <-
     *                                  (head)
     * </pre>
     *
     * @params times The number of times to advance head backwards.
     *               This value can be negative indicating a forwards
     *               advance.
     * @return A reference to this polygon.
     * @throws # If this GeomPoly has been disposed.]]></haxe_doc>
		</skipBackwards>
		<skipForward public="1" set="method" line="656">
			<f a="times">
				<x path="Int"/>
				<c path="nape.geom.GeomPoly"/>
			</f>
			<haxe_doc><![CDATA[* Advance head of polygon forward.
     * <br/><br/>
     * The current head of polygon will be moved forwards
     * the given number of times, with a negative value
     * being equivalent to performing a backwards advance.
     * <br/><br/>
     * <code>poly.skip_forwards(times)</code> is equivalent to
     * <code>poly.skip_backwards(-times)</code>
     * <pre>
     * poly := -> A <-> B <-> C <-> D <-> E <-
     *                (head)
     *
     * poly.skipForwards(2);
     *
     * poly := -> A <-> B <-> C <-> D <-> E <-
     *                            (head)
     * </pre>
     *
     * @params times The number of times to advance head forward.
     *               This value can be negative indicating a backwards
     *               advance.
     * @return A reference to this polygon.
     * @throws # If this GeomPoly has been disposed.]]></haxe_doc>
		</skipForward>
		<shift public="1" set="method" line="576">
			<f a=""><c path="nape.geom.GeomPoly"/></f>
			<haxe_doc><![CDATA[* Shift vertex from polygon.
     * <br/><br/>
     * Shift the current vertex at head of polygon, advancing the 'current'
     * vertex to point to the next vertex in polygon. This inner vertex
     * will be released to the global object pool.
     * <br/><br/>
     * In this way a shift which follows an unshift will act to reset the
     * unshift operation.
     * <pre>
     * poly := -> A <-> B <-> C <-> D <-> E <-
     *                (head)
     *
     * poly.shift();
     *
     * poly := -> A <-> C <-> D <-> E <-
     *                (head)
     * </pre>
     *
     * @return A reference to this polygon.
     * @throws # If polygon is empty.
     * @throws # If this GeomPoly has been disposed.]]></haxe_doc>
		</shift>
		<unshift public="1" set="method" line="518">
			<f a="vertex">
				<c path="nape.geom.Vec2"/>
				<c path="nape.geom.GeomPoly"/>
			</f>
			<haxe_doc><![CDATA[* Unshift vertex to polygon.
     * <br/><br/>
     * A vertex will be allocated from a global object pool, and initialised
     * with the values of the given Vec2.
     * <br/><br/>
     * This vertex will be inserted before the current head, and the head
     * retreated to the newly inserted vertex, in this way successive unshifts
     * will insert elements in the expected reverse order.
     * <br/><br/>
     * Note that the Vec2 supplied as argument is only used to initialise the
     * inner Vertex.
     * <pre>
     * poly := -> A <-> B <-> C <-> D <-> E <-
     *                (head)
     *
     * poly.unshift(X);
     *
     * poly := -> A <-> X <-> B <-> C <-> D <-> E <-
     *                (head)
     * </pre>
     *
     * @param vertex The Vec2 to be used in initialising the inner vertex.
     * @return A reference to this polygon.
     * @throws # If Vec2 is null, or has been disposed.
     * @throws # If this GeomPoly has been disposed.]]></haxe_doc>
		</unshift>
		<pop public="1" set="method" line="436">
			<f a=""><c path="nape.geom.GeomPoly"/></f>
			<haxe_doc><![CDATA[* Pop vertex from polygon.
     * <br/><br/>
     * Pop the current vertex at head of polygon, retreating the 'current'
     * vertex to point to the previous vertex in polygon. This inner vertex
     * will be released to the global object pool.
     * <br/><br/>
     * In this way a pop which follows a push will act to reset the push.
     * <pre>
     * poly := -> A <-> B <-> C <-> D <-> E <-
     *                (head)
     *
     * poly.pop();
     *
     * poly := -> A <-> C <-> D <-> E <-
     *          (head)
     * </pre>
     *
     * @return A reference to this polygon.
     * @throws # If polygon is empty.
     * @throws # If this GeomPoly has been disposed.]]></haxe_doc>
		</pop>
		<push public="1" set="method" line="374">
			<f a="vertex">
				<c path="nape.geom.Vec2"/>
				<c path="nape.geom.GeomPoly"/>
			</f>
			<haxe_doc><![CDATA[* Push vertex to polygon.
     * <br/><br/>
     * A vertex will be allocated from a global object pool, and initialised
     * with the values of the given Vec2.
     * <br/><br/>
     * This vertex will be inserted after the current head, and the head
     * advanced to the newly inserted vertex, in this way successive pushes
     * will insert elements in order.
     * <br/><br/>
     * Note that the Vec2 supplied as argument is only used to initialise the
     * inner Vertex.
     * <pre>
     * poly := -> A <-> B <-> C <-> D <-> E <-
     *                (head)
     *
     * poly.push(X);
     *
     * poly := -> A <-> B <-> X <-> C <-> D <-> E <-
     *                      (head)
     * </pre>
     *
     * @param vertex The Vec2 to be used in initialising the inner vertex.
     * @return A reference to this polygon.
     * @throws # If Vec2 is null, or has been disposed.
     * @throws # If this GeomPoly has been disposed.]]></haxe_doc>
		</push>
		<current public="1" get="inline" set="null" line="334">
			<f a=""><c path="nape.geom.Vec2"/></f>
			<haxe_doc><![CDATA[* Current vertex at head of polygon.
     * <br/><br/>
     * The current vertex will not be changed by this access.
     * <br/><br/>
     * This function returns a Vec2 which will be intrinsically tied
     * to the values of the internal vertex so that modifications to
     * this Vec2 will be reflected in the vertex of the polygon.
     * <br/><br/>
     * If invoked again with the head of the polygon pointing to the
     * same vertex, then the same Vec2 will be returned; this Vec2 is
     * not able to be disposed of.
     *
     * @return A Vec2 representing the current vertex of polygon.
     * @throws # If polygon is empty.
     * @throws # If this GeomPoly has been disposed.]]></haxe_doc>
		</current>
		<backwardsIterator public="1" get="inline" set="null" line="308">
			<f a=""><c path="nape.geom.GeomVertexIterator"/></f>
			<haxe_doc>* Haxe iterator over vertices of polygon.
     *
     * @return A Haxe iterator over the vertices of the polygon.
     *         Iterating in a backwards direction.
     * @throws # If this GeomPoly has been disposed.</haxe_doc>
		</backwardsIterator>
		<forwardIterator public="1" get="inline" set="null" line="292">
			<f a=""><c path="nape.geom.GeomVertexIterator"/></f>
			<haxe_doc>* Haxe iterator over vertices of polygon.
     *
     * @return A Haxe iterator over the vertices of the polygon.
     *         Iterating in a forward direction.
     * @throws # If this GeomPoly has been disposed.</haxe_doc>
		</forwardIterator>
		<iterator public="1" get="inline" set="null" line="276">
			<f a=""><c path="nape.geom.GeomVertexIterator"/></f>
			<haxe_doc>* Haxe iterator over vertices of polygon.
     *
     * @return A Haxe iterator over the vertices of the polygon.
     * @throws # If this GeomPoly has been disposed.</haxe_doc>
		</iterator>
		<size public="1" set="method" line="243">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Determine number of vertices in polygon
     *
     * @return The number of vertices.
     * @throws # If this GeomPoly has been disposed.</haxe_doc>
		</size>
		<empty public="1" get="inline" set="null" line="229">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Determine if polygon is empty.
     *
     * @return True if polygon is empty.
     * @throws # If this GeomPoly has been disposed.</haxe_doc>
		</empty>
		<zpp_inner public="1">
			<c path="zpp_nape.geom.ZPP_GeomPoly"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<zpp_disp public="1">
			<x path="Bool"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_disp>
		<zpp_pool public="1">
			<c path="nape.geom.GeomPoly"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_pool>
		<new public="1" set="method" line="954">
			<f a="?vertices">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Create a new GeomPoly polygon.
     * <br/><br/>
     * The vertices argument is typed Dynamic (* in AS3), and is permitted
     * to be one of: <code>Array&lt;Vec2&gt;, flash.Vector&lt;Vec2&gt;, Vec2List, GeomPoly</code>
     * <br/><br/>
     * The input will be used to initialise the vertices of the polygon with
     * the head of the polygon pointing to the first vertex in input with vertices
     * inserted in forward order.
     * <br/><br/>
     * You should use the static 'get' method in preference to make use of object pool.
     *
     * @param vertices Vertex data to initialise polygon, or null for empty polygon.
     * @return New GeomPoly representing input vertex data.
     * @throws # If input data is not of an expected Type.]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Polygon class with various geometric methods
 * <br/><br/>
 * This class represents a general Polygon, rather than the Polygon class
 * which is physics shape.
 * <br/><br/>
 * Internally this polygon is stored as a circularly linked list of special
 * vertex types that are exposed via a Vec2 that is lazily constructed whenever
 * necessary to the API.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.geom.GeomPolyIterator" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/geom/GeomPolyIterator.hx">
		<zpp_pool public="1" line="194" static="1">
			<c path="nape.geom.GeomPolyIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_pool>
		<get public="1" set="method" line="217" static="1">
			<f a="list">
				<c path="nape.geom.GeomPolyList"/>
				<c path="nape.geom.GeomPolyIterator"/>
			</f>
			<haxe_doc><![CDATA[* Create iterator for Nape list.
     * <br/><br/>
     * There is no specific reason to use this over: <code>list.iterator()</code>
     * especcialy since this requires writing the class name :)
     * (This function is used internally)
     *
     * @param list The Nape list to create iterator for.
     * @return     An iterator over the Nape list.]]></haxe_doc>
		</get>
		<next public="1" get="inline" set="null" line="264">
			<f a=""><c path="nape.geom.GeomPoly"/></f>
			<haxe_doc>* Return next element in list.
     *
     * @return The next element in iteration.</haxe_doc>
		</next>
		<hasNext public="1" get="inline" set="null" line="240">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Check if there are any elements remaining.
     *
     * @return True if there are more elements to iterator over.</haxe_doc>
		</hasNext>
		<zpp_next public="1">
			<c path="nape.geom.GeomPolyIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_next>
		<zpp_critical public="1">
			<x path="Bool"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_critical>
		<zpp_i public="1">
			<x path="Int"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_i>
		<zpp_inner public="1">
			<c path="nape.geom.GeomPolyList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="202">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Haxe Iterator<T> compatible iterator over Nape list.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.geom.GeomPolyList" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/geom/GeomPolyList.hx">
		<fromArray public="1" set="method" line="304" static="1">
			<f a="array">
				<c path="Array"><c path="nape.geom.GeomPoly"/></c>
				<c path="nape.geom.GeomPolyList"/>
			</f>
			<haxe_doc>* Convert standard Array to Nape list.
     *
     * @param array The array to be converted
     * @return An equivalent Nape list.
     * @throws If array argument is null.
     * @throws If array contains elements of type other than GeomPoly</haxe_doc>
		</fromArray>
		<filter public="1" set="method" line="779">
			<f a="lambda">
				<f a="">
					<c path="nape.geom.GeomPoly"/>
					<x path="Bool"/>
				</f>
				<c path="nape.geom.GeomPolyList"/>
			</f>
			<haxe_doc><![CDATA[* Iterate over list filtering elements.
     * <br/><br/>
     * The given function will be applied to each element, whenever the
     * function returns false, the element will be removed from the list.
     * <br/><br/>
     * Any exception thrown by the supplied function will be treat as a
     * signal to halt iteration acting as a 'break' statement.
     * <br/><br/>
     * This method is to be greatly preferred for filtering logic as
     * it is otherwise unsafe to modify the list during an iteration.
     * <br/><br/>
     * An example of using this method to clean up a list whilst performing
     * actions on the elements.
     * <pre>
     * list.filter(function (obj) {
     *    // perform clean up with obj
     *    return false; // remove from list.
     * });
     * </pre>
     *
     * @param lambda The function to apply to each argument, deciding if
     *               element should be removed.
     * @return A reference to 'this' list.
     * @throws # If lambda argument is null.]]></haxe_doc>
		</filter>
		<foreach public="1" get="inline" set="null" line="732">
			<f a="lambda">
				<f a="">
					<c path="nape.geom.GeomPoly"/>
					<x path="Void"/>
				</f>
				<c path="nape.geom.GeomPolyList"/>
			</f>
			<haxe_doc><![CDATA[* Iterate over list applying function.
     * <br/><br/>
     * Any exception thrown by the supplied function will be treat as a
     * signal to halt iteration acting as a 'break' statement.
     * <br/><br/>
     * This method should be preferred to using standard haxe iteration
     * as there will be no allocation of an iterator object.
     * <pre>
     * list.foreach(function (obj) {
     *     if (ignore_object(obj)) return; //acts as a 'continue' statement
     *     if (halt_iteration(obj)) throw "": //acts as a 'break' statement
     * });
     * </pre>
     *
     * @param lambda The function to apply to each argument.
     * @return A reference to 'this' list.
     * @throws # If lambda argument is null.]]></haxe_doc>
		</foreach>
		<toString public="1" set="method" line="702">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<merge public="1" set="method" line="684">
			<f a="xs">
				<c path="nape.geom.GeomPolyList"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Merge given list into this one.
     * <br/><br/>
     * The result is that this list will have all objects from the argument
     * that were not already in the list inserted. You should make no
     * assumption about the order of these insertions.
     *
     * @param xs The list to merge.
     * @throws # If xs argument is null.]]></haxe_doc>
		</merge>
		<copy public="1" set="method" line="662">
			<f a="?deep">
				<x path="Bool"/>
				<c path="nape.geom.GeomPolyList"/>
			</f>
			<haxe_doc>* Produce a possibly deep copy of list.
     *
     * @param deep If true, then each element will have its own copy
     *             function called instead of simply having its
     *             reference copied over.
     * @return     The copied list.</haxe_doc>
		</copy>
		<iterator public="1" get="inline" set="null" line="647">
			<f a=""><c path="nape.geom.GeomPolyIterator"/></f>
			<haxe_doc><![CDATA[* Return Haxe iterator for list.
     * <br/><br/>
     * Use of this iterator, whilst stylistically better in Haxe should not
     * be used, in preference for use of the foreach function which will
     * not require allocation of an iterator object.
     * <br/><br/>
     * Equally in AS3, the foreach method should be the preferred way to iterate.]]></haxe_doc>
		</iterator>
		<empty public="1" get="inline" set="null" line="631">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Test if list is empty or not.
     *
     * @return True if list is empty.</haxe_doc>
		</empty>
		<clear public="1" set="method" line="614">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clear the list, removing all elements.
     *
     * @throws # If list is iummutable</haxe_doc>
		</clear>
		<remove public="1" set="method" line="576">
			<f a="obj">
				<c path="nape.geom.GeomPoly"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Remove element from list.
     * <br/><br/>
     * This is a linear time operation.
     *
     * @param obj The object to remove
     * @return True if object was removed from list.
     * @throws # If list is immutable]]></haxe_doc>
		</remove>
		<add public="1" get="inline" set="null" line="563">
			<f a="obj">
				<c path="nape.geom.GeomPoly"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Insert element into list in most effecient way.
     * <br/><br/>
     * This method will defer to either the push or unshift function
     * depending on which is most effecient in the context.
     * <br/><br/>
     * If order of elements is not important then you should always use
     * this function to insert elements.
     *
     * @param obj The object to insert.
     * @return True if object was successfuly inserted.
     * @throws # If list is immutable]]></haxe_doc>
		</add>
		<shift public="1" set="method" line="519">
			<f a=""><c path="nape.geom.GeomPoly"/></f>
			<haxe_doc><![CDATA[* Pop element from front of list.
     * <br/><br/>
     * If you are wanting to clear a list, whilst operating on its elements,
     * consider use of the filter method instead.
     *
     * @returns The element removed from list.
     * @throws # If list is immutable.
     * @throws # If the list is empty.]]></haxe_doc>
		</shift>
		<pop public="1" set="method" line="478">
			<f a=""><c path="nape.geom.GeomPoly"/></f>
			<haxe_doc><![CDATA[* Pop element from back of list.
     * <br/><br/>
     * If you are wanting to clear a list, whilst operating on its elements,
     * consider use of the filter method instead.
     *
     * @returns The element removed from list.
     * @throws # If list is immutable.
     * @throws # If the list is empty.]]></haxe_doc>
		</pop>
		<unshift public="1" set="method" line="447">
			<f a="obj">
				<c path="nape.geom.GeomPoly"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Push element to front of list.
     * <br/><br/>
     * When the order of objects is not important, it is best to use the
     * add() method instead.
     *
     * @param obj The object to insert.
     * @returns True if object was successively inserted.
     * @throws # If list is immutable.]]></haxe_doc>
		</unshift>
		<push public="1" set="method" line="416">
			<f a="obj">
				<c path="nape.geom.GeomPoly"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Push element to back of list.
     * <br/><br/>
     * When the order of objects is not important, it is best to use the
     * add() method instead.
     *
     * @param obj The object to insert.
     * @returns True if object was successively inserted.
     * @throws # If list is immutable.]]></haxe_doc>
		</push>
		<at public="1" set="method" line="363">
			<f a="index">
				<x path="Int"/>
				<c path="nape.geom.GeomPoly"/>
			</f>
			<haxe_doc><![CDATA[* Random access to elements of list by index.
     * <br/><br/>
     * Under normal circumstances, accessing succesive elements via this
     * method will occur in constant time.
     *
     * @param index The index of the element in list to access.
     * @returns The element at the given index.
     * @throws # If index is out of bounds.]]></haxe_doc>
		</at>
		<has public="1" set="method" line="346">
			<f a="obj">
				<c path="nape.geom.GeomPoly"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if element is already in the list
     *
     * @param obj The object to test.
     * @return True if object is in the list.</haxe_doc>
		</has>
		<get_length get="inline" set="null" line="244"><f a=""><x path="Int"/></f></get_length>
		<length public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Length of list.</haxe_doc>
		</length>
		<zpp_inner public="1">
			<c path="zpp_nape.util.ZPP_GeomPolyList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="695">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Construct a new list.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Nape list of GeomPoly type objects
 * <br/><br/>
 * Internally this list is at present implemented as a linked list with
 * object pooled nodes and iterators with various fast paths made for
 * standard access patterns (For instance accessing successive elements
 * runs in constant time when using random access functions)
 * <br/><br/>
 * Iteration of this list can be done in various ways, but the preferred
 * way on all targets, is through use of the foreach function:
 * <pre>
 * list.foreach(function (obj) {
 * });
 * </pre>
 * This method is inlined so that in haxe no closure will need to be created.
 * <br/><br/>
 * In AS3, a closure would need to be created in general, so for performance
 * reasons you 'may' choose to use iteration as follows:
 * <pre>
 * for (var i:int = 0; i < list.length; i++) {
 *     var obj:GeomPoly = list.at(i);
 * }
 * </pre>
 * <br/>
 * NOTE: It is 'not' safe to modify a list whilst iterating over it.
 * If you wish to remove elements during an iteration you should use the
 * filter method, for example:
 * <pre>
 * list.filter(function (obj) {
 *     // operate on object.
 *     // ...
 *     return (false if you want object to be removed);
 * });
 * </pre>
 * <br/><br/>
 * In AS3, if you wish to avoid a closure generation, you can perform such
 * an iteration in a safe manner as follows:
 * <pre>
 * var i:int = 0;
 * while (i < list.length) {
 *     var obj:GeomPoly = list.at(i);
 *     // operate on object.
 *     // ...
 *     if (should remove obj) {
 *         list.remove(obj);
 *         continue;
 *     }
 *     else i++;
 * }
 * </pre>
 * Or if you are always clearing the list entirely you could write:
 * <pre>
 * while (!list.empty()) {
 *     var obj:GeomPoly = list.pop();
 *     // operate on object.
 *     // ...
 * }
 * </pre>]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.geom.GeomVertexIterator" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/geom/GeomVertexIterator.hx">
		<next public="1" set="method" line="237">
			<f a=""><c path="nape.geom.Vec2"/></f>
			<haxe_doc><![CDATA[* Return next vertex in list.
     * <br/><br/>
     * The vertex is represented by an intrinsically linked Vec2
     * unique to that vertex, which cannot be diposed of.
     *
     * @return The next vertex in iteration.]]></haxe_doc>
		</next>
		<hasNext public="1" set="method" line="200">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Check if there are any vertices remaining.
     *
     * @return True if there are more vertices to iterate over.</haxe_doc>
		</hasNext>
		<zpp_inner public="1">
			<c path="zpp_nape.geom.ZPP_GeomVertexIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="188">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Haxe compatible iterator over vertices of GeomPoly.
 * <br/><br/>
 * Vec2's intrinsically tied to the vertices are exposed through
 * the iterator which does not modify the state of the polygon.]]></haxe_doc>
	</class>
	<typedef path="nape.geom.IsoFunctionDef" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/geom/IsoFunction.hx" module="nape.geom.IsoFunction">
		<f a=":">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<haxe_doc><![CDATA[* For 'flash' targets only.
 * <br/><br/>
 * Iso-functions for MarchingSquares must be given
 * as an object implementing this IsoFunction interface. This is for
 * reasons of avoiding excessive memory allocations that occur through
 * automatic boxing of arguments/return values when using function values.
 * <br/>
 * Since iso-functions may be called 10,000's of times per-invocation of
 * marching-squares, this can quickly accumulate into a lot of GC activity.]]></haxe_doc>
	</typedef>
	<class path="nape.geom.MarchingSquares" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/geom/MarchingSquares.hx">
		<run public="1" set="method" line="269" static="1">
			<f a="iso:bounds:cellsize:?quality:?subgrid:?combine:?output">
				<t path="nape.geom.IsoFunctionDef"/>
				<c path="nape.geom.AABB"/>
				<c path="nape.geom.Vec2"/>
				<x path="Int"/>
				<c path="nape.geom.Vec2"/>
				<x path="Bool"/>
				<c path="nape.geom.GeomPolyList"/>
				<c path="nape.geom.GeomPolyList"/>
			</f>
			<haxe_doc><![CDATA[* Execute marching squares algorithm over region of space.
     * <br/><br/>
     * We can, optionally provide a subgrid argument which, when non null
     * will invoke this algorithm seperately on each subgrid cell of the region
     * in space, instead of on the entire region at once. This can be very useful
     * as shown in the DestructibleTerrain demo where regions of a terrain are
     * recomputed with marching squares without needing to regenerate the whole
     * of the terrain.
     *
     * @param iso The iso-function defining the regions where polygons should
     *            be extracted, a negative return indicates a region to be extracted.
     *            This function need not be continuous, but if it is continuous
     *            then more accurate results will be given for the same input
     *            parameters.
     * @param bounds The AABB representing the region of space to be converted.
     *               The arguments to the iso-function will be in the same region.
     * @param cellsize The dimensions of each cell used individual polygon extraction.
     *                 Smaller cells will give more accurate results at a greater
     *                 cost permitting smaller features to be extracted.
     * @param quality This is the number of recursive interpolations which will be
     *                performed along cell edges. If the iso-function is not
     *                continuous, then this value should be increased to get better
     *                accuracy. (default 2)
     * @param subgrid When supplied, the region of space will be first subdivided
     *                into cells with these given dimensions, and each cell treated
     *                as a seperate invocation of this method, this value should
     *                obviously be greater than cellsize or it would be a bit
     *                pointless. (default null)
     * @param combine When True, the polygons generated in each cell of the grid
     *                will be combined into the largest possible weakly-simple
     *                polygons representing the same area. These polygons will
     *                always be suitable for decomposition in Nape. (default true)
     * @param output When supplied, GeomPoly will be inserted into the list (via add)
     *               instead of creating a new GeomPolyList object.
     * @return A list of GeomPoly representing the results of the extraction.
     * @throws # If iso, bounds or cellsize argument is null.
     * @throws # If cellsize is disposed, or its components have 0, or negative values.
     * @throws # If quality is less than 0.
     * @throws # If subgrid is not null, but is disposed or has zero or negative
     *           component values.]]></haxe_doc>
		</run>
		<haxe_doc><![CDATA[* Iso-surface extraction into polygons.
 * <br/><br/>
 * This class, with only one static method provides an interface to
 * an algorithm which will, when given a function mapping each point
 * in a given AABB to a scalar value extract approximated polygons
 * which represent the region of the AABB where the function returns
 * a negative value.
 * <br/><br/>
 * This function could be a mathematical function like the equation of
 * a circle: <code> function (x, y) return (x*x + y*y) - r*r </code>
 * <br/>
 * Or something more practical like the biased alpha value interpolated
 * from a Bitmap:
 * <pre>
 * function (x, y) {
 *    var ix = if (x < 0) 0 else if (x >= bitmap.width - 1) bitmap.width - 2 else Std.int(x);
 *    var iy = if (y < 0) 0 else if (y >= bitmap.height - 1) bitmap.height - 2 else Std.int(y);
 *    var fx = x - ix;
 *    var fy = y - iy;
 *    var gx = 1 - fx;
 *    var gy = 1 - fy;
 *
 *    var a00 = bitmap.getPixel32(ix, iy) >>> 24;
 *    var a01 = bitmap.getPixel32(ix, iy + 1) >>> 24;
 *    var a10 = bitmap.getPixel32(ix + 1, iy) >>> 24;
 *    var a11 = bitmap.getPixel32(ix + 1, iy + 1) >>> 24;
 *
 *    return 0x80 - (gx*gy*a00 + fx*gy*a10 + gx*fy*a01 + fx*fy*a11);
 * }
 * </pre>
 * For 'flash', we must wrap this in an IsoFunction interface to be used
 * by MarchingSquares for performance reasons:
 * <pre>
 * class BitmapIsoFunction implements nape.geom.IsoFunction {
 *     public function iso(x:Float, y:Float):Float {
 *         ...
 *     }
 * }
 * </pre>
 * This function is converted into a set of polygons by sampling along regular
 * grid points, and then recursively interpolating along cell edges based on
 * the function provided to find the point in space along that edge where the
 * function is approximately 0.
 * <br/><br/>
 * From this we generate polygons in each grid cell, which are then by default
 * combined into larger, weakly simply polygons suitable for use in the
 * decomposition routines of GeomPoly like convexDecomposition!
 * <br/><br/>
 * The runtime of the algorithm is O(N+K) for N number of cells and K number
 * of output vertices (A final pass is made to remove unnecessary vertices).]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.geom.Mat23" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/geom/Mat23.hx">
		<rotation public="1" set="method" line="490" static="1">
			<f a="angle">
				<x path="Float"/>
				<c path="nape.geom.Mat23"/>
			</f>
			<haxe_doc><![CDATA[* Construct a Mat23 representing a clockwise rotation.
     *
     * <pre>
     * [ cos angle  -sin angle  0 ]
     * [ sin angle   cos angle  0 ]
     * </pre>
     *
     * @param angle The clockwise rotation in radians
     * @return      The rotation matrix.]]></haxe_doc>
		</rotation>
		<translation public="1" set="method" line="513" static="1">
			<f a="tx:ty">
				<x path="Float"/>
				<x path="Float"/>
				<c path="nape.geom.Mat23"/>
			</f>
			<haxe_doc><![CDATA[* Construct a Mat23 representing a translation
     *
     * <pre>
     * [ 1  0  tx ]
     * [ 0  1  ty ]
     * </pre>
     *
     * @param tx The x translation.
     * @param ty The y translation.
     * @return   The translation matrix.]]></haxe_doc>
		</translation>
		<scale public="1" set="method" line="529" static="1">
			<f a="sx:sy">
				<x path="Float"/>
				<x path="Float"/>
				<c path="nape.geom.Mat23"/>
			</f>
			<haxe_doc><![CDATA[* Construct a Mat23 representing a scaling
     *
     * <pre>
     * [ sx  0  0 ]
     * [ 0  sy  0 ]
     * </pre>
     *
     * @param sx The x factor of scaling.
     * @param sy The y factor of scaling.
     * @return   The scaling matrix.]]></haxe_doc>
		</scale>
		<orthogonalise public="1" set="method" line="862">
			<f a=""><c path="nape.geom.Mat23"/></f>
			<haxe_doc><![CDATA[* Orthogonalise matrix.
     * <br/><br/>
     * We do this by finding the 'nearest' orthogonal matrix;
     * normalising the basis vectors of matrix
     * and applying an equal and opposite rotation to each basis vector to
     * make them perpendicular.
     *
     * @return A reference to this Mat23.
     * @throws # If matrix is singular.]]></haxe_doc>
		</orthogonalise>
		<equiorthogonalise public="1" set="method" line="817">
			<f a=""><c path="nape.geom.Mat23"/></f>
			<haxe_doc><![CDATA[* Equiorthogonalise matrix.
     * <br/><br/>
     * We do this by finding the 'nearest' orthogonal matrix;
     * scaling the basis vectors of matrix to their mean length
     * and applying an equal and opposite rotation to each basis vector to
     * make them perpendicular.
     *
     * @return A reference to this Mat23.
     * @throws # If matrix is singular.]]></haxe_doc>
		</equiorthogonalise>
		<orthogonal public="1" set="method" line="794">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[* Determine if matrix is orthogonal
     * <br/><br/>
     * This property describes a matrix
     * which maps circles into other circles of equal radius. In otherwords
     * the matrix can be decomposed into a rotation and a translation.
     * <br/><br/>
     * Mathematically speaking a matrix is orthogonal iff.
     * <code>transpose(M) * M = I</code>.
     *
     * @return True if matrix is orthogonal.]]></haxe_doc>
		</orthogonal>
		<equiorthogonal public="1" set="method" line="766">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[* Determine if matrix is equiorthogonal
     * <br/><br/>
     * This is a term I invented after
     * failing to find an existing name. It describes that this matrix maps
     * circles into other circles (of not necessarigly the same radius). In
     * otherwords the matrix can be decomposed into a rotation, translation
     * and scaling of equal x/y factors.
     * <br/><br/>
     * This property is required for any Mat23 that is used to transform a
     * Circle, or any Body containing a Circle, or to transform a Debug view.
     * <br/><br/>
     * This is a weaker property than orthogonality which describes a mapping
     * to a circle of equal radius.
     * <br/><br/>
     * Mathematically speaking a matrix is equiorthogonal iff.
     * <code>transpose(M) * M = kI</code> for some non-zero scalar k.
     *
     * @return True if matrix is equiorthogonal.]]></haxe_doc>
		</equiorthogonal>
		<toString public="1" set="method" line="742">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<inverseTransform public="1" set="method" line="702">
			<f a="point:?noTranslation:?weak">
				<c path="nape.geom.Vec2"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="nape.geom.Vec2"/>
			</f>
			<haxe_doc><![CDATA[* Perform inverse transformation with Vec2, returning new Vec2.
     * <br/><br/>
     * The matrix inverse will be performed implicitly and should this
     * method be called many times for the same Mat23, it would be better
     * to instead compute the matrix inverse only once.
     * <br/><br/>
     * The new Vec2 will be allocated from the global object pool.
     *
     * @param point         The Vec2 to transform.
     * @param noTranslation If true then the input Vec2 will be treat as a
     *                      vector instead of a point, treating the tx/ty
     *                      values of this Mat23 as though they were 0.
     *                      (default false)
     * @param weak          If true, then the allocated Vec2 will be
     *                      automatically released to global object pool when
     *                      used as an argument to a Nape function.
     * @return              The result of the transformation as a newly
     *                      allocated (possibly weak) Vec2. (default false)
     * @throws # If matrix is singular.
     * @throws # If point argument is null.]]></haxe_doc>
		</inverseTransform>
		<transform public="1" set="method" line="648">
			<f a="point:?noTranslation:?weak">
				<c path="nape.geom.Vec2"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="nape.geom.Vec2"/>
			</f>
			<haxe_doc><![CDATA[* Transform a Vec2 by this matrix in new Vec2.
     * <br/><br/>
     * The Vec2 object will be allocated form the global object pool.
     *
     * @param point         The Vec2 to transform by this matrix.
     * @param noTranslation If true, then the input Vec2 will be treat as a
     *                      vector, rather than a point with the tx/ty values
     *                      treat as 0. (default false)
     * @param weak          If true, then the allocated Vec2 will be
     *                      automatically released to global object pool when
     *                      used as an argument to a Nape function.
     * @return              The result of the transformation as a newly
     *                      allocated (possibly weak) Vec2. (default false)
     * @throws # If point argument is null.]]></haxe_doc>
		</transform>
		<concat public="1" set="method" line="622">
			<f a="matrix">
				<c path="nape.geom.Mat23"/>
				<c path="nape.geom.Mat23"/>
			</f>
			<haxe_doc><![CDATA[* Concatenate matrices (left-multiplication), returning new Mat23.
     * <br/><br/>
     * <code>mat1.concat(mat2)</code> is the transformation that first
     * performs transformation represented by mat1, followed by transformation
     * represented by mat2.
     * <br/>
     *
     * @param matrix Matrix to concatenate with.
     * @return       The result of the concatenation.
     * @throws # If matrix argument is null.]]></haxe_doc>
		</concat>
		<transpose public="1" set="method" line="606">
			<f a=""><c path="nape.geom.Mat23"/></f>
			<haxe_doc><![CDATA[* Compute the transpose of this matrix, returning the transpose in a new
     * Mat23 object.
     * <br/><br/>
     * Technically speaking, we cannot transpose a matrix if the tx/ty values
     * are non-zero as the implicit bottom row of matrix must be (0, 0, 1)
     * so the tx/ty values of output matrix are set so that should the main
     * 2x2 block of the matrix be orthogonal (Representing a rotation), then
     * the transpose will be able to act as the matrix inverse.
     * <pre>
     * var mat = Mat23.rotation(..).concat(Mat23.translation(...));
     * trace(mat.concat(mat.transpose())); // Identity matrix
     * trace(mat.concat(mat.inverse())); // Identity matrix
     * </pre>
     * If the main 2x2 block of matrix is 'not' orthogonal, then the transpose
     * will not be equal to the inverse.
     *
     * @return The transposed matrix.]]></haxe_doc>
		</transpose>
		<inverse public="1" set="method" line="577">
			<f a=""><c path="nape.geom.Mat23"/></f>
			<haxe_doc><![CDATA[* Compute the inverse of this matrix, returning the inverse in a new
     * Mat23 object.
     * <br/><br/>
     * The inverse is such that mat.concat(mat.inverse()) is the identity
     * matrix, as well as mat.inverse().concat(mat)
     *
     * @return The inverse matrix.
     * @throws # If matrix is singular.]]></haxe_doc>
		</inverse>
		<singular public="1" set="method" line="560">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[* Determine if the matrix is singular.
     * This check is based on computing the condition number of the matrix
     * by the Frobenius norm, and comparing against 2 / epsilon.
     * <br/><br/>
     * If matrix is singular, then inversion of the matrix cannot be performed
     *
     * @return True, if matrix is singular.]]></haxe_doc>
		</singular>
		<get_determinant get="inline" set="null" line="547"><f a=""><x path="Float"/></f></get_determinant>
		<determinant public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc><![CDATA[* (readonly) The determinant of this matrix.
     * <br/><br/>
     * This represents the factor of change in area
     * for a region of the plane after transformation by matrix.
     * <br/><br/>
     * A determinant of 0 signifies that the matrix is not invertible.
     * <br/><br/>
     * A negative determinant signifies that for example, a clockwise wound
     * polygon would be transformed into a counter-clockwise polygon.
     *
     * @default 1]]></haxe_doc>
		</determinant>
		<reset public="1" get="inline" set="null" line="433">
			<f a=""><c path="nape.geom.Mat23"/></f>
			<haxe_doc><![CDATA[* Reset matrix to identity.
     * <br/><br/>
     * Equivalent to calling setAs with default argument values.
     * <br/><br/>
     * @return A reference to this Mat23.]]></haxe_doc>
		</reset>
		<setAs public="1" set="method" line="420">
			<f a="?a:?b:?c:?d:?tx:?ty">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="nape.geom.Mat23"/>
			</f>
			<haxe_doc><![CDATA[* Set values of matrix from numbers.
     * <br/><br/>
     * So that: <code>mat.setAs(...)</code> is
     * semantically equivalent to: <code>mat.set(new Mat23(...))</code>
     * <br/><br/>
     * @param a  The value to which the (1,1) entry will be set (default 1)
     * @param b  The value to which the (1,2) entry will be set (default 0)
     * @param c  The value to which the (2,1) entry will be set (default 0)
     * @param d  The value to which the (2,2) entry will be set (default 1)
     * @param tx The value to which the (1,3) entry will be set (default 0)
     * @param ty The value to which the (2,3) entry will be set (default 0)
     * @return   A reference to this Mat23.]]></haxe_doc>
		</setAs>
		<set public="1" set="method" line="396">
			<f a="matrix">
				<c path="nape.geom.Mat23"/>
				<c path="nape.geom.Mat23"/>
			</f>
			<haxe_doc>* Set values of matrix from another.
     *
     * @param matrix The matrix to copy values from.
     * @return       A reference to this Mat23.
     * @throws # if matrix argument is null.</haxe_doc>
		</set>
		<copy public="1" set="method" line="386">
			<f a=""><c path="nape.geom.Mat23"/></f>
			<haxe_doc>* Produce copy of this Mat23
     *
     * @return The new Mat23 representing copy of this.</haxe_doc>
		</copy>
		<set_ty get="inline" set="null" line="342"><f a="ty">
	<x path="Float"/>
	<x path="Float"/>
</f></set_ty>
		<get_ty get="inline" set="null" line="339"><f a=""><x path="Float"/></f></get_ty>
		<ty public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The (2,3) entry in Mat23 which represents y translation
     * <br/><br/>
     * <pre>
     * [ .  .  .  ]
     * [ .  .  ty ]
     * </pre>
     *
     * @default 0]]></haxe_doc>
		</ty>
		<set_tx get="inline" set="null" line="315"><f a="tx">
	<x path="Float"/>
	<x path="Float"/>
</f></set_tx>
		<get_tx get="inline" set="null" line="312"><f a=""><x path="Float"/></f></get_tx>
		<tx public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The (1,3) entry in Mat23 which represents x translation
     * <br/><br/>
     * <pre>
     * [ .  .  tx ]
     * [ .  .  .  ]
     * </pre>
     *
     * @default 0]]></haxe_doc>
		</tx>
		<set_d get="inline" set="null" line="288"><f a="d">
	<x path="Float"/>
	<x path="Float"/>
</f></set_d>
		<get_d get="inline" set="null" line="285"><f a=""><x path="Float"/></f></get_d>
		<d public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The (2,2) entry in Mat23:
     * <br/><br/>
     * <pre>
     * [ .  .  . ]
     * [ .  d  . ]
     * </pre>
     *
     * @default 1]]></haxe_doc>
		</d>
		<set_c get="inline" set="null" line="261"><f a="c">
	<x path="Float"/>
	<x path="Float"/>
</f></set_c>
		<get_c get="inline" set="null" line="258"><f a=""><x path="Float"/></f></get_c>
		<c public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The (2,1) entry in Mat23:
     * <br/><br/>
     * <pre>
     * [ .  .  . ]
     * [ c  .  . ]
     * </pre>
     *
     * @default 0]]></haxe_doc>
		</c>
		<set_b get="inline" set="null" line="234"><f a="b">
	<x path="Float"/>
	<x path="Float"/>
</f></set_b>
		<get_b get="inline" set="null" line="231"><f a=""><x path="Float"/></f></get_b>
		<b public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The (1,2) entry in Mat23:
     * <br/><br/>
     * <pre>
     * [ .  b  . ]
     * [ .  .  . ]
     * </pre>
     *
     * @default 0]]></haxe_doc>
		</b>
		<set_a get="inline" set="null" line="207"><f a="a">
	<x path="Float"/>
	<x path="Float"/>
</f></set_a>
		<get_a get="inline" set="null" line="204"><f a=""><x path="Float"/></f></get_a>
		<a public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The (1,1) entry in Mat23:
     * <br/><br/>
     * <pre>
     * [ a  .  . ]
     * [ .  .  . ]
     * </pre>
     *
     * @default 1]]></haxe_doc>
		</a>
		<zpp_inner public="1">
			<c path="zpp_nape.geom.ZPP_Mat23"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="370">
			<f a="?a:?b:?c:?d:?tx:?ty">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Construct new Mat23.
     * <br/><br/>
     * <pre>
     * [ a  b  tx ]
     * [ c  d  ty ]
     * </pre>
     *
     * @param a  The (1,1) entry in matrix (default 1)
     * @param b  The (1,2) entry in matrix (default 0)
     * @param c  The (2,1) entry in matrix (default 0)
     * @param d  The (2,2) entry in matrix (default 1)
     * @param tx The (1,3) entry in matrix (default 0)
     * @param ty The (2,3) entry in matrix (default 0)
     * @return   The newly constructed Mat23.]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* 2D Matrix class representing affine transformations:
 * <pre>
 * [ a  b  tx ]
 * [ c  d  ty ]
 * [ 0  0  1  ]
 * </pre>
 *
 * Note that in AS3, flash.geom.Matrix has 'b' and 'c' swapped! so if you are
 * converting between flash.geom.Matrix and nape.geom.Mat23 you should use the
 * methods provided to avoid any mistakes with this.
 *]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.geom.MatMN" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/geom/MatMN.hx">
		<mul public="1" set="method" line="294">
			<f a="matrix">
				<c path="nape.geom.MatMN"/>
				<c path="nape.geom.MatMN"/>
			</f>
			<haxe_doc><![CDATA[* Multiple this matrix with another.
     * <br/><br/>
     * This operation is only valid if the number of columns
     * in this matrix, is equal to the number of rows in the input
     * matrix.
     * <br/>
     * The result of the multiplication is returned as a new matrix.
     *
     * @param matrix The matrix to multiple with.
     * @return The result of the multiplication
     * @throws If matrix dimensions are not compatible.]]></haxe_doc>
		</mul>
		<transpose public="1" set="method" line="274">
			<f a=""><c path="nape.geom.MatMN"/></f>
			<haxe_doc>* Transpose matrix, returning a new Matrix.
     *
     * @return The transposed matrix.</haxe_doc>
		</transpose>
		<toString public="1" set="method" line="258">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<setx public="1" get="inline" set="null" line="228">
			<f a="row:col:x">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Set element at index.
     *
     * @param row The row of the matrix to set.
     * @param col The column of the matrix to set.
     * @param x The value to set at given (row,col) index.
     * @return The value of matrix at given index after set. (Always
     *         equal to the x parameter)
     * @throws # If index is out of range.</haxe_doc>
		</setx>
		<x public="1" get="inline" set="null" line="209">
			<f a="row:col">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Access element at index.
     *
     * @param row The row of the matrix to access.
     * @param col the column of the matrix to access.
     * @return The element at given (row,col) index.
     * @throws # If access is out of range.</haxe_doc>
		</x>
		<get_cols get="inline" set="null" line="197"><f a=""><x path="Int"/></f></get_cols>
		<cols public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* The number of columns in the matrix.</haxe_doc>
		</cols>
		<get_rows get="inline" set="null" line="189"><f a=""><x path="Int"/></f></get_rows>
		<rows public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* The number of rows in the matrix.</haxe_doc>
		</rows>
		<zpp_inner public="1">
			<c path="zpp_nape.geom.ZPP_MatMN"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="246">
			<f a="rows:cols">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Construct a new Matrix.
     *
     * @param rows The number of rows in matrix.
     * @param cols The number of columns in matrix.
     * @return The constructed Matrix.
     * @throws # If rows or columns is negative or 0.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* A general MxN dimensional matrix.
 * <br/><br/>
 * This object is not often used in Nape :)]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.geom.Ray" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/geom/Ray.hx">
		<fromSegment public="1" set="method" line="370" static="1">
			<f a="start:end">
				<c path="nape.geom.Vec2"/>
				<c path="nape.geom.Vec2"/>
				<c path="nape.geom.Ray"/>
			</f>
			<haxe_doc><![CDATA[* Create ray representing a line segment.
     * <br/><br/>
     * This function will a ray who's origin is the start point
     * and who's direction is towards the end point with the
     * maxDistance property appropriately set to not extend
     * beyond the end point.
     *
     * @param start Start point of line segment
     * @param end End point of line segment
     * @return A Ray representing this line segment.
     * @throws # If start or end are either null or disposed of.
     * @throws # If start and end point are equal so that the
     *         direction of the ray would be degenerate.]]></haxe_doc>
		</fromSegment>
		<copy public="1" set="method" line="350">
			<f a=""><c path="nape.geom.Ray"/></f>
			<haxe_doc><![CDATA[* Produce a copy of this ray.
     * <br/><br/>
     * All ray properties will be copied including maxDistance.
     *
     * @return The copy of this Ray.]]></haxe_doc>
		</copy>
		<at public="1" set="method" line="313">
			<f a="distance:?weak">
				<x path="Float"/>
				<x path="Bool"/>
				<c path="nape.geom.Vec2"/>
			</f>
			<haxe_doc><![CDATA[* Compute point along ray at given distance.
     * <br/><br/>
     * Even if ray direction is not normalised, this value still repersents
     * a true distance. The distance may also be negative.
     * <br/><br/>
     * The Vec2 returned will be allocated from the global object pool.
     *
     * @param distance The distance along ray to compute point for.
     * @param weak If true then a weakly allocated Vec2 will be returned
     *             which will be automatically released to global object
     *             pool when used as argument to another Nape function.
     *             (default false)
     * @return Vec2 representing point at given distance along ray.]]></haxe_doc>
		</at>
		<aabb public="1" set="method" line="295">
			<f a=""><c path="nape.geom.AABB"/></f>
			<haxe_doc><![CDATA[* Compute bounding box of ray.
     * <br/><br/>
     * This function will take into account the maxDistance property of this ray.
     * <br/>
     * The return AABB may have in the general case infinite values :)
     *
     * @return An AABB representing bounding box of ray.]]></haxe_doc>
		</aabb>
		<set_maxDistance get="inline" set="null" line="275"><f a="maxDistance">
	<x path="Float"/>
	<x path="Float"/>
</f></set_maxDistance>
		<get_maxDistance get="inline" set="null" line="272"><f a=""><x path="Float"/></f></get_maxDistance>
		<maxDistance public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The maximum distance for ray to be queried.
     * <br/><br/>
     * When used in ray test functions, no search will extend beyond this
     * distance.
     * <br/><br/>
     * This value represents a true distance, even if direction vector is
     * not normalised. This value may be equal to infinity.
     *
     * @default infinity]]></haxe_doc>
		</maxDistance>
		<set_direction get="inline" set="null" line="242"><f a="direction">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_direction>
		<get_direction get="inline" set="null" line="239"><f a=""><c path="nape.geom.Vec2"/></f></get_direction>
		<direction public="1" get="accessor" set="accessor">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* Direction of ray.
     * <br/><br/>
     * This property can be set, and is equivalent to performing:
     * <code>ray.direction.set(newDirection)</code> with the additional
     * constraint that the input direction must not be degenerate.
     * <br/><br/>
     * This direction vector need not be normalised.]]></haxe_doc>
		</direction>
		<set_origin get="inline" set="null" line="212"><f a="origin">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_origin>
		<get_origin get="inline" set="null" line="209"><f a=""><c path="nape.geom.Vec2"/></f></get_origin>
		<origin public="1" get="accessor" set="accessor">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* Origin of ray.
     * <br/><br/>
     * This property can be set, and is equivalent to performing:
     * <code>ray.origin.set(newOrigin)</code>]]></haxe_doc>
		</origin>
		<get_userData get="inline" set="null" line="195"><f a=""><d><d/></d></f></get_userData>
		<userData public="1" get="accessor" set="null">
			<d><d/></d>
			<haxe_doc><![CDATA[* Dynamic object for user to store additional data.
     * <br/><br/>
     * This object cannot be set, only its dynamically created
     * properties may be set. In AS3 the type of this property is &#42
     * <br/><br/>
     * This object will be lazily constructed so that until accessed
     * for the first time, will be null internally.
     *
     * @default {}]]></haxe_doc>
		</userData>
		<zpp_inner public="1">
			<c path="zpp_nape.geom.ZPP_Ray"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="327">
			<f a="origin:direction">
				<c path="nape.geom.Vec2"/>
				<c path="nape.geom.Vec2"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Construct new Ray.
     *
     * @param origin Origin of ray.
     * @param direction Direction of ray.
     * @throws # If origin or direction are null, or disposed of.
     * @throws # If direction is degenerate.</haxe_doc>
		</new>
		<haxe_doc>* Parametrically defined ray used in ray casting functions.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.geom.RayResult" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/geom/RayResult.hx">
		<toString public="1" set="method" line="252">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<dispose public="1" get="inline" set="null" line="243">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Release RayResult object to pool.</haxe_doc>
		</dispose>
		<get_shape get="inline" set="null" line="223"><f a=""><c path="nape.shape.Shape"/></f></get_shape>
		<shape public="1" get="accessor" set="null">
			<c path="nape.shape.Shape"/>
			<haxe_doc>* The shape which was intersected.</haxe_doc>
		</shape>
		<get_inner get="inline" set="null" line="212"><f a=""><x path="Bool"/></f></get_inner>
		<inner public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>* Whether this intersection is with the inner surface of an object.</haxe_doc>
		</inner>
		<get_distance get="inline" set="null" line="201"><f a=""><x path="Float"/></f></get_distance>
		<distance public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* The distance to the intersection.</haxe_doc>
		</distance>
		<get_normal get="inline" set="null" line="190"><f a=""><c path="nape.geom.Vec2"/></f></get_normal>
		<normal public="1" get="accessor" set="null">
			<c path="nape.geom.Vec2"/>
			<haxe_doc>* The normal of the surface at intersection.</haxe_doc>
		</normal>
		<zpp_inner public="1">
			<c path="zpp_nape.geom.ZPP_ConvexRayResult"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="234">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Class representing the results of a ray cast operation.
 * <br/><br/>
 * These objects are allocated from an object pool and can
 * be released back to that pool by calling its dispose method.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.geom.RayResultIterator" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/geom/RayResultIterator.hx">
		<zpp_pool public="1" line="194" static="1">
			<c path="nape.geom.RayResultIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_pool>
		<get public="1" set="method" line="217" static="1">
			<f a="list">
				<c path="nape.geom.RayResultList"/>
				<c path="nape.geom.RayResultIterator"/>
			</f>
			<haxe_doc><![CDATA[* Create iterator for Nape list.
     * <br/><br/>
     * There is no specific reason to use this over: <code>list.iterator()</code>
     * especcialy since this requires writing the class name :)
     * (This function is used internally)
     *
     * @param list The Nape list to create iterator for.
     * @return     An iterator over the Nape list.]]></haxe_doc>
		</get>
		<next public="1" get="inline" set="null" line="264">
			<f a=""><c path="nape.geom.RayResult"/></f>
			<haxe_doc>* Return next element in list.
     *
     * @return The next element in iteration.</haxe_doc>
		</next>
		<hasNext public="1" get="inline" set="null" line="240">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Check if there are any elements remaining.
     *
     * @return True if there are more elements to iterator over.</haxe_doc>
		</hasNext>
		<zpp_next public="1">
			<c path="nape.geom.RayResultIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_next>
		<zpp_critical public="1">
			<x path="Bool"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_critical>
		<zpp_i public="1">
			<x path="Int"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_i>
		<zpp_inner public="1">
			<c path="nape.geom.RayResultList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="202">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Haxe Iterator<T> compatible iterator over Nape list.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.geom.RayResultList" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/geom/RayResultList.hx">
		<fromArray public="1" set="method" line="304" static="1">
			<f a="array">
				<c path="Array"><c path="nape.geom.RayResult"/></c>
				<c path="nape.geom.RayResultList"/>
			</f>
			<haxe_doc>* Convert standard Array to Nape list.
     *
     * @param array The array to be converted
     * @return An equivalent Nape list.
     * @throws If array argument is null.
     * @throws If array contains elements of type other than RayResult</haxe_doc>
		</fromArray>
		<filter public="1" set="method" line="779">
			<f a="lambda">
				<f a="">
					<c path="nape.geom.RayResult"/>
					<x path="Bool"/>
				</f>
				<c path="nape.geom.RayResultList"/>
			</f>
			<haxe_doc><![CDATA[* Iterate over list filtering elements.
     * <br/><br/>
     * The given function will be applied to each element, whenever the
     * function returns false, the element will be removed from the list.
     * <br/><br/>
     * Any exception thrown by the supplied function will be treat as a
     * signal to halt iteration acting as a 'break' statement.
     * <br/><br/>
     * This method is to be greatly preferred for filtering logic as
     * it is otherwise unsafe to modify the list during an iteration.
     * <br/><br/>
     * An example of using this method to clean up a list whilst performing
     * actions on the elements.
     * <pre>
     * list.filter(function (obj) {
     *    // perform clean up with obj
     *    return false; // remove from list.
     * });
     * </pre>
     *
     * @param lambda The function to apply to each argument, deciding if
     *               element should be removed.
     * @return A reference to 'this' list.
     * @throws # If lambda argument is null.]]></haxe_doc>
		</filter>
		<foreach public="1" get="inline" set="null" line="732">
			<f a="lambda">
				<f a="">
					<c path="nape.geom.RayResult"/>
					<x path="Void"/>
				</f>
				<c path="nape.geom.RayResultList"/>
			</f>
			<haxe_doc><![CDATA[* Iterate over list applying function.
     * <br/><br/>
     * Any exception thrown by the supplied function will be treat as a
     * signal to halt iteration acting as a 'break' statement.
     * <br/><br/>
     * This method should be preferred to using standard haxe iteration
     * as there will be no allocation of an iterator object.
     * <pre>
     * list.foreach(function (obj) {
     *     if (ignore_object(obj)) return; //acts as a 'continue' statement
     *     if (halt_iteration(obj)) throw "": //acts as a 'break' statement
     * });
     * </pre>
     *
     * @param lambda The function to apply to each argument.
     * @return A reference to 'this' list.
     * @throws # If lambda argument is null.]]></haxe_doc>
		</foreach>
		<toString public="1" set="method" line="702">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<merge public="1" set="method" line="684">
			<f a="xs">
				<c path="nape.geom.RayResultList"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Merge given list into this one.
     * <br/><br/>
     * The result is that this list will have all objects from the argument
     * that were not already in the list inserted. You should make no
     * assumption about the order of these insertions.
     *
     * @param xs The list to merge.
     * @throws # If xs argument is null.]]></haxe_doc>
		</merge>
		<copy public="1" set="method" line="662">
			<f a="?deep">
				<x path="Bool"/>
				<c path="nape.geom.RayResultList"/>
			</f>
			<haxe_doc>* Produce a possibly deep copy of list.
     *
     * @param deep If true, then each element will have its own copy
     *             function called instead of simply having its
     *             reference copied over.
     * @return     The copied list.</haxe_doc>
		</copy>
		<iterator public="1" get="inline" set="null" line="647">
			<f a=""><c path="nape.geom.RayResultIterator"/></f>
			<haxe_doc><![CDATA[* Return Haxe iterator for list.
     * <br/><br/>
     * Use of this iterator, whilst stylistically better in Haxe should not
     * be used, in preference for use of the foreach function which will
     * not require allocation of an iterator object.
     * <br/><br/>
     * Equally in AS3, the foreach method should be the preferred way to iterate.]]></haxe_doc>
		</iterator>
		<empty public="1" get="inline" set="null" line="631">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Test if list is empty or not.
     *
     * @return True if list is empty.</haxe_doc>
		</empty>
		<clear public="1" set="method" line="614">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clear the list, removing all elements.
     *
     * @throws # If list is iummutable</haxe_doc>
		</clear>
		<remove public="1" set="method" line="576">
			<f a="obj">
				<c path="nape.geom.RayResult"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Remove element from list.
     * <br/><br/>
     * This is a linear time operation.
     *
     * @param obj The object to remove
     * @return True if object was removed from list.
     * @throws # If list is immutable]]></haxe_doc>
		</remove>
		<add public="1" get="inline" set="null" line="563">
			<f a="obj">
				<c path="nape.geom.RayResult"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Insert element into list in most effecient way.
     * <br/><br/>
     * This method will defer to either the push or unshift function
     * depending on which is most effecient in the context.
     * <br/><br/>
     * If order of elements is not important then you should always use
     * this function to insert elements.
     *
     * @param obj The object to insert.
     * @return True if object was successfuly inserted.
     * @throws # If list is immutable]]></haxe_doc>
		</add>
		<shift public="1" set="method" line="519">
			<f a=""><c path="nape.geom.RayResult"/></f>
			<haxe_doc><![CDATA[* Pop element from front of list.
     * <br/><br/>
     * If you are wanting to clear a list, whilst operating on its elements,
     * consider use of the filter method instead.
     *
     * @returns The element removed from list.
     * @throws # If list is immutable.
     * @throws # If the list is empty.]]></haxe_doc>
		</shift>
		<pop public="1" set="method" line="478">
			<f a=""><c path="nape.geom.RayResult"/></f>
			<haxe_doc><![CDATA[* Pop element from back of list.
     * <br/><br/>
     * If you are wanting to clear a list, whilst operating on its elements,
     * consider use of the filter method instead.
     *
     * @returns The element removed from list.
     * @throws # If list is immutable.
     * @throws # If the list is empty.]]></haxe_doc>
		</pop>
		<unshift public="1" set="method" line="447">
			<f a="obj">
				<c path="nape.geom.RayResult"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Push element to front of list.
     * <br/><br/>
     * When the order of objects is not important, it is best to use the
     * add() method instead.
     *
     * @param obj The object to insert.
     * @returns True if object was successively inserted.
     * @throws # If list is immutable.]]></haxe_doc>
		</unshift>
		<push public="1" set="method" line="416">
			<f a="obj">
				<c path="nape.geom.RayResult"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Push element to back of list.
     * <br/><br/>
     * When the order of objects is not important, it is best to use the
     * add() method instead.
     *
     * @param obj The object to insert.
     * @returns True if object was successively inserted.
     * @throws # If list is immutable.]]></haxe_doc>
		</push>
		<at public="1" set="method" line="363">
			<f a="index">
				<x path="Int"/>
				<c path="nape.geom.RayResult"/>
			</f>
			<haxe_doc><![CDATA[* Random access to elements of list by index.
     * <br/><br/>
     * Under normal circumstances, accessing succesive elements via this
     * method will occur in constant time.
     *
     * @param index The index of the element in list to access.
     * @returns The element at the given index.
     * @throws # If index is out of bounds.]]></haxe_doc>
		</at>
		<has public="1" set="method" line="346">
			<f a="obj">
				<c path="nape.geom.RayResult"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if element is already in the list
     *
     * @param obj The object to test.
     * @return True if object is in the list.</haxe_doc>
		</has>
		<get_length get="inline" set="null" line="244"><f a=""><x path="Int"/></f></get_length>
		<length public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Length of list.</haxe_doc>
		</length>
		<zpp_inner public="1">
			<c path="zpp_nape.util.ZPP_RayResultList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="695">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Construct a new list.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Nape list of RayResult type objects
 * <br/><br/>
 * Internally this list is at present implemented as a linked list with
 * object pooled nodes and iterators with various fast paths made for
 * standard access patterns (For instance accessing successive elements
 * runs in constant time when using random access functions)
 * <br/><br/>
 * Iteration of this list can be done in various ways, but the preferred
 * way on all targets, is through use of the foreach function:
 * <pre>
 * list.foreach(function (obj) {
 * });
 * </pre>
 * This method is inlined so that in haxe no closure will need to be created.
 * <br/><br/>
 * In AS3, a closure would need to be created in general, so for performance
 * reasons you 'may' choose to use iteration as follows:
 * <pre>
 * for (var i:int = 0; i < list.length; i++) {
 *     var obj:RayResult = list.at(i);
 * }
 * </pre>
 * <br/>
 * NOTE: It is 'not' safe to modify a list whilst iterating over it.
 * If you wish to remove elements during an iteration you should use the
 * filter method, for example:
 * <pre>
 * list.filter(function (obj) {
 *     // operate on object.
 *     // ...
 *     return (false if you want object to be removed);
 * });
 * </pre>
 * <br/><br/>
 * In AS3, if you wish to avoid a closure generation, you can perform such
 * an iteration in a safe manner as follows:
 * <pre>
 * var i:int = 0;
 * while (i < list.length) {
 *     var obj:RayResult = list.at(i);
 *     // operate on object.
 *     // ...
 *     if (should remove obj) {
 *         list.remove(obj);
 *         continue;
 *     }
 *     else i++;
 * }
 * </pre>
 * Or if you are always clearing the list entirely you could write:
 * <pre>
 * while (!list.empty()) {
 *     var obj:RayResult = list.pop();
 *     // operate on object.
 *     // ...
 * }
 * </pre>]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.geom.Vec2" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/geom/Vec2.hx">
		<weak public="1" get="inline" set="null" line="256" static="1">
			<f a="?x:?y">
				<x path="Float"/>
				<x path="Float"/>
				<c path="nape.geom.Vec2"/>
			</f>
			<haxe_doc><![CDATA[* Allocate a weak Vec2 from global object pool.
     * <br/><br/>
     * This object which will be automaticaly released back to the object pool
     * when supplied as an argument to a Nape function.
     * <br/><br/>
     * Note that <code>Vec2.weak(x, y)</code> is exactly equivalent to <code>
     * Vec2.get(x, y, true)</code>.
     *
     * @param x The x coordinate for the vector. (default 0)
     * @param y The y coordiante for the vector. (default 0)
     * @return  The allocated weak Vec2 with given x/y values.]]></haxe_doc>
		</weak>
		<get public="1" get="inline" set="null" line="273" static="1">
			<f a="?x:?y:?weak">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="nape.geom.Vec2"/>
			</f>
			<haxe_doc><![CDATA[* Allocates a Vec2 from the global object pool.
     * <br/><br/>
     * Note that <code>Vec2.get(x, y, true)</code> is exactly equivalent to
     * <code>Vec2.weak(x, y)</code> and should be preferred.
     *
     * @param x    The x coordinate for the vector. (default 0)
     * @param y    The y coordinate for the vector. (default 0)
     * @param weak If true, then a weak Vec2 will be allocated which will be
     *             automatically released to object pool when passed as an
     *             argument to a Nape function. (default false)
     * @return     The allocated, possibly weak Vec2 with given x/y values.]]></haxe_doc>
		</get>
		<fromPolar public="1" set="method" line="505" static="1">
			<f a="length:angle:?weak">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="nape.geom.Vec2"/>
			</f>
			<haxe_doc><![CDATA[* Allocate a Vec2 given polar coordinates.
     * <br/><br/>
     * This Vec2 will be allocated from the global object pool.
     * <br/><br/>
     * This method will assign x/y values equal respectively to:
     * <code>length&#42Math.cos(angle)</code>,
     * <code>length&#42Math.sin(angle)</code>
     *
     * @param length The length of the Vec2. This value may be negative.
     * @param angle  The angle of the Vec2 as measured in radians clockwise
     *               from the positive x axis.
     * @param weak   If true, then a weak Vec2 will be allocated which will be
     *               automatically released to the object pool when passed as
     *               an argument to any Nape function. (default false)
     * @return       The possibly weak Vec2 allocated with given polar values.]]></haxe_doc>
		</fromPolar>
		<dsq public="1" get="inline" set="null" line="711" static="1">
			<f a="a:b">
				<c path="nape.geom.Vec2"/>
				<c path="nape.geom.Vec2"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Compute square distance between two points.
     *
     * @param a The first point Vec2.
     * @param b The second point Vec2.
     * @return Squared distance between points.
     * @throws # If a, b are disposed of or null.</haxe_doc>
		</dsq>
		<distance public="1" get="inline" set="null" line="759" static="1">
			<f a="a:b">
				<c path="nape.geom.Vec2"/>
				<c path="nape.geom.Vec2"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Compute distance between two points.
     *
     * @param a The first point Vec2.
     * @param b The second point Vec2.
     * @return Distance between points.
     * @throws # If a, b are disposed of or null.</haxe_doc>
		</distance>
		<toString public="1" set="method" line="1481">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<perp public="1" set="method" line="1470">
			<f a="?weak">
				<x path="Bool"/>
				<c path="nape.geom.Vec2"/>
			</f>
			<haxe_doc><![CDATA[* The right-perpendicular to this vector.
     * <br/><br/>
     * Computes the result of rotating this vector by 90 degrees clockwise
     * returning a newly allocated vector.
     * <br/><br/>
     * This is semantically equivalent to (the less optimal)
     * <code>vec.copy().rotate(Math.PI/2)</code>
     * <br/><br/>
     * The cross and dot product are related like:
     * <code>vec1.cross(vec2) == vec1.perp().dot(vec2)</code>
     * Hence the name 'perp-dot'
     *
     * @param weak If true then the returned vector will be automatically
     *             released to the global object pool when used as an argument
     *             to another Nape function. (default false)
     * @return     The possibly weakly allocated, right-perpendicular to this
     *             vector.
     * @throws # If this vector has been disposed.]]></haxe_doc>
		</perp>
		<cross public="1" set="method" line="1419">
			<f a="vector">
				<c path="nape.geom.Vec2"/>
				<x path="Float"/>
			</f>
			<haxe_doc><![CDATA[* Cross product with another vector.
     * <br/><br/>
     * Also known as the perp-dot product, this operation represents
     * the determinant of the matrix formed by having the 2 columns
     * as the two vectors. This is also the z-value of a 3D cross product
     * if you extend the input vectors with a z-value of 0.
     * <br/><br/>
     * Though not technically a cross-product in the way a 3D cross product
     * is, it shares many mathematical similarities.
     * <br/><br/>
     * If one of the vectors is of length 1. Then the cross product is the
     * length of the projection of the other vector onto the
     * right-perpendicular of the unit vector.
     * <br/><br/>
     * The cross and dot product are related like:
     * <code>vec1.cross(vec2) == vec1.perp().dot(vec2)</code>
     * Hence the name 'perp-dot'
     * <br/><br/>
     * Another useful property is that if the cross-product of two vectors
     * is 0, then the vectors are collinear, if positive then the second
     * vector is 'to the right' of the first vector, and if negative then
     * the second vector is 'to the left' of the first vector.
     *
     * @param vector The vector to compute cross product with.
     * @return       The cross product of this vector and the other.
     * @throws # If this vector, or the vector argument has been disposed.
     * @throws # If the vector passed as argument is null.]]></haxe_doc>
		</cross>
		<dot public="1" set="method" line="1359">
			<f a="vector">
				<c path="nape.geom.Vec2"/>
				<x path="Float"/>
			</f>
			<haxe_doc><![CDATA[* Dot product with another vector.
     * <br/><br/>
     * The dot product is equal to the product of the length of each
     * vector, multiplied by the cosine of the smallest angle between them.
     * <br/><br/>
     * If one of the vectors is of length 1. Then the dot product is the
     * length of the projection of the other vector onto it which may be
     * computed (assuming 'this' is of length 1) like:
     * <code>vec1.mul(vec1.dot(vec2))</code>
     *
     * @param vector The vector to compute dot product with.
     * @return       The dot product of this vector and the other.
     * @throws # If this vector, or the vector argument has been disposed.
     * @throws # If the vector passed as argument is null.]]></haxe_doc>
		</dot>
		<muleq public="1" set="method" line="1328">
			<f a="scalar">
				<x path="Float"/>
				<c path="nape.geom.Vec2"/>
			</f>
			<haxe_doc><![CDATA[* Multiply this vector with a number.
     * <br/><br/>
     * This vector is mutated to be the result of the operation.
     * <br/><br/>
     * Semantically equivalent to (the less optimal)
     * <code>vec.set(vec.mul(scalar))</code>
     *
     * @param scalar The number to multiply this vector with.
     * @return       A reference to this vector.
     * @throws # If this vector has been disposed.
     * @throws # If this vector is immutable.]]></haxe_doc>
		</muleq>
		<subeq public="1" set="method" line="1283">
			<f a="vector">
				<c path="nape.geom.Vec2"/>
				<c path="nape.geom.Vec2"/>
			</f>
			<haxe_doc><![CDATA[* Subtract another vector from this vector.
     * <br/><br/>
     * This vector is mutated to be the result of the operation.
     * <br/><br/>
     * Semantically equivalent to (the less optimal)
     * <code>vec1.set(vec1.sub(vec2))</code>
     *
     * @param vector The vector to subtract from this vector.
     * @return       A reference to this vector.
     * @throws # If this vector, or the vector argument has been disposed.
     * @throws # If this vector is immutable.
     * @throws # If the vector passed as argument is null.]]></haxe_doc>
		</subeq>
		<addeq public="1" set="method" line="1237">
			<f a="vector">
				<c path="nape.geom.Vec2"/>
				<c path="nape.geom.Vec2"/>
			</f>
			<haxe_doc><![CDATA[* Add another vector into this vector.
     * <br/><br/>
     * This vector is mutated to be the result of the operation.
     * <br/><br/>
     * Semantically equivalent to (the less optimal)
     * <code>vec1.set(vec1.add(vec2))</code>
     *
     * @param vector The vector to add into this vector.
     * @return       A reference to this vector.
     * @throws # If this vector, or the vector argument has been disposed.
     * @throws # If this vector is immutable.
     * @throws # If the vector passed as argument is null.]]></haxe_doc>
		</addeq>
		<mul public="1" set="method" line="1209">
			<f a="scalar:?weak">
				<x path="Float"/>
				<x path="Bool"/>
				<c path="nape.geom.Vec2"/>
			</f>
			<haxe_doc><![CDATA[* Multiply this vector with a number.
     * <br/><br/>
     * Returns a newly allocated vector so that this vector is not mutated.
     *
     * @param scalar The number to multiply this vector with.
     * @param weak   If true then the returned vector will be automatically
     *               released to the global object pool when used as an
     *               argument to another Nape function. (default false)
     * @return       The possibly weak vector representing the multiplication
     *               of this vector and the input number.
     * @throws # If this vector has been disposed.]]></haxe_doc>
		</mul>
		<sub public="1" set="method" line="1165">
			<f a="vector:?weak">
				<c path="nape.geom.Vec2"/>
				<x path="Bool"/>
				<c path="nape.geom.Vec2"/>
			</f>
			<haxe_doc><![CDATA[* Subtract another vector from this vector.
     * <br/><br/>
     * Returns a newly allocated vector so that this vector is not mutated.
     *
     * @param vector The vector to subtract from this vector. This value can
     *               not be null
     * @param weak   If true then the returned vector will be automatically
     *               released to the global object pool when used as an
     *               argument to another Nape function. (default false)
     * @return       The possibly weak vector representing the subtraction of
     *               the input vector from this vector.
     * @throws # If this vector, or the vector argument has been disposed.
     * @throws # If the vector passed as argument is null.]]></haxe_doc>
		</sub>
		<addMul public="1" set="method" line="1119">
			<f a="vector:scalar:?weak">
				<c path="nape.geom.Vec2"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="nape.geom.Vec2"/>
			</f>
			<haxe_doc><![CDATA[* Add a multiple of a vector to this vector.
     * <br/><br/>
     * This operation is equivalent to:
     * <pre>
     * this.add(vector.mul(scalar, true));
     * </pre>
     * <br/><br/>
     * Returns a newly allocated vector so that
     * this vector is not modified.
     * <br/><br/>
     * @param vector The vector to add to this vector. This value can not be
     *               null
     * @param scalar The scalar multiplier for the vector being added.
     * @param weak   If true then the returned vector will be automatically
     *               released to the global object pool when used as an
     *               argument to another Nape function. (default false)
     * @return       The possibly weak vector representing the sum of this
     *               and the input vector by scalar multiplier.
     * @throws # If this vector, or the vector argument has been disposed.
     * @throws # If the vector passed as argument is null.]]></haxe_doc>
		</addMul>
		<add public="1" set="method" line="1066">
			<f a="vector:?weak">
				<c path="nape.geom.Vec2"/>
				<x path="Bool"/>
				<c path="nape.geom.Vec2"/>
			</f>
			<haxe_doc><![CDATA[* Add another vector to this vector.
     * <br/><br/>
     * Returns a newly allocated vector so that
     * this vector is not modified.
     * <br/><br/>
     * @param vector The vector to add to this vector. This value can not be
     *               null
     * @param weak   If true then the returned vector will be automatically
     *               released to the global object pool when used as an
     *               argument to another Nape function. (default false)
     * @return       The possibly weak vector representing the sum of this
     *               and the input vector.
     * @throws # If this vector, or the vector argument has been disposed.
     * @throws # If the vector passed as argument is null.]]></haxe_doc>
		</add>
		<unit public="1" set="method" line="1035">
			<f a="?weak">
				<x path="Bool"/>
				<c path="nape.geom.Vec2"/>
			</f>
			<haxe_doc>* Return normalisation of this vector.
     *
     * @param weak If true then the allocated Vec2 will be automatically
     *             released to the global object pool when used as an argument
     *             to a Nape function. (default false)
     * @return A copy of this vector, normalised.
     * @throws # If this vector has been disposed of.
     * @throws # If length of this vector is 0.</haxe_doc>
		</unit>
		<normalise public="1" set="method" line="984">
			<f a=""><c path="nape.geom.Vec2"/></f>
			<haxe_doc><![CDATA[* Normalise this vector.
     * <br/><br/>
     * Equivalent to setting the length of the vector to 1, and also to the
     * (less-optimal) <code>this.set(this.unit())</code>.
     *
     * @return A reference to 'this' vector.
     * @throws # If this vector has been disposed of or is immutable.
     * @throws # If length of this vector is 0.]]></haxe_doc>
		</normalise>
		<reflect public="1" set="method" line="942">
			<f a="vec:?weak">
				<c path="nape.geom.Vec2"/>
				<x path="Bool"/>
				<c path="nape.geom.Vec2"/>
			</f>
			<haxe_doc><![CDATA[* Reflect given Vec2 in plane whose normal is this Vec2.
     * <br/><br/>
     * @param vec The vector to be reflected.
     * @param weak If true, the returned Vec2 will be automatically released
     *             to object pool when used in another Nape function (default false)
     * @return The reflected Vec2.
     * @throws # If this vector or argument has been disposed.
     * @throws # If this vector has zero length.]]></haxe_doc>
		</reflect>
		<rotate public="1" set="method" line="907">
			<f a="angle">
				<x path="Float"/>
				<c path="nape.geom.Vec2"/>
			</f>
			<haxe_doc><![CDATA[* Rotate Vec2 in-place by given number of radians..
     * <br/><br/>
     * Rotation performed in the clockwise direction.
     * <br/><br/>
     * The Vec2 will be mutated, with it's new x/y values being the result
     * of the rotation.
     *
     * @param angle The number of radians to rotate Vec2 by in the clockwise
     *              direction.
     * @return A reference to 'this' Vec2.
     * @throws # If this vector has been disposed.
     * @throws # If this vector is immutable.]]></haxe_doc>
		</rotate>
		<set_angle get="inline" set="null" line="874"><f a="angle">
	<x path="Float"/>
	<x path="Float"/>
</f></set_angle>
		<get_angle get="inline" set="null" line="861"><f a=""><x path="Float"/></f></get_angle>
		<angle public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Angle of this Vec2.
     *
     * Measured in radians as measured clockwise from the positive x axis.
     * The value will be given in the range -pi to pi.
     * <br/><br/>
     * If the x/y values of this Vec2 are both 0, then the angle value will
     * default to 0.
     * <br/><br/>
     * This value can also be set (to any value) so that <code>vec.angle +=
     * Math.PI</code> is a valid - if sub-optimial - way of negating a Vec2.
     *
     * @default 0]]></haxe_doc>
		</angle>
		<setxy public="1" get="inline" set="null" line="808">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<c path="nape.geom.Vec2"/>
			</f>
			<haxe_doc>* Set values of this Vec2 given pair of x/y values.
     *
     * @param x The x value to set this Vec2's x value to.
     * @param y The y value to set this Vec2's y value to.
     * @return  A reference to 'this' Vec2.
     * @throws # If this vector has been disposed.
     * @throws # If this vector is immutable.</haxe_doc>
		</setxy>
		<set public="1" get="inline" set="null" line="671">
			<f a="vector">
				<c path="nape.geom.Vec2"/>
				<c path="nape.geom.Vec2"/>
			</f>
			<haxe_doc><![CDATA[* Set values of this Vec2 to those of the argument.
     * <br/><br/>
     * Note that <code>vec.set(p)</code> is semantically equivalent to
     * <code>vec.setxy(p.x, p.y)</code>.
     *
     * @param vector The Vec2 to set the values of this Vec2 with.
     * @return       A reference to 'this' Vec2.
     * @throws # If this vector, or vector argument  has been disposed.
     * @throws # If this vector is immutable.
     * @throws # If the vector passed as argument is null.]]></haxe_doc>
		</set>
		<lsq public="1" set="method" line="650">
			<f a=""><x path="Float"/></f>
			<haxe_doc><![CDATA[* Compute squared length of this Vec2.
     * <br/><br/>
     * This is exactly the same as performing <code>vec.length &#42
     * vec.length</code> except for being more effecient.
     *
     * @return The squared length of this Vec2.
     * @throws # If this vector has been disposed.]]></haxe_doc>
		</lsq>
		<set_length get="inline" set="null" line="607"><f a="length">
	<x path="Float"/>
	<x path="Float"/>
</f></set_length>
		<get_length get="inline" set="null" line="599"><f a=""><x path="Float"/></f></get_length>
		<length public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Length of this Vec2.
     * <br/><br/>
     * This value can be set and may be set to negative values so that
     * <code>vec.length &#42= -1</code> is a valid - if sub-optimal - way of
     * negating a Vec2.
     *
     * @default 0]]></haxe_doc>
		</length>
		<set_y get="inline" set="null" line="568"><f a="y">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<get_y get="inline" set="null" line="559"><f a=""><x path="Float"/></f></get_y>
		<y public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* y coordinate of vector.
     *
     * @default 0</haxe_doc>
		</y>
		<set_x get="inline" set="null" line="532"><f a="x">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<get_x get="inline" set="null" line="523"><f a=""><x path="Float"/></f></get_x>
		<x public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* x coordinate of vector.
     *
     * @default 0</haxe_doc>
		</x>
		<copy public="1" get="inline" set="null" line="425">
			<f a="?weak">
				<x path="Bool"/>
				<c path="nape.geom.Vec2"/>
			</f>
			<haxe_doc><![CDATA[* Produce a copy of this Vec2.
     * <br/><br/>
     * The Vec2 will be allocated from the global object pool.
     * <br/><br/>
     * As would be expected, if you produce a copy of an 'immutable' Vec2, then
     * the copy will be 'mutable'.
     *
     * @param weak If true, then a weak Vec2 will be allocated which will be
     *             automatically released to the object pool when passed as an
     *             argument to any Nape function. (default false)
     * @return     The possibly weak copy of this Vec2.
     * @throws # If this vector has been disposed.]]></haxe_doc>
		</copy>
		<dispose public="1" get="inline" set="null" line="328">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Release this Vec2 to global object pool.
     * <br/><br/>
     * Once diposed this Vec2
     * will be accessible to Nape internals for re-allocation and should
     * not be touched (Good practice would be to set any references to this
     * Vec2 to null to help ensure this).
     * <br/><br/>
     * In debug mode, should you attempt to access this Vec2 after disposal
     * and the Vec2 is still in the object pool, you will be given an Error.
     * The object pool operates on a First-In-Last-Out principal in debug
     * mode to help catch these sort of errors.
     * @throws # If this vector has already been disposed.
     * @throws # If this vector is immutable.
     * @throws # If this vector is in use in some other manner, such as being
     *           an element of a Polygon's vertex list.]]></haxe_doc>
		</dispose>
		<zpp_disp public="1">
			<x path="Bool"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_disp>
		<zpp_pool public="1">
			<c path="nape.geom.Vec2"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_pool>
		<zpp_inner public="1">
			<c path="zpp_nape.geom.ZPP_Vec2"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="400">
			<f a="?x:?y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Construct a new Vec2.
     * <br/><br/>
     * This constructor will obviously not make use of
     * the global object pool: <code>Vec2.get</code> should be used in
     * preference noting that <code>new Vec2(x, y)</code> is semantically
     * equivalent to <code>Vec2.get(x, y)</code>.
     *
     * @param x The x coordinate for the vector. (default 0)
     * @param y The y coordinate for the vector. (default 0)
     * @return  The newly constructed Vec2 object with given x/y values.]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* 2 Dimensional vector.
 * <br/><br/>
 * Note that in many cases of a Vec2 object being returned by a Nape function
 * the Vec2 object will be marked internally as an 'immutable' Vec2. This will
 * always be documented and trying to mutate such a Vec2 will result in an
 * error being thrown.
 * <br/><br/>
 * Vec2 objects can make use of a global object pool, attempting to make use
 * of a disposed Vec2 will also result in an error with the object pool
 * working in a FILO order to increase the likelihood of such misuse being
 * caught.
 * <br/><br/>
 * Additionally Vec2 objects can be created as 'weak'. Passing a weak Vec2 to
 * any Nape function as an argument will result in the automatic disposal of
 * the Vec2 once the method has finished with it. There may be exceptions to
 * this rule which will also be documented; a notable case being the appending
 * of a weak Vec2 to a Nape Vec2List in which case the disposal of the weak
 * Vec2 is performed when that Vec2List is handed to a Nape function instead.
 * <br/><br/>
 * Example:
 * <pre>
 * var vertices = Polygon.box(20, 20, true);
 * var polygon = new Polygon(vertices);
 * </pre>
 * In this example, passing <code>true</code> to the Polygon.box method means
 * that we will be returned a Vec2List containing only 'weak' Vec2s. Upon
 * passing this Vec2List to the Polygon constructor, all of the Vec2s from
 * that list will be automatically disposed.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.geom.Vec2Iterator" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/geom/Vec2Iterator.hx">
		<zpp_pool public="1" line="194" static="1">
			<c path="nape.geom.Vec2Iterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_pool>
		<get public="1" set="method" line="217" static="1">
			<f a="list">
				<c path="nape.geom.Vec2List"/>
				<c path="nape.geom.Vec2Iterator"/>
			</f>
			<haxe_doc><![CDATA[* Create iterator for Nape list.
     * <br/><br/>
     * There is no specific reason to use this over: <code>list.iterator()</code>
     * especcialy since this requires writing the class name :)
     * (This function is used internally)
     *
     * @param list The Nape list to create iterator for.
     * @return     An iterator over the Nape list.]]></haxe_doc>
		</get>
		<next public="1" get="inline" set="null" line="264">
			<f a=""><c path="nape.geom.Vec2"/></f>
			<haxe_doc>* Return next element in list.
     *
     * @return The next element in iteration.</haxe_doc>
		</next>
		<hasNext public="1" get="inline" set="null" line="240">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Check if there are any elements remaining.
     *
     * @return True if there are more elements to iterator over.</haxe_doc>
		</hasNext>
		<zpp_next public="1">
			<c path="nape.geom.Vec2Iterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_next>
		<zpp_critical public="1">
			<x path="Bool"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_critical>
		<zpp_i public="1">
			<x path="Int"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_i>
		<zpp_inner public="1">
			<c path="nape.geom.Vec2List"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="202">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Haxe Iterator<T> compatible iterator over Nape list.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.geom.Vec2List" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/geom/Vec2List.hx">
		<fromArray public="1" set="method" line="304" static="1">
			<f a="array">
				<c path="Array"><c path="nape.geom.Vec2"/></c>
				<c path="nape.geom.Vec2List"/>
			</f>
			<haxe_doc>* Convert standard Array to Nape list.
     *
     * @param array The array to be converted
     * @return An equivalent Nape list.
     * @throws If array argument is null.
     * @throws If array contains elements of type other than Vec2</haxe_doc>
		</fromArray>
		<filter public="1" set="method" line="773">
			<f a="lambda">
				<f a="">
					<c path="nape.geom.Vec2"/>
					<x path="Bool"/>
				</f>
				<c path="nape.geom.Vec2List"/>
			</f>
			<haxe_doc><![CDATA[* Iterate over list filtering elements.
     * <br/><br/>
     * The given function will be applied to each element, whenever the
     * function returns false, the element will be removed from the list.
     * <br/><br/>
     * Any exception thrown by the supplied function will be treat as a
     * signal to halt iteration acting as a 'break' statement.
     * <br/><br/>
     * This method is to be greatly preferred for filtering logic as
     * it is otherwise unsafe to modify the list during an iteration.
     * <br/><br/>
     * An example of using this method to clean up a list whilst performing
     * actions on the elements.
     * <pre>
     * list.filter(function (obj) {
     *    // perform clean up with obj
     *    return false; // remove from list.
     * });
     * </pre>
     *
     * @param lambda The function to apply to each argument, deciding if
     *               element should be removed.
     * @return A reference to 'this' list.
     * @throws # If lambda argument is null.]]></haxe_doc>
		</filter>
		<foreach public="1" set="method" line="726">
			<f a="lambda">
				<f a="">
					<c path="nape.geom.Vec2"/>
					<x path="Void"/>
				</f>
				<c path="nape.geom.Vec2List"/>
			</f>
			<haxe_doc><![CDATA[* Iterate over list applying function.
     * <br/><br/>
     * Any exception thrown by the supplied function will be treat as a
     * signal to halt iteration acting as a 'break' statement.
     * <br/><br/>
     * This method should be preferred to using standard haxe iteration
     * as there will be no allocation of an iterator object.
     * <pre>
     * list.foreach(function (obj) {
     *     if (ignore_object(obj)) return; //acts as a 'continue' statement
     *     if (halt_iteration(obj)) throw "": //acts as a 'break' statement
     * });
     * </pre>
     *
     * @param lambda The function to apply to each argument.
     * @return A reference to 'this' list.
     * @throws # If lambda argument is null.]]></haxe_doc>
		</foreach>
		<toString public="1" set="method" line="696">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<merge public="1" set="method" line="678">
			<f a="xs">
				<c path="nape.geom.Vec2List"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Merge given list into this one.
     * <br/><br/>
     * The result is that this list will have all objects from the argument
     * that were not already in the list inserted. You should make no
     * assumption about the order of these insertions.
     *
     * @param xs The list to merge.
     * @throws # If xs argument is null.]]></haxe_doc>
		</merge>
		<copy public="1" set="method" line="662">
			<f a="?deep">
				<x path="Bool"/>
				<c path="nape.geom.Vec2List"/>
			</f>
			<haxe_doc>* Produce a possibly deep copy of list.
     *
     * @param deep If true, then each element will have its own copy
     *             function called instead of simply having its
     *             reference copied over.
     * @return     The copied list.</haxe_doc>
		</copy>
		<iterator public="1" set="method" line="647">
			<f a=""><c path="nape.geom.Vec2Iterator"/></f>
			<haxe_doc><![CDATA[* Return Haxe iterator for list.
     * <br/><br/>
     * Use of this iterator, whilst stylistically better in Haxe should not
     * be used, in preference for use of the foreach function which will
     * not require allocation of an iterator object.
     * <br/><br/>
     * Equally in AS3, the foreach method should be the preferred way to iterate.]]></haxe_doc>
		</iterator>
		<empty public="1" set="method" line="631">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Test if list is empty or not.
     *
     * @return True if list is empty.</haxe_doc>
		</empty>
		<clear public="1" set="method" line="614">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clear the list, removing all elements.
     *
     * @throws # If list is iummutable</haxe_doc>
		</clear>
		<remove public="1" set="method" line="576">
			<f a="obj">
				<c path="nape.geom.Vec2"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Remove element from list.
     * <br/><br/>
     * This is a linear time operation.
     *
     * @param obj The object to remove
     * @return True if object was removed from list.
     * @throws # If list is immutable]]></haxe_doc>
		</remove>
		<add public="1" set="method" line="563">
			<f a="obj">
				<c path="nape.geom.Vec2"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Insert element into list in most effecient way.
     * <br/><br/>
     * This method will defer to either the push or unshift function
     * depending on which is most effecient in the context.
     * <br/><br/>
     * If order of elements is not important then you should always use
     * this function to insert elements.
     *
     * @param obj The object to insert.
     * @return True if object was successfuly inserted.
     * @throws # If list is immutable]]></haxe_doc>
		</add>
		<shift public="1" set="method" line="519">
			<f a=""><c path="nape.geom.Vec2"/></f>
			<haxe_doc><![CDATA[* Pop element from front of list.
     * <br/><br/>
     * If you are wanting to clear a list, whilst operating on its elements,
     * consider use of the filter method instead.
     *
     * @returns The element removed from list.
     * @throws # If list is immutable.
     * @throws # If the list is empty.]]></haxe_doc>
		</shift>
		<pop public="1" set="method" line="478">
			<f a=""><c path="nape.geom.Vec2"/></f>
			<haxe_doc><![CDATA[* Pop element from back of list.
     * <br/><br/>
     * If you are wanting to clear a list, whilst operating on its elements,
     * consider use of the filter method instead.
     *
     * @returns The element removed from list.
     * @throws # If list is immutable.
     * @throws # If the list is empty.]]></haxe_doc>
		</pop>
		<unshift public="1" set="method" line="447">
			<f a="obj">
				<c path="nape.geom.Vec2"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Push element to front of list.
     * <br/><br/>
     * When the order of objects is not important, it is best to use the
     * add() method instead.
     *
     * @param obj The object to insert.
     * @returns True if object was successively inserted.
     * @throws # If list is immutable.]]></haxe_doc>
		</unshift>
		<push public="1" set="method" line="416">
			<f a="obj">
				<c path="nape.geom.Vec2"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Push element to back of list.
     * <br/><br/>
     * When the order of objects is not important, it is best to use the
     * add() method instead.
     *
     * @param obj The object to insert.
     * @returns True if object was successively inserted.
     * @throws # If list is immutable.]]></haxe_doc>
		</push>
		<at public="1" set="method" line="363">
			<f a="index">
				<x path="Int"/>
				<c path="nape.geom.Vec2"/>
			</f>
			<haxe_doc><![CDATA[* Random access to elements of list by index.
     * <br/><br/>
     * Under normal circumstances, accessing succesive elements via this
     * method will occur in constant time.
     *
     * @param index The index of the element in list to access.
     * @returns The element at the given index.
     * @throws # If index is out of bounds.]]></haxe_doc>
		</at>
		<has public="1" set="method" line="346">
			<f a="obj">
				<c path="nape.geom.Vec2"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if element is already in the list
     *
     * @param obj The object to test.
     * @return True if object is in the list.</haxe_doc>
		</has>
		<zpp_vm public="1" set="method" line="291">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</zpp_vm>
		<zpp_gl public="1" set="method" line="269">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* @private</haxe_doc>
		</zpp_gl>
		<get_length get="inline" set="null" line="263"><f a=""><x path="Int"/></f></get_length>
		<length public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Length of list.</haxe_doc>
		</length>
		<zpp_inner public="1">
			<c path="zpp_nape.util.ZPP_Vec2List"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="689">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Construct a new list.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Nape list of Vec2 type objects
 * <br/><br/>
 * Internally this list is at present implemented as a linked list with
 * object pooled nodes and iterators with various fast paths made for
 * standard access patterns (For instance accessing successive elements
 * runs in constant time when using random access functions)
 * <br/><br/>
 * Iteration of this list can be done in various ways, but the preferred
 * way on all targets, is through use of the foreach function:
 * <pre>
 * list.foreach(function (obj) {
 * });
 * </pre>
 * This method is inlined so that in haxe no closure will need to be created.
 * <br/><br/>
 * In AS3, a closure would need to be created in general, so for performance
 * reasons you 'may' choose to use iteration as follows:
 * <pre>
 * for (var i:int = 0; i < list.length; i++) {
 *     var obj:Vec2 = list.at(i);
 * }
 * </pre>
 * <br/>
 * NOTE: It is 'not' safe to modify a list whilst iterating over it.
 * If you wish to remove elements during an iteration you should use the
 * filter method, for example:
 * <pre>
 * list.filter(function (obj) {
 *     // operate on object.
 *     // ...
 *     return (false if you want object to be removed);
 * });
 * </pre>
 * <br/><br/>
 * In AS3, if you wish to avoid a closure generation, you can perform such
 * an iteration in a safe manner as follows:
 * <pre>
 * var i:int = 0;
 * while (i < list.length) {
 *     var obj:Vec2 = list.at(i);
 *     // operate on object.
 *     // ...
 *     if (should remove obj) {
 *         list.remove(obj);
 *         continue;
 *     }
 *     else i++;
 * }
 * </pre>
 * Or if you are always clearing the list entirely you could write:
 * <pre>
 * while (!list.empty()) {
 *     var obj:Vec2 = list.pop();
 *     // operate on object.
 *     // ...
 * }
 * </pre>]]></haxe_doc>
	</class>
	<class path="nape.geom.Vec3" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/geom/Vec3.hx">
		<get public="1" set="method" line="322" static="1">
			<f a="?x:?y:?z">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="nape.geom.Vec3"/>
			</f>
			<haxe_doc><![CDATA[* Allocate a Vec3 from the global object pool.
     * <br/><br/>
     * Use of this method should always be preferred to the constructor.
     *
     * @param x The x component of Vec3. (default 0)
     * @param y The y component of Vec3. (default 0)
     * @param z The z component of Vec3. (default 0)
     * @return A Vec3 allocated from global object pool with given components.]]></haxe_doc>
		</get>
		<toString public="1" set="method" line="608">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<xy public="1" set="method" line="597">
			<f a="?weak">
				<x path="Bool"/>
				<c path="nape.geom.Vec2"/>
			</f>
			<haxe_doc><![CDATA[* Produce copy of the xy components of Vec3.
     * <br/><br/>
     * This function will return a new Vec2 completely seperate
     * from this Vec3 with values equal to the xy components of
     * this Vec3.
     *
     * @param weak If true, then the allocated Vec2 will be weak
     *             so that when used as an argument to a Nape
     *             function it will be automatically released back
     *             to the global object pool. (default false)
     * @return An allocated Vec2 representing the xy components of
     *         this vector.]]></haxe_doc>
		</xy>
		<setxyz public="1" set="method" line="552">
			<f a="x:y:z">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="nape.geom.Vec3"/>
			</f>
			<haxe_doc>* Set values of this Vec3 from numbers.
     *
     * @param x The new x component value for this vector.
     * @param y The new y component value for this vector.
     * @param z The new z component value for this vector.
     * @return A reference to this Vec3.
     * @throws # If this Vec3 has been disposed of.
     * @throws # If this Vec3 is immutable.</haxe_doc>
		</setxyz>
		<set public="1" set="method" line="524">
			<f a="vector">
				<c path="nape.geom.Vec3"/>
				<c path="nape.geom.Vec3"/>
			</f>
			<haxe_doc>* Set values of this Vec3 from another.
     *
     * @param vector The vector to set values from.
     * @return A reference to this Vec3.
     * @throws # If the vector argument is null.
     * @throws # If this, or the vector argument are disposed of.
     * @throws # If this Vec3 is immutable.</haxe_doc>
		</set>
		<lsq public="1" set="method" line="507">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Compute squared length of Vec3.
     *
     * @return The squared length of this Vec3.
     * @throws # If the Vec3 has been disposed of.</haxe_doc>
		</lsq>
		<set_length get="inline" set="null" line="465"><f a="length">
	<x path="Float"/>
	<x path="Float"/>
</f></set_length>
		<get_length get="inline" set="null" line="457"><f a=""><x path="Float"/></f></get_length>
		<length public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Length of Vec3.
     * <br/><br/>
     * This value may also be set to any value including negatives, though
     * an error will be thrown if length of the Vec3 is already 0 as such
     * a scaling would be undefined. As well as if this Vec3 has been disposed
     * of, or is immutable.
     *
     * @default 0]]></haxe_doc>
		</length>
		<dispose public="1" set="method" line="406">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Produce a copy of this Vec3.
     *
     * @return The copy of this Vec3.
     * @throws # If this Vec3 has been disposed of.
    public function copy():Vec3{
        {
            #if(!NAPE_RELEASE_BUILD)
            if(this!=null&&this.zpp_disp)throw "Error: "+"Vec3"+" has been disposed and cannot be used!";
            #end
        };
        return Vec3.get(x,y,z);
    }
    /**
     * Release Vec3 object to global object pool.
     *
     * @throws # If this Vec3 has already been disposed of.
     * @throws # If this Vec3 is immutable.]]></haxe_doc>
		</dispose>
		<set_z get="inline" set="null" line="296"><f a="z">
	<x path="Float"/>
	<x path="Float"/>
</f></set_z>
		<get_z get="inline" set="null" line="287"><f a=""><x path="Float"/></f></get_z>
		<z public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The z component of Vec3.
     * @default 0</haxe_doc>
		</z>
		<set_y get="inline" set="null" line="265"><f a="y">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<get_y get="inline" set="null" line="256"><f a=""><x path="Float"/></f></get_y>
		<y public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The y component of Vec3.
     * @default 0</haxe_doc>
		</y>
		<set_x get="inline" set="null" line="234"><f a="x">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<get_x get="inline" set="null" line="225"><f a=""><x path="Float"/></f></get_x>
		<x public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The x component of Vec3.
     * @default 0</haxe_doc>
		</x>
		<zpp_disp public="1">
			<x path="Bool"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_disp>
		<zpp_pool public="1">
			<c path="nape.geom.Vec3"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_pool>
		<zpp_inner public="1">
			<c path="zpp_nape.geom.ZPP_Vec3"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="360">
			<f a="?x:?y:?z">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Construct a new Vec3.
     * <br/><br/>
     * This method should not generally be used with preference for the
     * static get method which will make use of the global object pool.
     *
     * @param x The x component of Vec3. (default 0)
     * @param y The y component of Vec3. (default 0)
     * @param z The z component of Vec3. (default 0)
     * @return A newly constructed Vec3 with given components.]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* A 3 dimensional vector object.
 * <br/><br/>
 * In many instances a Vec3 will be accessible from Nape which is marked
 * as immutable, these cases will be documented and modifying such a Vec3
 * will result in an error.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.geom.Winding" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/geom/Winding.hx">
		<UNDEFINED public="1" get="accessor" set="null" static="1">
			<c path="nape.geom.Winding"/>
			<haxe_doc><![CDATA[* Value represents that the polygon has no discernible, or ambiguous winding
     * <br/><br/>
     * This may be because the polygon is degenerate, or because it is self
     * intersecting. In either case it is not well defined to say that the winding
     * is either clockwise or anticlockwise.]]></haxe_doc>
		</UNDEFINED>
		<get_UNDEFINED get="inline" set="null" line="213" static="1"><f a=""><c path="nape.geom.Winding"/></f></get_UNDEFINED>
		<CLOCKWISE public="1" get="accessor" set="null" static="1">
			<c path="nape.geom.Winding"/>
			<haxe_doc>* Value represents that the polygon is wound clockwise.</haxe_doc>
		</CLOCKWISE>
		<get_CLOCKWISE get="inline" set="null" line="226" static="1"><f a=""><c path="nape.geom.Winding"/></f></get_CLOCKWISE>
		<ANTICLOCKWISE public="1" get="accessor" set="null" static="1">
			<c path="nape.geom.Winding"/>
			<haxe_doc>* Value represents that the polygon is wound anticlockwise.</haxe_doc>
		</ANTICLOCKWISE>
		<get_ANTICLOCKWISE get="inline" set="null" line="239" static="1"><f a=""><c path="nape.geom.Winding"/></f></get_ANTICLOCKWISE>
		<toString public="1" set="method" line="196">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<new public="1" set="method" line="188">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Enumeration represents the winding of a Polygon.
 * <br/><br/>
 * To appreciate what the winding of a polygon means, think of a polygon who's
 * vertices are the numbers on a clock face.
 *
 * If the vertices are ordered <code>12 -&gt; 1 -&gt; 2 ... -&gt; 12</code>
 * then this polygon is clockwise wound. The reverse order would mean the
 * polygon is wound anticlockwise.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.phys.Interactor" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/phys/Interactor.hx">
		<toString public="1" set="method" line="293">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<get_cbTypes get="inline" set="null" line="278"><f a=""><c path="nape.callbacks.CbTypeList"/></f></get_cbTypes>
		<cbTypes public="1" get="accessor" set="null">
			<c path="nape.callbacks.CbTypeList"/>
			<haxe_doc>* Set of CbType's assigned to this Interactor.
     *
     * @default []</haxe_doc>
		</cbTypes>
		<set_group get="inline" set="null" line="264"><f a="group">
	<t path="Null"><c path="nape.dynamics.InteractionGroup"/></t>
	<t path="Null"><c path="nape.dynamics.InteractionGroup"/></t>
</f></set_group>
		<get_group get="inline" set="null" line="261"><f a=""><t path="Null"><c path="nape.dynamics.InteractionGroup"/></t></f></get_group>
		<group public="1" get="accessor" set="accessor">
			<t path="Null"><c path="nape.dynamics.InteractionGroup"/></t>
			<haxe_doc>* InteractionGroup assigned to this Interactor.
     *
     * @default null</haxe_doc>
		</group>
		<get_castCompound get="inline" set="null" line="251"><f a=""><t path="Null"><c path="nape.phys.Compound"/></t></f></get_castCompound>
		<castCompound public="1" get="accessor" set="null">
			<t path="Null"><c path="nape.phys.Compound"/></t>
			<haxe_doc><![CDATA[* Fast equivalent to <code>cast(interactor, Compound)</code>]]></haxe_doc>
		</castCompound>
		<get_castBody get="inline" set="null" line="243"><f a=""><t path="Null"><c path="nape.phys.Body"/></t></f></get_castBody>
		<castBody public="1" get="accessor" set="null">
			<t path="Null"><c path="nape.phys.Body"/></t>
			<haxe_doc><![CDATA[* Fast equivalent to <code>cast(interactor, Body)</code>]]></haxe_doc>
		</castBody>
		<get_castShape get="inline" set="null" line="235"><f a=""><t path="Null"><c path="nape.shape.Shape"/></t></f></get_castShape>
		<castShape public="1" get="accessor" set="null">
			<t path="Null"><c path="nape.shape.Shape"/></t>
			<haxe_doc><![CDATA[* Fast equivalent to <code>cast(interactor, Shape)</code>]]></haxe_doc>
		</castShape>
		<isCompound public="1" get="inline" set="null" line="227">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[* Fast equivalent to <code>Std.is(interactor, Compound)</code>
     * @return true if this Interactor is a Compound.]]></haxe_doc>
		</isCompound>
		<isBody public="1" get="inline" set="null" line="219">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[* Fast equivalent to <code>Std.is(interactor, Body)</code>
     * @return true if this Interactor is a Body.]]></haxe_doc>
		</isBody>
		<isShape public="1" get="inline" set="null" line="211">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[* Fast equivalent to <code>Std.is(interactor, Shape)</code>
     * @return true if this Interactor is a Shape.]]></haxe_doc>
		</isShape>
		<get_userData get="inline" set="null" line="200"><f a=""><d><d/></d></f></get_userData>
		<userData public="1" get="accessor" set="null">
			<d><d/></d>
			<haxe_doc><![CDATA[* Dynamic object for user to store additional data.
     * <br/><br/>
     * This object cannot be set, only its dynamically created
     * properties may be set. In AS3 the type of this property is &#42
     * <br/><br/>
     * This object will be lazily constructed so that until accessed
     * for the first time, will be null internally.
     *
     * @default {}]]></haxe_doc>
		</userData>
		<get_id get="inline" set="null" line="184"><f a=""><x path="Int"/></f></get_id>
		<id public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Unique id of this Interactor.</haxe_doc>
		</id>
		<zpp_inner_i public="1">
			<c path="zpp_nape.phys.ZPP_Interactor"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner_i>
		<new public="1" set="method" line="285">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
	</class>
	<class path="nape.phys.Body" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/phys/Body.hx">
		<extends path="nape.phys.Interactor"/>
		<toString public="1" set="method" line="2537" override="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<contains public="1" set="method" line="2492">
			<f a="point">
				<c path="nape.geom.Vec2"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Determine if point is contained in Body.
     *
     * @param point The point to test containment for in world coordinates.
     * @return True if point is contained.
     * @throws # If point is null or has been disposed.</haxe_doc>
		</contains>
		<totalImpulse public="1" set="method" line="2407">
			<f a="?body:?freshOnly">
				<c path="nape.phys.Body"/>
				<x path="Bool"/>
				<c path="nape.geom.Vec3"/>
			</f>
			<haxe_doc><![CDATA[* Evaluate sum effect of all impulses on Body.
     * <br/><br/
     * If the body argument is non-null, then only impulses between 'this' and
     * the given Body will be considered when evaluating interaction impulses.
     * <br/>
     * Constraint impulses are not effected by the body argument.
     *
     * @param body The Body to restrict consideration of impulses with.
     *             (default null)
     * @param freshOnly If true, then only 'new' contact points will be considered
     *             when evaluating contact impulses.
     *             (default false)
     * @return The summed effect of impulses acting on Body.]]></haxe_doc>
		</totalImpulse>
		<constraintsImpulse public="1" set="method" line="2341">
			<f a=""><c path="nape.geom.Vec3"/></f>
			<haxe_doc>* Evaluate sum effect of all constraint impulses on this Body.
     *
     * @return The summed effect of constraint impulses acting on Body.</haxe_doc>
		</constraintsImpulse>
		<totalFluidImpulse public="1" set="method" line="2284">
			<f a="?body">
				<c path="nape.phys.Body"/>
				<c path="nape.geom.Vec3"/>
			</f>
			<haxe_doc><![CDATA[* Evaluate sum effect of all fluid impulses acting on Body.
     * <br/><br/
     * If the body argument is non-null, then only impulses between 'this' and
     * the given Body will be considered.
     *
     * @param body The Body to restrict consideration of impulses with.
     *             (default null)
     * @return The summed effect of impulses acting on Body.]]></haxe_doc>
		</totalFluidImpulse>
		<dragImpulse public="1" set="method" line="2222">
			<f a="?body">
				<c path="nape.phys.Body"/>
				<c path="nape.geom.Vec3"/>
			</f>
			<haxe_doc><![CDATA[* Evaluate sum effect of all fluid drag impulses acting on Body.
     * <br/><br/
     * If the body argument is non-null, then only impulses between 'this' and
     * the given Body will be considered.
     *
     * @param body The Body to restrict consideration of impulses with.
     *             (default null)
     * @return The summed effect of impulses acting on Body.]]></haxe_doc>
		</dragImpulse>
		<buoyancyImpulse public="1" set="method" line="2160">
			<f a="?body">
				<c path="nape.phys.Body"/>
				<c path="nape.geom.Vec3"/>
			</f>
			<haxe_doc><![CDATA[* Evaluate sum effect of all buoyancy impulses acting on Body.
     * <br/><br/
     * If the body argument is non-null, then only impulses between 'this' and
     * the given Body will be considered.
     *
     * @param body The Body to restrict consideration of impulses with.
     *             (default null)
     * @return The summed effect of impulses acting on Body.]]></haxe_doc>
		</buoyancyImpulse>
		<rollingImpulse public="1" set="method" line="2134">
			<f a="?body:?freshOnly">
				<c path="nape.phys.Body"/>
				<x path="Bool"/>
				<x path="Float"/>
			</f>
			<haxe_doc><![CDATA[* Evaluate sum effect of all rolling friction contact impulses on Body.
     * <br/><br/
     * If the body argument is non-null, then only impulses between 'this' and
     * the given Body will be considered.
     *
     * @param body The Body to restrict consideration of impulses with.
     *             (default null)
     * @param freshOnly If true, then only 'new' contact points will be considered.
     *             (default false)
     * @return The summed effect of impulses acting on Body.]]></haxe_doc>
		</rollingImpulse>
		<totalContactsImpulse public="1" set="method" line="2070">
			<f a="?body:?freshOnly">
				<c path="nape.phys.Body"/>
				<x path="Bool"/>
				<c path="nape.geom.Vec3"/>
			</f>
			<haxe_doc><![CDATA[* Evaluate sum effect of all contact impulses on Body.
     * <br/><br/>
     * If the body argument is non-null, then only impulses between 'this' and
     * the given Body will be considered.
     *
     * @param body The Body to restrict consideration of impulses with.
     *             (default null)
     * @param freshOnly If true, then only 'new' contact points will be considered.
     *             (default false)
     * @return The summed effect of impulses acting on Body.]]></haxe_doc>
		</totalContactsImpulse>
		<tangentImpulse public="1" set="method" line="2006">
			<f a="?body:?freshOnly">
				<c path="nape.phys.Body"/>
				<x path="Bool"/>
				<c path="nape.geom.Vec3"/>
			</f>
			<haxe_doc><![CDATA[* Evaluate sum effect of all tangent contact impulses on Body.
     * <br/><br/>
     * If the body argument is non-null, then only impulses between 'this' and
     * the given Body will be considered.
     *
     * @param body The Body to restrict consideration of impulses with.
     *             (default null)
     * @param freshOnly If true, then only 'new' contact points will be considered.
     *             (default false)
     * @return The summed effect of impulses acting on Body.]]></haxe_doc>
		</tangentImpulse>
		<normalImpulse public="1" set="method" line="1942">
			<f a="?body:?freshOnly">
				<c path="nape.phys.Body"/>
				<x path="Bool"/>
				<c path="nape.geom.Vec3"/>
			</f>
			<haxe_doc><![CDATA[* Evaluate sum effect of all normal contact impulses on Body.
     * <br/><br/>
     * If the body argument is non-null, then only impulses between 'this' and
     * the given Body will be considered.
     *
     * @param body The Body to restrict consideration of impulses with.
     *             (default null)
     * @param freshOnly If true, then only 'new' contact points will be considered.
     *             (default false)
     * @return The summed effect of impulses acting on Body.]]></haxe_doc>
		</normalImpulse>
		<get_worldCOM get="inline" set="null" line="1917"><f a=""><c path="nape.geom.Vec2"/></f></get_worldCOM>
		<worldCOM public="1" get="accessor" set="null">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* World centre of mass of Body.
     * <br/><br/>
     * This value can be accessed even if Body has no shapes, but attempting
     * to query its values will result in a debug build error.
     * <br/><br/>
     * This Vec2 is immutable.]]></haxe_doc>
		</worldCOM>
		<get_localCOM get="inline" set="null" line="1895"><f a=""><c path="nape.geom.Vec2"/></f></get_localCOM>
		<localCOM public="1" get="accessor" set="null">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* Local centre of mass of Body.
     * <br/><br/>
     * This value can be accessed even if Body has no shapes, but attempting
     * to query its values will result in a debug build error.
     * <br/><br/>
     * This Vec2 is immutable.]]></haxe_doc>
		</localCOM>
		<setShapeFluidProperties public="1" set="method" line="1870">
			<f a="fluidProperties">
				<c path="nape.phys.FluidProperties"/>
				<c path="nape.phys.Body"/>
			</f>
			<haxe_doc><![CDATA[* Set fluidProperties of all shapes.
     * <br/><br/>
     * Equivalent to: <code>body.shapes.foreach(function (shape) shape.fluidProperties = fluidProperties)</code>
     *
     * @param fluidProperties The fluidProperties to set Shape's fluidProperties to.
     * @return A reference to this Body.]]></haxe_doc>
		</setShapeFluidProperties>
		<setShapeFilters public="1" set="method" line="1846">
			<f a="filter">
				<c path="nape.dynamics.InteractionFilter"/>
				<c path="nape.phys.Body"/>
			</f>
			<haxe_doc><![CDATA[* Set interaction filter of all shapes.
     * <br/><br/>
     * Equivalent to: <code>body.shapes.foreach(function (shape) shape.filter = filter)</code>
     *
     * @param filter The filter to set Shape's filter to.
     * @return A reference to this Body.]]></haxe_doc>
		</setShapeFilters>
		<setShapeMaterials public="1" set="method" line="1822">
			<f a="material">
				<c path="nape.phys.Material"/>
				<c path="nape.phys.Body"/>
			</f>
			<haxe_doc><![CDATA[* Set material of all shapes.
     * <br/><br/>
     * Equivalent to: <code>body.shapes.foreach(function (shape) shape.material = material)</code>
     *
     * @param material The material to set Shape's material to.
     * @return A reference to this Body.]]></haxe_doc>
		</setShapeMaterials>
		<rotate public="1" set="method" line="1780">
			<f a="centre:angle">
				<c path="nape.geom.Vec2"/>
				<x path="Float"/>
				<c path="nape.phys.Body"/>
			</f>
			<haxe_doc><![CDATA[* Rotate body about about given point.
     * <br/><br/>
     * Please note that this method is equivalent to teleporting the body,
     * the same way direct manipulation of position and rotation is.
     *
     * @param centre The centre of rotation in world coordinates.
     * @param angle The angle to rotate body by in clockwise radians.
     * @return A reference to this Body.
     * @throws # If this Body is static, and inside of a Space.
     * @throws # If centre is null or disposed of.]]></haxe_doc>
		</rotate>
		<align public="1" set="method" line="1737">
			<f a=""><c path="nape.phys.Body"/></f>
			<haxe_doc><![CDATA[* Align rigid body so that its origin is also its centre of mass.
     * <br/><br/>
     * This operation will both translate the Shapes inside of the Body,
     * as well as translating the Body itself so that its 'apparent' position
     * has not been modified.
     * <br/><br/>
     * Alignment of Rigid bodies is necessary for dynamic bodies so that
     * they will interact and rotate as expected.
     * <br/><br/>
     * Simple Body's created with a single Polygon.box() or basic Circle
     * will already be aligned.
     *
     * @return A reference to this Body.]]></haxe_doc>
		</align>
		<transformShapes public="1" set="method" line="1706">
			<f a="matrix">
				<c path="nape.geom.Mat23"/>
				<c path="nape.phys.Body"/>
			</f>
			<haxe_doc><![CDATA[* Transform each shape in local coordiantes.
     * <br/><br/>
     * This operation does not affect the Body itself, but affects each
     * Shape 'inside' of the Body instead.
     *
     * @param matrix The transformation matrix to apply to each Shape.
     * @return A reference to this Body.
     * @throws # If this Body is static, and inside of a Space.
     * @throws # If matrix is null or singular.
     * @throws # If Body contains Circle shapes, and input matrix is
     *           not equiorthogonal.]]></haxe_doc>
		</transformShapes>
		<scaleShapes public="1" set="method" line="1677">
			<f a="scaleX:scaleY">
				<x path="Float"/>
				<x path="Float"/>
				<c path="nape.phys.Body"/>
			</f>
			<haxe_doc><![CDATA[* Scale each shape in local coordinates.
     * <br/><br/>
     * This operation does not affect the Body itself, but affects each
     * Shape 'inside' of the Body instead.
     *
     * @param scaleX The x-coordinate factor of scaling.
     * @param scaleY The y-coordinate factor of scaling.
     * @return A reference to this Body.
     * @throws # If this Body is static, and inside of a Space.
     * @throws # If Body contains Circle shapes, and scaleX != scaleY]]></haxe_doc>
		</scaleShapes>
		<rotateShapes public="1" set="method" line="1649">
			<f a="angle">
				<x path="Float"/>
				<c path="nape.phys.Body"/>
			</f>
			<haxe_doc><![CDATA[* Rotate each shape in local coordinates.
     * <br/><br/>
     * This operation does not effect the Body's rotation, but rotates
     * each of the shapes 'inside' of the Body.
     *
     * @param angle The angle to rotate shapes by in clockwise radians.
     * @return A reference to this Body.
     * @throws # If this Body is static, and inside of a Space.]]></haxe_doc>
		</rotateShapes>
		<translateShapes public="1" set="method" line="1601">
			<f a="translation">
				<c path="nape.geom.Vec2"/>
				<c path="nape.phys.Body"/>
			</f>
			<haxe_doc><![CDATA[* Translate each shape in local coordinates.
     * <br/><br/>
     * This operation does not effect the Body's position, but the position
     * of the shapes 'inside' of the Body.
     *
     * @param translation The local translation to apply to Shapes.
     * @return A reference to this Body.
     * @throws # If translation is null or has been disposed of.
     * @throws # If this Body is static, and inside of a Space.]]></haxe_doc>
		</translateShapes>
		<applyAngularImpulse public="1" set="method" line="1575">
			<f a="impulse:?sleepable">
				<x path="Float"/>
				<x path="Bool"/>
				<c path="nape.phys.Body"/>
			</f>
			<haxe_doc>* Apply a pure angular impulse to Body.
     *
     * @param impulse The angular impulse to apply.
     * @param sleepable This parameter can be set to true, in the case that you
     *                  are constantly applying an impulse which is dependent only
     *                  on the position/velocity of the body meaning that application
     *                  of this impulse does not need to prevent the object from sleeping.
     *                  When true, and the body is sleeping, this method call will not
     *                  apply any impulse.
     *                  (default false).
     * @returns A reference to 'this' Body.</haxe_doc>
		</applyAngularImpulse>
		<applyImpulse public="1" set="method" line="1479">
			<f a="impulse:?pos:?sleepable">
				<c path="nape.geom.Vec2"/>
				<c path="nape.geom.Vec2"/>
				<x path="Bool"/>
				<c path="nape.phys.Body"/>
			</f>
			<haxe_doc><![CDATA[* Apply impulse to a point on Body.
     * <br/><br/>
     * If position argument is not given, then body.position is assumed so that impulse
     * is applied at centre of Body.
     *
     * @param impulse The impulse to apply given in world coordinates.
     * @param pos The position to apply impulse given in world coordinates.
     *            (default body.position)
     * @param sleepable This parameter can be set to true, in the case that you
     *                  are constantly applying an impulse which is dependent only
     *                  on the position/velocity of the body meaning that application
     *                  of this impulse does not need to prevent the object from sleeping.
     *                  When true, and the body is sleeping, this method call will not
     *                  apply any impulse.
     *                  (default false).
     * @throws # If impulse is null or disposed of.
     * @throws # If pos is non-null and disposed of.
     * @returns A reference to 'this' Body.]]></haxe_doc>
		</applyImpulse>
		<worldVectorToLocal public="1" set="method" line="1429">
			<f a="vector:?weak">
				<c path="nape.geom.Vec2"/>
				<x path="Bool"/>
				<c path="nape.geom.Vec2"/>
			</f>
			<haxe_doc><![CDATA[* Transform vector from world coordinates to Body's local coordinates
     * <br/><br/>
     *
     * @param vector The vector to transform.
     * @param weak If true the returned Vec2 will be automatically released
     *             back to object pool when used as an argument to a Nape function.
     *             (default false)
     * @return The result of the transformation.
     * @throws # If vector is null or disposed of.]]></haxe_doc>
		</worldVectorToLocal>
		<localVectorToWorld public="1" set="method" line="1388">
			<f a="vector:?weak">
				<c path="nape.geom.Vec2"/>
				<x path="Bool"/>
				<c path="nape.geom.Vec2"/>
			</f>
			<haxe_doc><![CDATA[* Transform vector from Body's local coordinates into world coordinates.
     * <br/><br/>
     *
     * @param vector The vector to transform.
     * @param weak If true the returned Vec2 will be automatically released
     *             back to object pool when used as an argument to a Nape function.
     *             (default false)
     * @return The result of the transformation.
     * @throws # If vector is null or disposed of.]]></haxe_doc>
		</localVectorToWorld>
		<worldPointToLocal public="1" set="method" line="1341">
			<f a="point:?weak">
				<c path="nape.geom.Vec2"/>
				<x path="Bool"/>
				<c path="nape.geom.Vec2"/>
			</f>
			<haxe_doc>* Transform a point from world coordinates to Body's local coordinates.
     *
     * @param point The point to transform.
     * @param weak If true the returned Vec2 will be automatically released
     *             back to object pool when used as an argument to a Nape function.
     *             (default false)
     * @return The result of the transformation.
     * @throws # If point is null or disposed of.</haxe_doc>
		</worldPointToLocal>
		<localPointToWorld public="1" set="method" line="1301">
			<f a="point:?weak">
				<c path="nape.geom.Vec2"/>
				<x path="Bool"/>
				<c path="nape.geom.Vec2"/>
			</f>
			<haxe_doc>* Transform a point from Body's local coordinates to world coordinates.
     *
     * @param point The point to transform.
     * @param weak If true the returned Vec2 will be automatically released
     *             back to object pool when used as an argument to a Nape function.
     *             (default false)
     * @return The result of the transformation.
     * @throws # If point is null or disposed of.</haxe_doc>
		</localPointToWorld>
		<crushFactor public="1" set="method" line="1264">
			<f a=""><x path="Float"/></f>
			<haxe_doc><![CDATA[* Determine how much this body is being crushed.
     * <br/><br/>
     * This is an approximate value, computed as:
     * <code>crushFactor = (sum(magnitude(impulse)) - magnitude(sum(impulse))) / mass</code>
     * <br/><br/>
     * In this way, it is a mass and time step invariant value which is 0 when all impulses
     * are acting on body in the same direction, and has maximum value when impulses
     * act in opposing directions 'crushing' the Body.
     *
     * @return A positive value representing an approximation to how much the
     *         body is being crushed.
     * @throws # If body is not in a Space.]]></haxe_doc>
		</crushFactor>
		<interactingBodies public="1" set="method" line="1242">
			<f a="?type:?depth:?output">
				<c path="nape.callbacks.InteractionType"/>
				<x path="Int"/>
				<c path="nape.phys.BodyList"/>
				<c path="nape.phys.BodyList"/>
			</f>
			<haxe_doc>* Compute set of bodies interacting with this body.
     *
     * @param type When not equal to null, this parameter controls what sort
     *             of interaction we permit in the search.
     * @param depth Control the depth limit of the graph search. Negative
     *              values indicate an unlimited search. A depth value of
     *              0 would cause only the current Body to be returned.
     *              (default -1)
     * @param output An optional list to append results to, if left as null
     *               then a new list is created.
     * @return A list of the interacting bodies up to
     *         the given graph depth.</haxe_doc>
		</interactingBodies>
		<connectedBodies public="1" set="method" line="1224">
			<f a="?depth:?output">
				<x path="Int"/>
				<c path="nape.phys.BodyList"/>
				<c path="nape.phys.BodyList"/>
			</f>
			<haxe_doc><![CDATA[* Compute set of bodies connected via constraints.
     * <br/><br/>
     * Only constraints that are inside of a Space will be considered the
     * same way that the body's constraints list only tracks constraints
     * that are part of a simulation.
     *
     * @param depth Control the depth limit of the graph search. Negative
     *              values indicate an unlimited search. A depth value of
     *              0 would cause only the current Body to be returned.
     *              (default -1)
     * @param output An optional list to append results to, if left as null
     *               then a new list is created.
     * @return A list of the connected bodies up to
     *         the given graph depth.]]></haxe_doc>
		</connectedBodies>
		<set_inertia get="inline" set="null" line="1190"><f a="inertia">
	<x path="Float"/>
	<x path="Float"/>
</f></set_inertia>
		<get_inertia get="inline" set="null" line="1180"><f a=""><x path="Float"/></f></get_inertia>
		<inertia public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Moment of inertia of this Body.
     * <br/><br/>
     * Setting this value will implicitly change the inertiaMode to FIXED.]]></haxe_doc>
		</inertia>
		<get_constraintInertia get="inline" set="null" line="1169"><f a=""><x path="Float"/></f></get_constraintInertia>
		<constraintInertia public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Moment of inertia to be used in user defined Constraints.
     * <br/><br/>
     * This value is equal to the inverse inertia of the Body taking into account
     * Body type (Static and Kinematic bodies will have constraintInertia of 0).
     * As well as properties like allowRotation.]]></haxe_doc>
		</constraintInertia>
		<set_inertiaMode get="inline" set="null" line="1146"><f a="inertiaMode">
	<c path="nape.phys.InertiaMode"/>
	<c path="nape.phys.InertiaMode"/>
</f></set_inertiaMode>
		<get_inertiaMode get="inline" set="null" line="1143"><f a=""><c path="nape.phys.InertiaMode"/></f></get_inertiaMode>
		<inertiaMode public="1" get="accessor" set="accessor">
			<c path="nape.phys.InertiaMode"/>
			<haxe_doc><![CDATA[* Method of computing Body moment of inertia.
     * <br/><br/>
     * This value will be set implicitly by modifying Body inertia property.
     *
     * @default InertiaMode.DEFAULT]]></haxe_doc>
		</inertiaMode>
		<set_gravMassScale get="inline" set="null" line="1119"><f a="gravMassScale">
	<x path="Float"/>
	<x path="Float"/>
</f></set_gravMassScale>
		<get_gravMassScale get="inline" set="null" line="1110"><f a=""><x path="Float"/></f></get_gravMassScale>
		<gravMassScale public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Mass scale used in computation of gravity for Body in Space.
     * <br/><br/>
     * Setting this value will implicitly change the gravMassMode to SCALED.
     * <br/>
     * When set, the gravMass of Body will be computed as this scaling factor
     * multiplied with the Body's mass.]]></haxe_doc>
		</gravMassScale>
		<set_gravMass get="inline" set="null" line="1085"><f a="gravMass">
	<x path="Float"/>
	<x path="Float"/>
</f></set_gravMass>
		<get_gravMass get="inline" set="null" line="1073"><f a=""><x path="Float"/></f></get_gravMass>
		<gravMass public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Mass used in gravity computations in a Space.
     * <br/><br/>
     * Setting this value will implicitly change the gravMassMode to FIXED.
     * <br/>
     * Set to 0 to disable gravity for this Body.]]></haxe_doc>
		</gravMass>
		<set_gravMassMode get="inline" set="null" line="1050"><f a="gravMassMode">
	<c path="nape.phys.GravMassMode"/>
	<c path="nape.phys.GravMassMode"/>
</f></set_gravMassMode>
		<get_gravMassMode get="inline" set="null" line="1047"><f a=""><c path="nape.phys.GravMassMode"/></f></get_gravMassMode>
		<gravMassMode public="1" get="accessor" set="accessor">
			<c path="nape.phys.GravMassMode"/>
			<haxe_doc><![CDATA[* Method of computing mass as seen by gravity.
     * <br/><br/>
     * This value will be implicitly set by modifying gravMass or gravMassScale properties.
     *
     * @default GravMassMode.DEFAULT]]></haxe_doc>
		</gravMassMode>
		<set_mass get="inline" set="null" line="1021"><f a="mass">
	<x path="Float"/>
	<x path="Float"/>
</f></set_mass>
		<get_mass get="inline" set="null" line="1011"><f a=""><x path="Float"/></f></get_mass>
		<mass public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Mass of the Body.
     * <br/><br/>
     * This value is computed by default based on the Body's Shape's areas and
     * Material densities.
     * <br/>
     * When massMode is DEFAULT, accessing this value for an empty Body will thus
     * give an error as the value is undefined.
     * <br/><br/>
     * Setting this value will permit you to give a fixed mass to the Body
     * implicitly changing the massMode to MassMode.FIXED]]></haxe_doc>
		</mass>
		<get_constraintMass get="inline" set="null" line="993"><f a=""><x path="Float"/></f></get_constraintMass>
		<constraintMass public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Mass to be used for a Body in User built constraints.
     * <br/><br/>
     * This value is given as the inverse mass of the Body taking into account
     * Body type (Static and Kinematic Bodies will have constraintMass of 0)
     * as well as properties like allowMovement.]]></haxe_doc>
		</constraintMass>
		<set_massMode get="inline" set="null" line="970"><f a="massMode">
	<c path="nape.phys.MassMode"/>
	<c path="nape.phys.MassMode"/>
</f></set_massMode>
		<get_massMode get="inline" set="null" line="967"><f a=""><c path="nape.phys.MassMode"/></f></get_massMode>
		<massMode public="1" get="accessor" set="accessor">
			<c path="nape.phys.MassMode"/>
			<haxe_doc><![CDATA[* Method of mass computation for Body.
     * <br/><br/>
     * This value will be set implicitly to FIXED when mass property is set.
     * <br/>Setting back to DEFAULT will then set mass implicitly back to the default
     * computed mass.
     *
     * @default MassMode.DEFAULT]]></haxe_doc>
		</massMode>
		<set_allowRotation get="inline" set="null" line="946"><f a="allowRotation">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_allowRotation>
		<get_allowRotation get="inline" set="null" line="943"><f a=""><x path="Bool"/></f></get_allowRotation>
		<allowRotation public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Whether dynamic Body is permitted to be rotated by physics.
     * <br/><br/>
     * When this field is false, no physics will be able to cause a change in the
     * bodies angular velocity (It can still rotate, but only if you tell it to like
     * a kinematic body).
     *
     * @default true]]></haxe_doc>
		</allowRotation>
		<set_allowMovement get="inline" set="null" line="922"><f a="allowMovement">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_allowMovement>
		<get_allowMovement get="inline" set="null" line="919"><f a=""><x path="Bool"/></f></get_allowMovement>
		<allowMovement public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Whether dynamic Body is permitted to be moved by physics linearly.
     * <br/><br/>
     * When this field is false, no physics will be able to cause a change in the
     * bodies linear velocity (It can still move, but only if you tell it to like
     * a kinematic body).
     *
     * @default true]]></haxe_doc>
		</allowMovement>
		<get_bounds get="inline" set="null" line="902"><f a=""><c path="nape.geom.AABB"/></f></get_bounds>
		<bounds public="1" get="accessor" set="null">
			<c path="nape.geom.AABB"/>
			<haxe_doc><![CDATA[* Bounding box of Body in world space.
     * <br/><br/>
     * This value can be accessed even if there are no Shapes in the Body, but
     * attempting to query its values whilst there are no Shapes will result
     * in a debug build error.
     * <br/><br/>
     * This AABB is immutable.]]></haxe_doc>
		</bounds>
		<set_torque get="inline" set="null" line="873"><f a="torque">
	<x path="Float"/>
	<x path="Float"/>
</f></set_torque>
		<get_torque get="inline" set="null" line="870"><f a=""><x path="Float"/></f></get_torque>
		<torque public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Accumulated torque acting on body in px.px.kg/s/s
     * <br/><br/>
     * This value is not used internally for any physics computations.
     * <br/><br/>
     * You may set this property only on dynamic bodies.
     *
     * @default 0]]></haxe_doc>
		</torque>
		<set_kinAngVel get="inline" set="null" line="844"><f a="kinAngVel">
	<x path="Float"/>
	<x path="Float"/>
</f></set_kinAngVel>
		<get_kinAngVel get="inline" set="null" line="841"><f a=""><x path="Float"/></f></get_kinAngVel>
		<kinAngVel public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Additional kinematic angular velocity of Body in rad/s.
     * <br/><br/>
     * A bodies 'kinematic' velocity is an added velocity bias used in all physics
     * computations but that will not effect how the Body moves directly.
     * <br/><br/>
     * Even a static body can be given a kinematic velocity, and can be used for
     * such things as giving a body of water a fluid-velocity for fluid drag
     * computations.
     *
     * @default 0]]></haxe_doc>
		</kinAngVel>
		<set_angularVel get="inline" set="null" line="809"><f a="angularVel">
	<x path="Float"/>
	<x path="Float"/>
</f></set_angularVel>
		<get_angularVel get="inline" set="null" line="806"><f a=""><x path="Float"/></f></get_angularVel>
		<angularVel public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Angular velocity of Body in clockwise rad/s
     * <br/><br/>
     * A static body cannot have its angular velocity set.
     *
     * @default 0]]></haxe_doc>
		</angularVel>
		<set_rotation get="inline" set="null" line="777"><f a="rotation">
	<x path="Float"/>
	<x path="Float"/>
</f></set_rotation>
		<get_rotation get="inline" set="null" line="774"><f a=""><x path="Float"/></f></get_rotation>
		<rotation public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Rotation of Body in clockwise rad.
     * <br/><br/>
     * Attempting to set this value on a static Body that is in a Space will result
     * in a debug build error.
     * <br/><br/>
     * Please note that for kinematic objects, setting this value is equiavalent
     * to 'teleporting' the object, and for normal movement you should be using
     * the kinematic body's angularVel.
     *
     * @default 0]]></haxe_doc>
		</rotation>
		<get_constraintVelocity get="inline" set="null" line="756"><f a=""><c path="nape.geom.Vec3"/></f></get_constraintVelocity>
		<constraintVelocity public="1" get="accessor" set="null">
			<c path="nape.geom.Vec3"/>
			<haxe_doc><![CDATA[* This property represents the velocity seen by constraint physics.
     * <br/><br/>
     * You should not need to use this property unless writing your own
     * constraints using the UserConstraint API.]]></haxe_doc>
		</constraintVelocity>
		<set_force get="inline" set="null" line="734"><f a="force">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_force>
		<get_force get="inline" set="null" line="730"><f a=""><c path="nape.geom.Vec2"/></f></get_force>
		<force public="1" get="accessor" set="accessor">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* Accumulated force acting on body in px.kg/s/s
     * <br/><br/>
     * This value is not used internally for any physics computations.
     * <br/><br/>
     * You may set this property only on dynamic bodies.
     *
     * @default (0,0)]]></haxe_doc>
		</force>
		<set_surfaceVel get="inline" set="null" line="705"><f a="surfaceVel">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_surfaceVel>
		<get_surfaceVel get="inline" set="null" line="701"><f a=""><c path="nape.geom.Vec2"/></f></get_surfaceVel>
		<surfaceVel public="1" get="accessor" set="accessor">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* Additional surface velocity for Body in px/s.
     * <br/><br/>
     * A bodies 'surface' velocity is an added velocity bias that is rotated to match
     * the angle of the contact surface used in contact physics and will not
     * effect how the Body moves directly.
     * <br/><br/>
     * Even a static body can be given a surface velocity, and can be used for
     * such things as conveyor belts (By setting the x-component of surfaceVel).
     *
     * @default (0,0)]]></haxe_doc>
		</surfaceVel>
		<set_kinematicVel get="inline" set="null" line="673"><f a="kinematicVel">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_kinematicVel>
		<get_kinematicVel get="inline" set="null" line="669"><f a=""><c path="nape.geom.Vec2"/></f></get_kinematicVel>
		<kinematicVel public="1" get="accessor" set="accessor">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* Additional kinematic velocity of Body in px/s.
     * <br/><br/>
     * A bodies 'kinematic' velocity is an added velocity bias used in all physics
     * computations but that will not effect how the Body moves directly.
     * <br/><br/>
     * Even a static body can be given a kinematic velocity, and can be used for
     * such things as giving a body of water a fluid-velocity for fluid drag
     * computations.
     *
     * @default (0,0)]]></haxe_doc>
		</kinematicVel>
		<setVelocityFromTarget public="1" set="method" line="629">
			<f a="targetPosition:targetRotation:deltaTime">
				<c path="nape.geom.Vec2"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="nape.phys.Body"/>
			</f>
			<haxe_doc><![CDATA[* Set velocities to achieve desired position at end of time step.
     * <br/><br/>
     * This function is a utility to help with animating kinematic bodies.
     * Kinematic bodies should be moved through velocity, but it is often
     * easier to think in terms of position.
     * <br/><br/>
     * This method will set linear and angular velocities so that the target
     * position/rotation is achieved at end of time step.
     *
     * @param targetPosition The target position for Body.
     * @param targetRotation The target rotation for Body.
     * @param deltaTime The time step for next call to space.step().
     * @throws # If targetPosition is null or disposed of.
     * @returns A reference to 'this' Body.]]></haxe_doc>
		</setVelocityFromTarget>
		<set_velocity get="inline" set="null" line="598"><f a="velocity">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_velocity>
		<get_velocity get="inline" set="null" line="594"><f a=""><c path="nape.geom.Vec2"/></f></get_velocity>
		<velocity public="1" get="accessor" set="accessor">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* Linear velocity of Body's origin in px/s.
     * <br/><br/>
     * This value can be set and is equivalent to: <code>this.velocity.set(value)</code>
     * <br/><br/>
     * A static body cannot have its velocity set.
     *
     * @default (0,0)]]></haxe_doc>
		</velocity>
		<set_position get="inline" set="null" line="569"><f a="position">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_position>
		<get_position get="inline" set="null" line="565"><f a=""><c path="nape.geom.Vec2"/></f></get_position>
		<position public="1" get="accessor" set="accessor">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* Position of Body's origin in px.
     * <br/><br/>
     * This value can be set and is equivalent to: <code>this.position.set(value)</code>
     * <br/><br/>
     * Attempting to set this value on a static Body that is in a Space will result
     * in a debug build error.
     * <br/><br/>
     * Please note that for kinematic objects, setting this value is equiavalent
     * to 'teleporting' the object, and for normal movement you should be using
     * the kinematic body's velocity.
     *
     * @default (0,0)]]></haxe_doc>
		</position>
		<copy public="1" set="method" line="543">
			<f a=""><c path="nape.phys.Body"/></f>
			<haxe_doc><![CDATA[* Construct an exact copy of this Body.
     * <br/><br/>
     * All properties will be exactly copied, with Shapes also
     * being copied with the copied Body's and Shape's userData
     * objects being assigned the same fields as the existing ones with
     * values copied over by reference for object types.
     *
     * @return A copy of this Body.]]></haxe_doc>
		</copy>
		<get_constraints get="inline" set="null" line="443"><f a=""><c path="nape.constraint.ConstraintList"/></f></get_constraints>
		<constraints public="1" get="accessor" set="null">
			<c path="nape.constraint.ConstraintList"/>
			<haxe_doc><![CDATA[* Set of constraints using this Body.
     * <br/><br/>
     * This list contains those constraints that are inside of a Space only.
     * <br/><br/>
     * This list is immutable.]]></haxe_doc>
		</constraints>
		<get_isSleeping get="inline" set="null" line="428"><f a=""><x path="Bool"/></f></get_isSleeping>
		<isSleeping public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Whether this body is sleeping.
     * <br/><br/>
     * This value is immutable, In Nape you do not ever need to manually wake up a Body.
     * It will always be done automatically without error.
     * <br/><br/>
     * To manually put a Body to sleep is against the very nature of Nape API
     * and so is excluded from the core of Nape. If you really want to do this
     * then you should make use of the nape-hacks module.]]></haxe_doc>
		</isSleeping>
		<get_arbiters get="inline" set="null" line="412"><f a=""><c path="nape.dynamics.ArbiterList"/></f></get_arbiters>
		<arbiters public="1" get="accessor" set="null">
			<c path="nape.dynamics.ArbiterList"/>
			<haxe_doc><![CDATA[* Set of active arbiters related to this Body.
     * <br/><br/>
     * This list is immutable.]]></haxe_doc>
		</arbiters>
		<set_space get="inline" set="null" line="388"><f a="space">
	<t path="Null"><c path="nape.space.Space"/></t>
	<t path="Null"><c path="nape.space.Space"/></t>
</f></set_space>
		<get_space get="inline" set="null" line="385"><f a=""><t path="Null"><c path="nape.space.Space"/></t></f></get_space>
		<space public="1" get="accessor" set="accessor">
			<t path="Null"><c path="nape.space.Space"/></t>
			<haxe_doc><![CDATA[* Space this Body is assigned to.
     * <br/><br/>
     * When this Body is part of a Compound, this value is immutable.
     * <br/>
     * When a Body is part of a Compound it is owned by that Compound and it
     * is the Compound that is added/removed from a Space.]]></haxe_doc>
		</space>
		<set_compound get="inline" set="null" line="366"><f a="compound">
	<t path="Null"><c path="nape.phys.Compound"/></t>
	<t path="Null"><c path="nape.phys.Compound"/></t>
</f></set_compound>
		<get_compound get="inline" set="null" line="363"><f a=""><t path="Null"><c path="nape.phys.Compound"/></t></f></get_compound>
		<compound public="1" get="accessor" set="accessor">
			<t path="Null"><c path="nape.phys.Compound"/></t>
			<haxe_doc><![CDATA[* Compound this Body belongs to.
     * <br/><br/>
     * If this Body belongs to a Compound, then the Compound 'owns' this Body and
     * it is the Compound which would be added/removed from a Space rather than
     * this Body.
     *
     * @default null]]></haxe_doc>
		</compound>
		<get_shapes get="inline" set="null" line="349"><f a=""><c path="nape.shape.ShapeList"/></f></get_shapes>
		<shapes public="1" get="accessor" set="null">
			<c path="nape.shape.ShapeList"/>
			<haxe_doc><![CDATA[* List of shapes owned by Body.
     * <br/><br/>
     * Appending a Shape to this list is equivalent to <code>shape.body = this</code>
     *
     * @default []]]></haxe_doc>
		</shapes>
		<isKinematic public="1" get="inline" set="null" line="337">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[* Fast equivalent to <code>body.type == BodyType.KINEMATIC</code>
     * @return True if body is Kinematic.]]></haxe_doc>
		</isKinematic>
		<isDynamic public="1" get="inline" set="null" line="328">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[* Fast equivalent to <code>body.type == BodyType.DYNAMIC</code>
     * @return True if body is Dynamic.]]></haxe_doc>
		</isDynamic>
		<isStatic public="1" get="inline" set="null" line="319">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[* Fast equivalent to <code>body.type == BodyType.STATIC</code>
     * @return True if body is Static.]]></haxe_doc>
		</isStatic>
		<integrate public="1" set="method" line="295">
			<f a="deltaTime">
				<x path="Float"/>
				<c path="nape.phys.Body"/>
			</f>
			<haxe_doc>* Integrate body forward in time, taking only velocities into account.
     *
     * @param deltaTime The time to integrate body by. This value may be negative to
     *                  integrate back in time.
     * @return A refernce to 'this' Body</haxe_doc>
		</integrate>
		<set_disableCCD get="inline" set="null" line="281"><f a="disableCCD">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_disableCCD>
		<get_disableCCD get="inline" set="null" line="278"><f a=""><x path="Bool"/></f></get_disableCCD>
		<disableCCD public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Declare object should never be collided continuously
     * <br/><br/>
     * When performing continuous collisions, Nape will check both Bodies to see
     * if either has opted-out of CCD. If either Body has this flag true, then
     * no CCD will be performed for that pair.
     * @default false]]></haxe_doc>
		</disableCCD>
		<set_isBullet get="inline" set="null" line="262"><f a="isBullet">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_isBullet>
		<get_isBullet get="inline" set="null" line="259"><f a=""><x path="Bool"/></f></get_isBullet>
		<isBullet public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Mark object for continuous collisions against other dynamic Bodies
     * <br/><br/>
     * If true, then this Body will undergo continuous collisions with other
     * dynamic Bodies. This flag has no effect for non-dynamic Bodies.
     * <br/><br/>
     * This flag should only be set for very fast, small moving dynamic bodies,
     * and due to the way continuous collisions are resolved it is not wise to
     * enable this for a large group of bodies that interact together as it
     * will lead to visual stalling.
     * <br/>
     * Bullets also do not play well when existing in a group with respect to
     * continuous collisions against kinematic objects and may cause
     * tunnelling against the kinematic.
     * @default false]]></haxe_doc>
		</isBullet>
		<set_type get="inline" set="null" line="200"><f a="type">
	<c path="nape.phys.BodyType"/>
	<c path="nape.phys.BodyType"/>
</f></set_type>
		<get_type get="inline" set="null" line="197"><f a=""><c path="nape.phys.BodyType"/></f></get_type>
		<type public="1" get="accessor" set="accessor">
			<c path="nape.phys.BodyType"/>
			<haxe_doc><![CDATA[* Type of body.
     * <br/><br/>
     * This value can be changed even if Body is inside of a Space.]]></haxe_doc>
		</type>
		<debugDraw public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Set to disable debug drawing/
     * <br/><br/>
     * When true, this Body will not be drawn during debug draw operations
     * unless specifically given as argument to Debug draw() method.
     * @default true]]></haxe_doc>
		</debugDraw>
		<zpp_inner public="1">
			<c path="zpp_nape.phys.ZPP_Body"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="457">
			<f a="?type:?position">
				<c path="nape.phys.BodyType"/>
				<c path="nape.geom.Vec2"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Construct a new Body.
     * <br/><br/>
     * @param type The type of Body to create. (default DYNAMIC)
     * @param position The initial position for object. (default &#40;0,0&#41;)
     * @return The newly constructed Body.
     * @throws # If position is non-null, and has been disposed of.]]></haxe_doc>
		</new>
		<haxe_doc>* Class representing a physics Rigid Body.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.phys.BodyIterator" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/phys/BodyIterator.hx">
		<zpp_pool public="1" line="194" static="1">
			<c path="nape.phys.BodyIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_pool>
		<get public="1" set="method" line="217" static="1">
			<f a="list">
				<c path="nape.phys.BodyList"/>
				<c path="nape.phys.BodyIterator"/>
			</f>
			<haxe_doc><![CDATA[* Create iterator for Nape list.
     * <br/><br/>
     * There is no specific reason to use this over: <code>list.iterator()</code>
     * especcialy since this requires writing the class name :)
     * (This function is used internally)
     *
     * @param list The Nape list to create iterator for.
     * @return     An iterator over the Nape list.]]></haxe_doc>
		</get>
		<next public="1" get="inline" set="null" line="264">
			<f a=""><c path="nape.phys.Body"/></f>
			<haxe_doc>* Return next element in list.
     *
     * @return The next element in iteration.</haxe_doc>
		</next>
		<hasNext public="1" get="inline" set="null" line="240">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Check if there are any elements remaining.
     *
     * @return True if there are more elements to iterator over.</haxe_doc>
		</hasNext>
		<zpp_next public="1">
			<c path="nape.phys.BodyIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_next>
		<zpp_critical public="1">
			<x path="Bool"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_critical>
		<zpp_i public="1">
			<x path="Int"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_i>
		<zpp_inner public="1">
			<c path="nape.phys.BodyList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="202">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Haxe Iterator<T> compatible iterator over Nape list.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.phys.BodyList" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/phys/BodyList.hx">
		<fromArray public="1" set="method" line="304" static="1">
			<f a="array">
				<c path="Array"><c path="nape.phys.Body"/></c>
				<c path="nape.phys.BodyList"/>
			</f>
			<haxe_doc>* Convert standard Array to Nape list.
     *
     * @param array The array to be converted
     * @return An equivalent Nape list.
     * @throws If array argument is null.
     * @throws If array contains elements of type other than Body</haxe_doc>
		</fromArray>
		<filter public="1" set="method" line="779">
			<f a="lambda">
				<f a="">
					<c path="nape.phys.Body"/>
					<x path="Bool"/>
				</f>
				<c path="nape.phys.BodyList"/>
			</f>
			<haxe_doc><![CDATA[* Iterate over list filtering elements.
     * <br/><br/>
     * The given function will be applied to each element, whenever the
     * function returns false, the element will be removed from the list.
     * <br/><br/>
     * Any exception thrown by the supplied function will be treat as a
     * signal to halt iteration acting as a 'break' statement.
     * <br/><br/>
     * This method is to be greatly preferred for filtering logic as
     * it is otherwise unsafe to modify the list during an iteration.
     * <br/><br/>
     * An example of using this method to clean up a list whilst performing
     * actions on the elements.
     * <pre>
     * list.filter(function (obj) {
     *    // perform clean up with obj
     *    return false; // remove from list.
     * });
     * </pre>
     *
     * @param lambda The function to apply to each argument, deciding if
     *               element should be removed.
     * @return A reference to 'this' list.
     * @throws # If lambda argument is null.]]></haxe_doc>
		</filter>
		<foreach public="1" get="inline" set="null" line="732">
			<f a="lambda">
				<f a="">
					<c path="nape.phys.Body"/>
					<x path="Void"/>
				</f>
				<c path="nape.phys.BodyList"/>
			</f>
			<haxe_doc><![CDATA[* Iterate over list applying function.
     * <br/><br/>
     * Any exception thrown by the supplied function will be treat as a
     * signal to halt iteration acting as a 'break' statement.
     * <br/><br/>
     * This method should be preferred to using standard haxe iteration
     * as there will be no allocation of an iterator object.
     * <pre>
     * list.foreach(function (obj) {
     *     if (ignore_object(obj)) return; //acts as a 'continue' statement
     *     if (halt_iteration(obj)) throw "": //acts as a 'break' statement
     * });
     * </pre>
     *
     * @param lambda The function to apply to each argument.
     * @return A reference to 'this' list.
     * @throws # If lambda argument is null.]]></haxe_doc>
		</foreach>
		<toString public="1" set="method" line="702">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<merge public="1" set="method" line="684">
			<f a="xs">
				<c path="nape.phys.BodyList"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Merge given list into this one.
     * <br/><br/>
     * The result is that this list will have all objects from the argument
     * that were not already in the list inserted. You should make no
     * assumption about the order of these insertions.
     *
     * @param xs The list to merge.
     * @throws # If xs argument is null.]]></haxe_doc>
		</merge>
		<copy public="1" set="method" line="662">
			<f a="?deep">
				<x path="Bool"/>
				<c path="nape.phys.BodyList"/>
			</f>
			<haxe_doc>* Produce a possibly deep copy of list.
     *
     * @param deep If true, then each element will have its own copy
     *             function called instead of simply having its
     *             reference copied over.
     * @return     The copied list.</haxe_doc>
		</copy>
		<iterator public="1" get="inline" set="null" line="647">
			<f a=""><c path="nape.phys.BodyIterator"/></f>
			<haxe_doc><![CDATA[* Return Haxe iterator for list.
     * <br/><br/>
     * Use of this iterator, whilst stylistically better in Haxe should not
     * be used, in preference for use of the foreach function which will
     * not require allocation of an iterator object.
     * <br/><br/>
     * Equally in AS3, the foreach method should be the preferred way to iterate.]]></haxe_doc>
		</iterator>
		<empty public="1" get="inline" set="null" line="631">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Test if list is empty or not.
     *
     * @return True if list is empty.</haxe_doc>
		</empty>
		<clear public="1" set="method" line="614">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clear the list, removing all elements.
     *
     * @throws # If list is iummutable</haxe_doc>
		</clear>
		<remove public="1" set="method" line="576">
			<f a="obj">
				<c path="nape.phys.Body"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Remove element from list.
     * <br/><br/>
     * This is a linear time operation.
     *
     * @param obj The object to remove
     * @return True if object was removed from list.
     * @throws # If list is immutable]]></haxe_doc>
		</remove>
		<add public="1" get="inline" set="null" line="563">
			<f a="obj">
				<c path="nape.phys.Body"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Insert element into list in most effecient way.
     * <br/><br/>
     * This method will defer to either the push or unshift function
     * depending on which is most effecient in the context.
     * <br/><br/>
     * If order of elements is not important then you should always use
     * this function to insert elements.
     *
     * @param obj The object to insert.
     * @return True if object was successfuly inserted.
     * @throws # If list is immutable]]></haxe_doc>
		</add>
		<shift public="1" set="method" line="519">
			<f a=""><c path="nape.phys.Body"/></f>
			<haxe_doc><![CDATA[* Pop element from front of list.
     * <br/><br/>
     * If you are wanting to clear a list, whilst operating on its elements,
     * consider use of the filter method instead.
     *
     * @returns The element removed from list.
     * @throws # If list is immutable.
     * @throws # If the list is empty.]]></haxe_doc>
		</shift>
		<pop public="1" set="method" line="478">
			<f a=""><c path="nape.phys.Body"/></f>
			<haxe_doc><![CDATA[* Pop element from back of list.
     * <br/><br/>
     * If you are wanting to clear a list, whilst operating on its elements,
     * consider use of the filter method instead.
     *
     * @returns The element removed from list.
     * @throws # If list is immutable.
     * @throws # If the list is empty.]]></haxe_doc>
		</pop>
		<unshift public="1" set="method" line="447">
			<f a="obj">
				<c path="nape.phys.Body"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Push element to front of list.
     * <br/><br/>
     * When the order of objects is not important, it is best to use the
     * add() method instead.
     *
     * @param obj The object to insert.
     * @returns True if object was successively inserted.
     * @throws # If list is immutable.]]></haxe_doc>
		</unshift>
		<push public="1" set="method" line="416">
			<f a="obj">
				<c path="nape.phys.Body"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Push element to back of list.
     * <br/><br/>
     * When the order of objects is not important, it is best to use the
     * add() method instead.
     *
     * @param obj The object to insert.
     * @returns True if object was successively inserted.
     * @throws # If list is immutable.]]></haxe_doc>
		</push>
		<at public="1" set="method" line="363">
			<f a="index">
				<x path="Int"/>
				<c path="nape.phys.Body"/>
			</f>
			<haxe_doc><![CDATA[* Random access to elements of list by index.
     * <br/><br/>
     * Under normal circumstances, accessing succesive elements via this
     * method will occur in constant time.
     *
     * @param index The index of the element in list to access.
     * @returns The element at the given index.
     * @throws # If index is out of bounds.]]></haxe_doc>
		</at>
		<has public="1" set="method" line="346">
			<f a="obj">
				<c path="nape.phys.Body"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if element is already in the list
     *
     * @param obj The object to test.
     * @return True if object is in the list.</haxe_doc>
		</has>
		<get_length get="inline" set="null" line="244"><f a=""><x path="Int"/></f></get_length>
		<length public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Length of list.</haxe_doc>
		</length>
		<zpp_inner public="1">
			<c path="zpp_nape.util.ZPP_BodyList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="695">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Construct a new list.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Nape list of Body type objects
 * <br/><br/>
 * Internally this list is at present implemented as a linked list with
 * object pooled nodes and iterators with various fast paths made for
 * standard access patterns (For instance accessing successive elements
 * runs in constant time when using random access functions)
 * <br/><br/>
 * Iteration of this list can be done in various ways, but the preferred
 * way on all targets, is through use of the foreach function:
 * <pre>
 * list.foreach(function (obj) {
 * });
 * </pre>
 * This method is inlined so that in haxe no closure will need to be created.
 * <br/><br/>
 * In AS3, a closure would need to be created in general, so for performance
 * reasons you 'may' choose to use iteration as follows:
 * <pre>
 * for (var i:int = 0; i < list.length; i++) {
 *     var obj:Body = list.at(i);
 * }
 * </pre>
 * <br/>
 * NOTE: It is 'not' safe to modify a list whilst iterating over it.
 * If you wish to remove elements during an iteration you should use the
 * filter method, for example:
 * <pre>
 * list.filter(function (obj) {
 *     // operate on object.
 *     // ...
 *     return (false if you want object to be removed);
 * });
 * </pre>
 * <br/><br/>
 * In AS3, if you wish to avoid a closure generation, you can perform such
 * an iteration in a safe manner as follows:
 * <pre>
 * var i:int = 0;
 * while (i < list.length) {
 *     var obj:Body = list.at(i);
 *     // operate on object.
 *     // ...
 *     if (should remove obj) {
 *         list.remove(obj);
 *         continue;
 *     }
 *     else i++;
 * }
 * </pre>
 * Or if you are always clearing the list entirely you could write:
 * <pre>
 * while (!list.empty()) {
 *     var obj:Body = list.pop();
 *     // operate on object.
 *     // ...
 * }
 * </pre>]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.phys.BodyType" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/phys/BodyType.hx">
		<STATIC public="1" get="accessor" set="null" static="1">
			<c path="nape.phys.BodyType"/>
			<haxe_doc>* Static objects are not permitted to move, and due to this several
     * optimisatinos can be made for them.</haxe_doc>
		</STATIC>
		<get_STATIC get="inline" set="null" line="203" static="1"><f a=""><c path="nape.phys.BodyType"/></f></get_STATIC>
		<DYNAMIC public="1" get="accessor" set="null" static="1">
			<c path="nape.phys.BodyType"/>
			<haxe_doc>* Standard dynamic object, this object will be effected by the physics
     * as usual.</haxe_doc>
		</DYNAMIC>
		<get_DYNAMIC get="inline" set="null" line="217" static="1"><f a=""><c path="nape.phys.BodyType"/></f></get_DYNAMIC>
		<KINEMATIC public="1" get="accessor" set="null" static="1">
			<c path="nape.phys.BodyType"/>
			<haxe_doc>* Kinematic objects are static objects which 'are' permitted to move,
     * you have complete control over their velocity to make them move how
     * you wish and are not effected by any physics.</haxe_doc>
		</KINEMATIC>
		<get_KINEMATIC get="inline" set="null" line="232" static="1"><f a=""><c path="nape.phys.BodyType"/></f></get_KINEMATIC>
		<toString public="1" set="method" line="189">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<new public="1" set="method" line="181">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc>* Enumeration of rigid body types.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.phys.Compound" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/phys/Compound.hx">
		<extends path="nape.phys.Interactor"/>
		<rotate public="1" set="method" line="463">
			<f a="centre:angle">
				<c path="nape.geom.Vec2"/>
				<x path="Float"/>
				<c path="nape.phys.Compound"/>
			</f>
			<haxe_doc><![CDATA[* Rotate entire compound about a point.
     * <br/><br/>
     * This is equivalent to: <code>compound.visitBodies(function (b) b.rotate(centre, angle))</code>
     *
     * @param centre The centre of rotation in world coordinates.
     * @param angle The clockwise angle of rotation in radians.
     * @return A reference to this Compound.
     * @throws # If centre is null or disposed of.
     * @throws # If any Body in the compound is static, and this compound is in a Space.]]></haxe_doc>
		</rotate>
		<translate public="1" set="method" line="426">
			<f a="translation">
				<c path="nape.geom.Vec2"/>
				<c path="nape.phys.Compound"/>
			</f>
			<haxe_doc><![CDATA[* Translate entire compound.
     * <br/><br/>
     * This is equivalent to: <code>compound.visitBodies(function (b) b.translate(translation))</code>
     *
     * @param translation The translation to apply to the Compound.
     * @return A reference to this Compound.
     * @throws # If translation is null or disposed of.
     * @throws # If any Body in the compound is static, and this compound is in a Space.]]></haxe_doc>
		</translate>
		<COM public="1" set="method" line="401">
			<f a="?weak">
				<x path="Bool"/>
				<c path="nape.geom.Vec2"/>
			</f>
			<haxe_doc>* Compute centre of mass of Compound.
     *
     * @param weak If true, the returned Vec2 will be automatically released
     *             to the object pool when passed as an argument to a Nape
     *             function. (default false)
     * @return The centre of mass of compound.
     * @throws # If Compound has no Bodies contained directly or indirectly
     *           that contain at least one Shape.</haxe_doc>
		</COM>
		<visitCompounds public="1" set="method" line="382">
			<f a="lambda">
				<f a="">
					<c path="nape.phys.Compound"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Method to iterate over all compounds contained directly or indirectly by
     * this Compound.
     *
     * @param lambda The method to apply to each Compound.
     * @throws # If lambda is null.</haxe_doc>
		</visitCompounds>
		<visitConstraints public="1" set="method" line="368">
			<f a="lambda">
				<f a="">
					<c path="nape.constraint.Constraint"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Method to iterate over all constraints contained directly or indirectly by
     * this Compound.
     *
     * @param lambda The method to apply to each Constraint.
     * @throws # If lambda is null.</haxe_doc>
		</visitConstraints>
		<visitBodies public="1" set="method" line="354">
			<f a="lambda">
				<f a="">
					<c path="nape.phys.Body"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Method to iterate over all bodies contained directly or indirectly by
     * this Compound.
     *
     * @param lambda The method to apply to each Body.
     * @throws # If lambda is null.</haxe_doc>
		</visitBodies>
		<breakApart public="1" set="method" line="344">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Breaking compound apart in-place.
     * <br/><br/>
     * This method will destroy the compound, moving all of it's components
     * to the assigned Space if this is the root compound, otherwise to the
     * parent compound.
     * <br/><br/>
     * Apart from being easier than doing this manually it also means that we
     * do not have to temporarigly remove objects from the space meaning that
     * things like PreListener ignored interactions will be unaffected.]]></haxe_doc>
		</breakApart>
		<copy public="1" set="method" line="330">
			<f a=""><c path="nape.phys.Compound"/></f>
			<haxe_doc><![CDATA[* Produce an exact copy of this Compound.
     * <br/><br/>
     * This copy will remap owned constraints so that their body properties
     * refer to the newly copied bodies also owned by this compound.
     * <br/><br/>
     * If this compound tree contains any constraints that make references
     * to outside of this compound; then these properties will be made null.
     * <pre>
     *       ____Cmp1____               [Cmp2.copy()]
     *      /    /        &#92;
     * Body1 Body2___     Cmp2        null    Cmp2'
     *   |     |     &#92;     /  &#92;         &#92;    /    &#92;
     * Shp1  Shp2     Joint--Body3       Joint'--Body3'
     *                         |                   |
     *                        Shp3               Shp3'
     * </pre>
     * For instance if copying Cmp1 then all is well, but if we copy Cmp2 the
     * copied Joint will have one of it's body references null as that body is
     * not owned directly, or indirectly by the compound.]]></haxe_doc>
		</copy>
		<toString public="1" set="method" line="306" override="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<set_space get="inline" set="null" line="269"><f a="space">
	<t path="Null"><c path="nape.space.Space"/></t>
	<t path="Null"><c path="nape.space.Space"/></t>
</f></set_space>
		<get_space get="inline" set="null" line="266"><f a=""><t path="Null"><c path="nape.space.Space"/></t></f></get_space>
		<space public="1" get="accessor" set="accessor">
			<t path="Null"><c path="nape.space.Space"/></t>
			<haxe_doc><![CDATA[* Space this compound belongs to.
     * <br/><br/>
     * This value is immutable when this compound belongs to another parent Compound.
     *
     * @default null]]></haxe_doc>
		</space>
		<set_compound get="inline" set="null" line="247"><f a="compound">
	<t path="Null"><c path="nape.phys.Compound"/></t>
	<t path="Null"><c path="nape.phys.Compound"/></t>
</f></set_compound>
		<get_compound get="inline" set="null" line="244"><f a=""><t path="Null"><c path="nape.phys.Compound"/></t></f></get_compound>
		<compound public="1" get="accessor" set="accessor">
			<t path="Null"><c path="nape.phys.Compound"/></t>
			<haxe_doc>* Compound that this compound belongs to.
     *
     * @default null</haxe_doc>
		</compound>
		<get_compounds get="inline" set="null" line="234"><f a=""><c path="nape.phys.CompoundList"/></f></get_compounds>
		<compounds public="1" get="accessor" set="null">
			<c path="nape.phys.CompoundList"/>
			<haxe_doc><![CDATA[* List of compounds directly owned by this Compound.
     * <br/><br/>
     * This list does not include those compounds belonging to sub-compounds.
     *
     * @default []]]></haxe_doc>
		</compounds>
		<get_constraints get="inline" set="null" line="222"><f a=""><c path="nape.constraint.ConstraintList"/></f></get_constraints>
		<constraints public="1" get="accessor" set="null">
			<c path="nape.constraint.ConstraintList"/>
			<haxe_doc><![CDATA[* List of constraints directly owned by this Compound.
     * <br/><br/>
     * This list does not include those constraints belonging to sub-compounds.
     *
     * @default []]]></haxe_doc>
		</constraints>
		<get_bodies get="inline" set="null" line="210"><f a=""><c path="nape.phys.BodyList"/></f></get_bodies>
		<bodies public="1" get="accessor" set="null">
			<c path="nape.phys.BodyList"/>
			<haxe_doc><![CDATA[* List of bodies directly owned by this Compound.
     * <br/><br/>
     * This list does not include those bodies belonging to sub-compounds.
     *
     * @default []]]></haxe_doc>
		</bodies>
		<zpp_inner public="1">
			<c path="zpp_nape.phys.ZPP_Compound"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="287">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Construct a new Compound.
     *
     * @result The constructed Compound.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Compound represents a grouping of physics objects into a single object.
 * <br/><br/>
 * This compound owns its constituents and works in the callback system and with
 * respect to adding/removing from a Space as a single object.
 * <pre>
 *       ____Cmp1_____
 *      /    /    &#92;   &#92;
 * Body1 Body2--Joint Cmp2
 *   |     |        &#92;  |
 * Shp1  Shp2        Body3
 *                     |
 *                    Shp3
 * </pre>
 * For example if you have a complex car built with several bodies and
 * constraints you might store this in a Compound providing an easy way
 * of removing/adding/copying the Car as well as being able to get a single
 * callback for when the car collides with something.
 * <br/><br/>
 * When you add a compound to a Space, all of it's constituents get added
 * and furthermore, those constituents cannot be added seperately.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.phys.CompoundIterator" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/phys/CompoundIterator.hx">
		<zpp_pool public="1" line="194" static="1">
			<c path="nape.phys.CompoundIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_pool>
		<get public="1" set="method" line="217" static="1">
			<f a="list">
				<c path="nape.phys.CompoundList"/>
				<c path="nape.phys.CompoundIterator"/>
			</f>
			<haxe_doc><![CDATA[* Create iterator for Nape list.
     * <br/><br/>
     * There is no specific reason to use this over: <code>list.iterator()</code>
     * especcialy since this requires writing the class name :)
     * (This function is used internally)
     *
     * @param list The Nape list to create iterator for.
     * @return     An iterator over the Nape list.]]></haxe_doc>
		</get>
		<next public="1" get="inline" set="null" line="264">
			<f a=""><c path="nape.phys.Compound"/></f>
			<haxe_doc>* Return next element in list.
     *
     * @return The next element in iteration.</haxe_doc>
		</next>
		<hasNext public="1" get="inline" set="null" line="240">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Check if there are any elements remaining.
     *
     * @return True if there are more elements to iterator over.</haxe_doc>
		</hasNext>
		<zpp_next public="1">
			<c path="nape.phys.CompoundIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_next>
		<zpp_critical public="1">
			<x path="Bool"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_critical>
		<zpp_i public="1">
			<x path="Int"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_i>
		<zpp_inner public="1">
			<c path="nape.phys.CompoundList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="202">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Haxe Iterator<T> compatible iterator over Nape list.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.phys.CompoundList" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/phys/CompoundList.hx">
		<fromArray public="1" set="method" line="304" static="1">
			<f a="array">
				<c path="Array"><c path="nape.phys.Compound"/></c>
				<c path="nape.phys.CompoundList"/>
			</f>
			<haxe_doc>* Convert standard Array to Nape list.
     *
     * @param array The array to be converted
     * @return An equivalent Nape list.
     * @throws If array argument is null.
     * @throws If array contains elements of type other than Compound</haxe_doc>
		</fromArray>
		<filter public="1" set="method" line="779">
			<f a="lambda">
				<f a="">
					<c path="nape.phys.Compound"/>
					<x path="Bool"/>
				</f>
				<c path="nape.phys.CompoundList"/>
			</f>
			<haxe_doc><![CDATA[* Iterate over list filtering elements.
     * <br/><br/>
     * The given function will be applied to each element, whenever the
     * function returns false, the element will be removed from the list.
     * <br/><br/>
     * Any exception thrown by the supplied function will be treat as a
     * signal to halt iteration acting as a 'break' statement.
     * <br/><br/>
     * This method is to be greatly preferred for filtering logic as
     * it is otherwise unsafe to modify the list during an iteration.
     * <br/><br/>
     * An example of using this method to clean up a list whilst performing
     * actions on the elements.
     * <pre>
     * list.filter(function (obj) {
     *    // perform clean up with obj
     *    return false; // remove from list.
     * });
     * </pre>
     *
     * @param lambda The function to apply to each argument, deciding if
     *               element should be removed.
     * @return A reference to 'this' list.
     * @throws # If lambda argument is null.]]></haxe_doc>
		</filter>
		<foreach public="1" get="inline" set="null" line="732">
			<f a="lambda">
				<f a="">
					<c path="nape.phys.Compound"/>
					<x path="Void"/>
				</f>
				<c path="nape.phys.CompoundList"/>
			</f>
			<haxe_doc><![CDATA[* Iterate over list applying function.
     * <br/><br/>
     * Any exception thrown by the supplied function will be treat as a
     * signal to halt iteration acting as a 'break' statement.
     * <br/><br/>
     * This method should be preferred to using standard haxe iteration
     * as there will be no allocation of an iterator object.
     * <pre>
     * list.foreach(function (obj) {
     *     if (ignore_object(obj)) return; //acts as a 'continue' statement
     *     if (halt_iteration(obj)) throw "": //acts as a 'break' statement
     * });
     * </pre>
     *
     * @param lambda The function to apply to each argument.
     * @return A reference to 'this' list.
     * @throws # If lambda argument is null.]]></haxe_doc>
		</foreach>
		<toString public="1" set="method" line="702">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<merge public="1" set="method" line="684">
			<f a="xs">
				<c path="nape.phys.CompoundList"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Merge given list into this one.
     * <br/><br/>
     * The result is that this list will have all objects from the argument
     * that were not already in the list inserted. You should make no
     * assumption about the order of these insertions.
     *
     * @param xs The list to merge.
     * @throws # If xs argument is null.]]></haxe_doc>
		</merge>
		<copy public="1" set="method" line="662">
			<f a="?deep">
				<x path="Bool"/>
				<c path="nape.phys.CompoundList"/>
			</f>
			<haxe_doc>* Produce a possibly deep copy of list.
     *
     * @param deep If true, then each element will have its own copy
     *             function called instead of simply having its
     *             reference copied over.
     * @return     The copied list.</haxe_doc>
		</copy>
		<iterator public="1" get="inline" set="null" line="647">
			<f a=""><c path="nape.phys.CompoundIterator"/></f>
			<haxe_doc><![CDATA[* Return Haxe iterator for list.
     * <br/><br/>
     * Use of this iterator, whilst stylistically better in Haxe should not
     * be used, in preference for use of the foreach function which will
     * not require allocation of an iterator object.
     * <br/><br/>
     * Equally in AS3, the foreach method should be the preferred way to iterate.]]></haxe_doc>
		</iterator>
		<empty public="1" get="inline" set="null" line="631">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Test if list is empty or not.
     *
     * @return True if list is empty.</haxe_doc>
		</empty>
		<clear public="1" set="method" line="614">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clear the list, removing all elements.
     *
     * @throws # If list is iummutable</haxe_doc>
		</clear>
		<remove public="1" set="method" line="576">
			<f a="obj">
				<c path="nape.phys.Compound"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Remove element from list.
     * <br/><br/>
     * This is a linear time operation.
     *
     * @param obj The object to remove
     * @return True if object was removed from list.
     * @throws # If list is immutable]]></haxe_doc>
		</remove>
		<add public="1" get="inline" set="null" line="563">
			<f a="obj">
				<c path="nape.phys.Compound"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Insert element into list in most effecient way.
     * <br/><br/>
     * This method will defer to either the push or unshift function
     * depending on which is most effecient in the context.
     * <br/><br/>
     * If order of elements is not important then you should always use
     * this function to insert elements.
     *
     * @param obj The object to insert.
     * @return True if object was successfuly inserted.
     * @throws # If list is immutable]]></haxe_doc>
		</add>
		<shift public="1" set="method" line="519">
			<f a=""><c path="nape.phys.Compound"/></f>
			<haxe_doc><![CDATA[* Pop element from front of list.
     * <br/><br/>
     * If you are wanting to clear a list, whilst operating on its elements,
     * consider use of the filter method instead.
     *
     * @returns The element removed from list.
     * @throws # If list is immutable.
     * @throws # If the list is empty.]]></haxe_doc>
		</shift>
		<pop public="1" set="method" line="478">
			<f a=""><c path="nape.phys.Compound"/></f>
			<haxe_doc><![CDATA[* Pop element from back of list.
     * <br/><br/>
     * If you are wanting to clear a list, whilst operating on its elements,
     * consider use of the filter method instead.
     *
     * @returns The element removed from list.
     * @throws # If list is immutable.
     * @throws # If the list is empty.]]></haxe_doc>
		</pop>
		<unshift public="1" set="method" line="447">
			<f a="obj">
				<c path="nape.phys.Compound"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Push element to front of list.
     * <br/><br/>
     * When the order of objects is not important, it is best to use the
     * add() method instead.
     *
     * @param obj The object to insert.
     * @returns True if object was successively inserted.
     * @throws # If list is immutable.]]></haxe_doc>
		</unshift>
		<push public="1" set="method" line="416">
			<f a="obj">
				<c path="nape.phys.Compound"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Push element to back of list.
     * <br/><br/>
     * When the order of objects is not important, it is best to use the
     * add() method instead.
     *
     * @param obj The object to insert.
     * @returns True if object was successively inserted.
     * @throws # If list is immutable.]]></haxe_doc>
		</push>
		<at public="1" set="method" line="363">
			<f a="index">
				<x path="Int"/>
				<c path="nape.phys.Compound"/>
			</f>
			<haxe_doc><![CDATA[* Random access to elements of list by index.
     * <br/><br/>
     * Under normal circumstances, accessing succesive elements via this
     * method will occur in constant time.
     *
     * @param index The index of the element in list to access.
     * @returns The element at the given index.
     * @throws # If index is out of bounds.]]></haxe_doc>
		</at>
		<has public="1" set="method" line="346">
			<f a="obj">
				<c path="nape.phys.Compound"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if element is already in the list
     *
     * @param obj The object to test.
     * @return True if object is in the list.</haxe_doc>
		</has>
		<get_length get="inline" set="null" line="244"><f a=""><x path="Int"/></f></get_length>
		<length public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Length of list.</haxe_doc>
		</length>
		<zpp_inner public="1">
			<c path="zpp_nape.util.ZPP_CompoundList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="695">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Construct a new list.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Nape list of Compound type objects
 * <br/><br/>
 * Internally this list is at present implemented as a linked list with
 * object pooled nodes and iterators with various fast paths made for
 * standard access patterns (For instance accessing successive elements
 * runs in constant time when using random access functions)
 * <br/><br/>
 * Iteration of this list can be done in various ways, but the preferred
 * way on all targets, is through use of the foreach function:
 * <pre>
 * list.foreach(function (obj) {
 * });
 * </pre>
 * This method is inlined so that in haxe no closure will need to be created.
 * <br/><br/>
 * In AS3, a closure would need to be created in general, so for performance
 * reasons you 'may' choose to use iteration as follows:
 * <pre>
 * for (var i:int = 0; i < list.length; i++) {
 *     var obj:Compound = list.at(i);
 * }
 * </pre>
 * <br/>
 * NOTE: It is 'not' safe to modify a list whilst iterating over it.
 * If you wish to remove elements during an iteration you should use the
 * filter method, for example:
 * <pre>
 * list.filter(function (obj) {
 *     // operate on object.
 *     // ...
 *     return (false if you want object to be removed);
 * });
 * </pre>
 * <br/><br/>
 * In AS3, if you wish to avoid a closure generation, you can perform such
 * an iteration in a safe manner as follows:
 * <pre>
 * var i:int = 0;
 * while (i < list.length) {
 *     var obj:Compound = list.at(i);
 *     // operate on object.
 *     // ...
 *     if (should remove obj) {
 *         list.remove(obj);
 *         continue;
 *     }
 *     else i++;
 * }
 * </pre>
 * Or if you are always clearing the list entirely you could write:
 * <pre>
 * while (!list.empty()) {
 *     var obj:Compound = list.pop();
 *     // operate on object.
 *     // ...
 * }
 * </pre>]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.phys.FluidProperties" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/phys/FluidProperties.hx">
		<toString public="1" set="method" line="344">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<set_gravity get="inline" set="null" line="320"><f a="gravity">
	<t path="Null"><c path="nape.geom.Vec2"/></t>
	<t path="Null"><c path="nape.geom.Vec2"/></t>
</f></set_gravity>
		<get_gravity get="inline" set="null" line="317"><f a=""><t path="Null"><c path="nape.geom.Vec2"/></t></f></get_gravity>
		<gravity public="1" get="accessor" set="accessor">
			<t path="Null"><c path="nape.geom.Vec2"/></t>
			<haxe_doc><![CDATA[* Local gravity for buoyancy computations.
     * <br/><br/>
     * When this value is not null, it will be used in place of the Space gravity
     * when performing buoyancy computations.]]></haxe_doc>
		</gravity>
		<set_viscosity get="inline" set="null" line="296"><f a="viscosity">
	<x path="Float"/>
	<x path="Float"/>
</f></set_viscosity>
		<get_viscosity get="inline" set="null" line="293"><f a=""><x path="Float"/></f></get_viscosity>
		<viscosity public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Viscosity of fluid.
     * <br/><br/>
     * This value is used in drag comutations, the higher the viscosity the
     * more quickly objects will come to rest in the fluid.
     * @default 1]]></haxe_doc>
		</viscosity>
		<set_density get="inline" set="null" line="271"><f a="density">
	<x path="Float"/>
	<x path="Float"/>
</f></set_density>
		<get_density get="inline" set="null" line="268"><f a=""><x path="Float"/></f></get_density>
		<density public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Density of fluid.
     * <br/><br/>
     * This value, like Material density is of g/pixel/pixel.
     * @default 1]]></haxe_doc>
		</density>
		<copy public="1" set="method" line="254">
			<f a=""><c path="nape.phys.FluidProperties"/></f>
			<haxe_doc><![CDATA[* Produce a copy of this FluidProperties object.
     * <br/><br/>
     * The copied object will be identical in all properties with the the
     * copied userData being assigned the same fields as 'this' Shape with the
     * same values copied over by reference for object types.
     *
     * @return The copied FluidProperties.]]></haxe_doc>
		</copy>
		<get_shapes get="inline" set="null" line="210"><f a=""><c path="nape.shape.ShapeList"/></f></get_shapes>
		<shapes public="1" get="accessor" set="null">
			<c path="nape.shape.ShapeList"/>
			<haxe_doc><![CDATA[* Set of all active shapes using this object.
     * <br/><br/>
     * Activeness of a shape in the sense that the Shape's Body is inside of a Space.
     * <br/><br/>
     * This list is immutable.]]></haxe_doc>
		</shapes>
		<get_userData get="inline" set="null" line="195"><f a=""><d><d/></d></f></get_userData>
		<userData public="1" get="accessor" set="null">
			<d><d/></d>
			<haxe_doc><![CDATA[* Dynamic object for user to store additional data.
     * <br/><br/>
     * This object cannot be set, only its dynamically created
     * properties may be set. In AS3 the type of this property is &#42
     * <br/><br/>
     * This object will be lazily constructed so that until accessed
     * for the first time, will be null internally.
     *
     * @default {}]]></haxe_doc>
		</userData>
		<zpp_inner public="1">
			<c path="zpp_nape.phys.ZPP_FluidProperties"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="222">
			<f a="?density:?viscosity">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Construct a new FluidProperties objects.
     *
     * @param density The density of the fluid in g/px/px. (default 1)
     * @param viscosity The viscosity of the fluid for drag computations in kg/px/s
     *                  (default 1)
     * @return The constructed FluidProperties object.</haxe_doc>
		</new>
		<haxe_doc>* FluidProperties providing shared parameters for fluid interaction.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.phys.GravMassMode" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/phys/GravMassMode.hx">
		<DEFAULT public="1" get="accessor" set="null" static="1">
			<c path="nape.phys.GravMassMode"/>
			<haxe_doc><![CDATA[* Default method of computation.
     * <br/><br/>
     * Mass seen by gravity equal to the Body mass.]]></haxe_doc>
		</DEFAULT>
		<get_DEFAULT get="inline" set="null" line="204" static="1"><f a=""><c path="nape.phys.GravMassMode"/></f></get_DEFAULT>
		<FIXED public="1" get="accessor" set="null" static="1">
			<c path="nape.phys.GravMassMode"/>
			<haxe_doc><![CDATA[* Fixed method of computation.
     * <br/><br/>
     * Mass seen by gravity set by user.]]></haxe_doc>
		</FIXED>
		<get_FIXED get="inline" set="null" line="219" static="1"><f a=""><c path="nape.phys.GravMassMode"/></f></get_FIXED>
		<SCALED public="1" get="accessor" set="null" static="1">
			<c path="nape.phys.GravMassMode"/>
			<haxe_doc><![CDATA[* Scaled method of computation.
     * <br/><br/>
     * Mass seen by gravity computed as a factor of the Body mass with
     * scaling factor set by user.]]></haxe_doc>
		</SCALED>
		<get_SCALED get="inline" set="null" line="235" static="1"><f a=""><c path="nape.phys.GravMassMode"/></f></get_SCALED>
		<toString public="1" set="method" line="189">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<new public="1" set="method" line="181">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc>* Enumeration of GravMassMode values for a Body.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.phys.InertiaMode" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/phys/InertiaMode.hx">
		<DEFAULT public="1" get="accessor" set="null" static="1">
			<c path="nape.phys.InertiaMode"/>
			<haxe_doc><![CDATA[* Default method of computation.
     * <br/><br/>
     * Moment of inertia will be computed based on Body's Shape's inertias and densities.]]></haxe_doc>
		</DEFAULT>
		<get_DEFAULT get="inline" set="null" line="203" static="1"><f a=""><c path="nape.phys.InertiaMode"/></f></get_DEFAULT>
		<FIXED public="1" get="accessor" set="null" static="1">
			<c path="nape.phys.InertiaMode"/>
			<haxe_doc><![CDATA[* Fixed method of computation.
     * <br/><br/>
     * Moment of inertia set by user.]]></haxe_doc>
		</FIXED>
		<get_FIXED get="inline" set="null" line="218" static="1"><f a=""><c path="nape.phys.InertiaMode"/></f></get_FIXED>
		<toString public="1" set="method" line="189">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<new public="1" set="method" line="181">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc>* Enumeration of InertiaMode values for a Body.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.phys.InteractorIterator" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/phys/InteractorIterator.hx">
		<zpp_pool public="1" line="194" static="1">
			<c path="nape.phys.InteractorIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_pool>
		<get public="1" set="method" line="217" static="1">
			<f a="list">
				<c path="nape.phys.InteractorList"/>
				<c path="nape.phys.InteractorIterator"/>
			</f>
			<haxe_doc><![CDATA[* Create iterator for Nape list.
     * <br/><br/>
     * There is no specific reason to use this over: <code>list.iterator()</code>
     * especcialy since this requires writing the class name :)
     * (This function is used internally)
     *
     * @param list The Nape list to create iterator for.
     * @return     An iterator over the Nape list.]]></haxe_doc>
		</get>
		<next public="1" get="inline" set="null" line="264">
			<f a=""><c path="nape.phys.Interactor"/></f>
			<haxe_doc>* Return next element in list.
     *
     * @return The next element in iteration.</haxe_doc>
		</next>
		<hasNext public="1" get="inline" set="null" line="240">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Check if there are any elements remaining.
     *
     * @return True if there are more elements to iterator over.</haxe_doc>
		</hasNext>
		<zpp_next public="1">
			<c path="nape.phys.InteractorIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_next>
		<zpp_critical public="1">
			<x path="Bool"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_critical>
		<zpp_i public="1">
			<x path="Int"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_i>
		<zpp_inner public="1">
			<c path="nape.phys.InteractorList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="202">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Haxe Iterator<T> compatible iterator over Nape list.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.phys.InteractorList" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/phys/InteractorList.hx">
		<fromArray public="1" set="method" line="304" static="1">
			<f a="array">
				<c path="Array"><c path="nape.phys.Interactor"/></c>
				<c path="nape.phys.InteractorList"/>
			</f>
			<haxe_doc>* Convert standard Array to Nape list.
     *
     * @param array The array to be converted
     * @return An equivalent Nape list.
     * @throws If array argument is null.
     * @throws If array contains elements of type other than Interactor</haxe_doc>
		</fromArray>
		<filter public="1" set="method" line="779">
			<f a="lambda">
				<f a="">
					<c path="nape.phys.Interactor"/>
					<x path="Bool"/>
				</f>
				<c path="nape.phys.InteractorList"/>
			</f>
			<haxe_doc><![CDATA[* Iterate over list filtering elements.
     * <br/><br/>
     * The given function will be applied to each element, whenever the
     * function returns false, the element will be removed from the list.
     * <br/><br/>
     * Any exception thrown by the supplied function will be treat as a
     * signal to halt iteration acting as a 'break' statement.
     * <br/><br/>
     * This method is to be greatly preferred for filtering logic as
     * it is otherwise unsafe to modify the list during an iteration.
     * <br/><br/>
     * An example of using this method to clean up a list whilst performing
     * actions on the elements.
     * <pre>
     * list.filter(function (obj) {
     *    // perform clean up with obj
     *    return false; // remove from list.
     * });
     * </pre>
     *
     * @param lambda The function to apply to each argument, deciding if
     *               element should be removed.
     * @return A reference to 'this' list.
     * @throws # If lambda argument is null.]]></haxe_doc>
		</filter>
		<foreach public="1" get="inline" set="null" line="732">
			<f a="lambda">
				<f a="">
					<c path="nape.phys.Interactor"/>
					<x path="Void"/>
				</f>
				<c path="nape.phys.InteractorList"/>
			</f>
			<haxe_doc><![CDATA[* Iterate over list applying function.
     * <br/><br/>
     * Any exception thrown by the supplied function will be treat as a
     * signal to halt iteration acting as a 'break' statement.
     * <br/><br/>
     * This method should be preferred to using standard haxe iteration
     * as there will be no allocation of an iterator object.
     * <pre>
     * list.foreach(function (obj) {
     *     if (ignore_object(obj)) return; //acts as a 'continue' statement
     *     if (halt_iteration(obj)) throw "": //acts as a 'break' statement
     * });
     * </pre>
     *
     * @param lambda The function to apply to each argument.
     * @return A reference to 'this' list.
     * @throws # If lambda argument is null.]]></haxe_doc>
		</foreach>
		<toString public="1" set="method" line="702">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<merge public="1" set="method" line="684">
			<f a="xs">
				<c path="nape.phys.InteractorList"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Merge given list into this one.
     * <br/><br/>
     * The result is that this list will have all objects from the argument
     * that were not already in the list inserted. You should make no
     * assumption about the order of these insertions.
     *
     * @param xs The list to merge.
     * @throws # If xs argument is null.]]></haxe_doc>
		</merge>
		<copy public="1" set="method" line="662">
			<f a="?deep">
				<x path="Bool"/>
				<c path="nape.phys.InteractorList"/>
			</f>
			<haxe_doc>* Produce a possibly deep copy of list.
     *
     * @param deep If true, then each element will have its own copy
     *             function called instead of simply having its
     *             reference copied over.
     * @return     The copied list.</haxe_doc>
		</copy>
		<iterator public="1" get="inline" set="null" line="647">
			<f a=""><c path="nape.phys.InteractorIterator"/></f>
			<haxe_doc><![CDATA[* Return Haxe iterator for list.
     * <br/><br/>
     * Use of this iterator, whilst stylistically better in Haxe should not
     * be used, in preference for use of the foreach function which will
     * not require allocation of an iterator object.
     * <br/><br/>
     * Equally in AS3, the foreach method should be the preferred way to iterate.]]></haxe_doc>
		</iterator>
		<empty public="1" get="inline" set="null" line="631">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Test if list is empty or not.
     *
     * @return True if list is empty.</haxe_doc>
		</empty>
		<clear public="1" set="method" line="614">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clear the list, removing all elements.
     *
     * @throws # If list is iummutable</haxe_doc>
		</clear>
		<remove public="1" set="method" line="576">
			<f a="obj">
				<c path="nape.phys.Interactor"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Remove element from list.
     * <br/><br/>
     * This is a linear time operation.
     *
     * @param obj The object to remove
     * @return True if object was removed from list.
     * @throws # If list is immutable]]></haxe_doc>
		</remove>
		<add public="1" get="inline" set="null" line="563">
			<f a="obj">
				<c path="nape.phys.Interactor"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Insert element into list in most effecient way.
     * <br/><br/>
     * This method will defer to either the push or unshift function
     * depending on which is most effecient in the context.
     * <br/><br/>
     * If order of elements is not important then you should always use
     * this function to insert elements.
     *
     * @param obj The object to insert.
     * @return True if object was successfuly inserted.
     * @throws # If list is immutable]]></haxe_doc>
		</add>
		<shift public="1" set="method" line="519">
			<f a=""><c path="nape.phys.Interactor"/></f>
			<haxe_doc><![CDATA[* Pop element from front of list.
     * <br/><br/>
     * If you are wanting to clear a list, whilst operating on its elements,
     * consider use of the filter method instead.
     *
     * @returns The element removed from list.
     * @throws # If list is immutable.
     * @throws # If the list is empty.]]></haxe_doc>
		</shift>
		<pop public="1" set="method" line="478">
			<f a=""><c path="nape.phys.Interactor"/></f>
			<haxe_doc><![CDATA[* Pop element from back of list.
     * <br/><br/>
     * If you are wanting to clear a list, whilst operating on its elements,
     * consider use of the filter method instead.
     *
     * @returns The element removed from list.
     * @throws # If list is immutable.
     * @throws # If the list is empty.]]></haxe_doc>
		</pop>
		<unshift public="1" set="method" line="447">
			<f a="obj">
				<c path="nape.phys.Interactor"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Push element to front of list.
     * <br/><br/>
     * When the order of objects is not important, it is best to use the
     * add() method instead.
     *
     * @param obj The object to insert.
     * @returns True if object was successively inserted.
     * @throws # If list is immutable.]]></haxe_doc>
		</unshift>
		<push public="1" set="method" line="416">
			<f a="obj">
				<c path="nape.phys.Interactor"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Push element to back of list.
     * <br/><br/>
     * When the order of objects is not important, it is best to use the
     * add() method instead.
     *
     * @param obj The object to insert.
     * @returns True if object was successively inserted.
     * @throws # If list is immutable.]]></haxe_doc>
		</push>
		<at public="1" set="method" line="363">
			<f a="index">
				<x path="Int"/>
				<c path="nape.phys.Interactor"/>
			</f>
			<haxe_doc><![CDATA[* Random access to elements of list by index.
     * <br/><br/>
     * Under normal circumstances, accessing succesive elements via this
     * method will occur in constant time.
     *
     * @param index The index of the element in list to access.
     * @returns The element at the given index.
     * @throws # If index is out of bounds.]]></haxe_doc>
		</at>
		<has public="1" set="method" line="346">
			<f a="obj">
				<c path="nape.phys.Interactor"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if element is already in the list
     *
     * @param obj The object to test.
     * @return True if object is in the list.</haxe_doc>
		</has>
		<get_length get="inline" set="null" line="244"><f a=""><x path="Int"/></f></get_length>
		<length public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Length of list.</haxe_doc>
		</length>
		<zpp_inner public="1">
			<c path="zpp_nape.util.ZPP_InteractorList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="695">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Construct a new list.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Nape list of Interactor type objects
 * <br/><br/>
 * Internally this list is at present implemented as a linked list with
 * object pooled nodes and iterators with various fast paths made for
 * standard access patterns (For instance accessing successive elements
 * runs in constant time when using random access functions)
 * <br/><br/>
 * Iteration of this list can be done in various ways, but the preferred
 * way on all targets, is through use of the foreach function:
 * <pre>
 * list.foreach(function (obj) {
 * });
 * </pre>
 * This method is inlined so that in haxe no closure will need to be created.
 * <br/><br/>
 * In AS3, a closure would need to be created in general, so for performance
 * reasons you 'may' choose to use iteration as follows:
 * <pre>
 * for (var i:int = 0; i < list.length; i++) {
 *     var obj:Interactor = list.at(i);
 * }
 * </pre>
 * <br/>
 * NOTE: It is 'not' safe to modify a list whilst iterating over it.
 * If you wish to remove elements during an iteration you should use the
 * filter method, for example:
 * <pre>
 * list.filter(function (obj) {
 *     // operate on object.
 *     // ...
 *     return (false if you want object to be removed);
 * });
 * </pre>
 * <br/><br/>
 * In AS3, if you wish to avoid a closure generation, you can perform such
 * an iteration in a safe manner as follows:
 * <pre>
 * var i:int = 0;
 * while (i < list.length) {
 *     var obj:Interactor = list.at(i);
 *     // operate on object.
 *     // ...
 *     if (should remove obj) {
 *         list.remove(obj);
 *         continue;
 *     }
 *     else i++;
 * }
 * </pre>
 * Or if you are always clearing the list entirely you could write:
 * <pre>
 * while (!list.empty()) {
 *     var obj:Interactor = list.pop();
 *     // operate on object.
 *     // ...
 * }
 * </pre>]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.phys.MassMode" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/phys/MassMode.hx">
		<DEFAULT public="1" get="accessor" set="null" static="1">
			<c path="nape.phys.MassMode"/>
			<haxe_doc><![CDATA[* Default method of computation.
     * <br/><br/>
     * Mass will be computed based on Body's Shape's areas and densities.]]></haxe_doc>
		</DEFAULT>
		<get_DEFAULT get="inline" set="null" line="203" static="1"><f a=""><c path="nape.phys.MassMode"/></f></get_DEFAULT>
		<FIXED public="1" get="accessor" set="null" static="1">
			<c path="nape.phys.MassMode"/>
			<haxe_doc><![CDATA[* Fixed method of computation.
     * <br/><br/>
     * Mass set by user.]]></haxe_doc>
		</FIXED>
		<get_FIXED get="inline" set="null" line="218" static="1"><f a=""><c path="nape.phys.MassMode"/></f></get_FIXED>
		<toString public="1" set="method" line="189">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<new public="1" set="method" line="181">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc>* Enumeration of MassMode values for a Body.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.phys.Material" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/phys/Material.hx">
		<wood public="1" set="method" line="434" static="1">
			<f a=""><c path="nape.phys.Material"/></f>
			<haxe_doc><![CDATA[* Predefined constructor for a wood style Material.
     *
     * @return <code>new Material(0.4,0.2,0.38,0.7,0.005)</code>]]></haxe_doc>
		</wood>
		<steel public="1" set="method" line="443" static="1">
			<f a=""><c path="nape.phys.Material"/></f>
			<haxe_doc><![CDATA[* Predefined constructor for a steel style Material.
     *
     * @return <code>new Material(0.2,0.57,0.74,7.8,0.001)</code>]]></haxe_doc>
		</steel>
		<ice public="1" set="method" line="452" static="1">
			<f a=""><c path="nape.phys.Material"/></f>
			<haxe_doc><![CDATA[* Predefined constructor for a ice style Material.
     *
     * @return <code>new Material(0.3,0.03,0.1,0.9,0.0001)</code>]]></haxe_doc>
		</ice>
		<rubber public="1" set="method" line="461" static="1">
			<f a=""><c path="nape.phys.Material"/></f>
			<haxe_doc><![CDATA[* Predefined constructor for a rubber style Material.
     *
     * @return <code>new Material(0.8,1.0,1.4,1.5,0.01)</code>]]></haxe_doc>
		</rubber>
		<glass public="1" set="method" line="470" static="1">
			<f a=""><c path="nape.phys.Material"/></f>
			<haxe_doc><![CDATA[* Predefined constructor for a glass style Material.
     *
     * @return <code>new Material(0.4,0.4,0.94,2.6,0.002)</code>]]></haxe_doc>
		</glass>
		<sand public="1" set="method" line="479" static="1">
			<f a=""><c path="nape.phys.Material"/></f>
			<haxe_doc><![CDATA[* Predefined constructor for a sand style Material.
     *
     * @return <code>new Material(-1.0,0.45,0.6,1.6,16.0)</code>]]></haxe_doc>
		</sand>
		<toString public="1" set="method" line="425">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<set_rollingFriction get="inline" set="null" line="408"><f a="rollingFriction">
	<x path="Float"/>
	<x path="Float"/>
</f></set_rollingFriction>
		<get_rollingFriction get="inline" set="null" line="405"><f a=""><x path="Float"/></f></get_rollingFriction>
		<rollingFriction public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Coeffecient of rolling friction for circle interactions.
     * <br/><br/>
     * This property may take any zero or positive value. Coeffecients of
     * staticFriction are combined by taking the square root of their product.
     * <br/><br/>
     * The higher this value, the more quickly a rolling circle - which would
     * otherwise roll forever ignoring drag and numerical issues - will come to
     * rest.
     *
     * @default 0.01]]></haxe_doc>
		</rollingFriction>
		<set_density get="inline" set="null" line="377"><f a="density">
	<x path="Float"/>
	<x path="Float"/>
</f></set_density>
		<get_density get="inline" set="null" line="374"><f a=""><x path="Float"/></f></get_density>
		<density public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Density of Shape's using this Material.
     * <br/><br/>
     * This property has units of g/pixel/pixel, not Kg/pixel/pixel for the
     * simple reason that we get more reasonable values like 1 instead of 0.001
     * to attain reasonable mass values for Bodys.
     *
     * @default 1]]></haxe_doc>
		</density>
		<set_staticFriction get="inline" set="null" line="349"><f a="staticFriction">
	<x path="Float"/>
	<x path="Float"/>
</f></set_staticFriction>
		<get_staticFriction get="inline" set="null" line="346"><f a=""><x path="Float"/></f></get_staticFriction>
		<staticFriction public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Coeffecient of static friction for material.
     * <br/><br/>
     * This property may take any zero or positive value. Coeffecients of
     * staticFriction are combined by taking the square root of their product.
     * <br/><br/>
     * The higher this value the more quickly objects will come to rest once moving
     * very slowly, and the harder it will be to cause the objcet to begin to slide.
     *
     * @default 2]]></haxe_doc>
		</staticFriction>
		<set_dynamicFriction get="inline" set="null" line="319"><f a="dynamicFriction">
	<x path="Float"/>
	<x path="Float"/>
</f></set_dynamicFriction>
		<get_dynamicFriction get="inline" set="null" line="316"><f a=""><x path="Float"/></f></get_dynamicFriction>
		<dynamicFriction public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Coeffecient of dynamic friction for material.
     * <br/><br/>
     * This property may take any zero or positive value. Coeffecients of
     * dynamicFriction are combined by taking the square root of their product.
     * <br/><br/>
     * The higher this value the more quickly objects will slow down from speed
     * when sliding.
     *
     * @default 1]]></haxe_doc>
		</dynamicFriction>
		<set_elasticity get="inline" set="null" line="289"><f a="elasticity">
	<x path="Float"/>
	<x path="Float"/>
</f></set_elasticity>
		<get_elasticity get="inline" set="null" line="286"><f a=""><x path="Float"/></f></get_elasticity>
		<elasticity public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Elasticity of material.
     * <br/><br/>
     * This property may take any value. Coeffecients of elasticity are combined
     * by taking their average, and then clamping to the range [0,1]. In this way
     * you may give very large values (even infinites) to this property to bias
     * the result of combining elasticities.
     * <br/><br/>
     * A combined, clamped value of 0 results in no bouncing whatsoever.
     * <br/>
     * A combine, clamped value of 1 results in complete elasticity where if
     * possible, the objects will not lose any energy at all.
     *
     * @default 0.0]]></haxe_doc>
		</elasticity>
		<copy public="1" set="method" line="264">
			<f a=""><c path="nape.phys.Material"/></f>
			<haxe_doc><![CDATA[* Produce a copy of this Material object.
     * <br/><br/>
     * The copied object will be identical in all properties with the the
     * copied userData being assigned the same fields as 'this' Shape with the
     * same values copied over by reference for object types.
     *
     * @return The copied Material.]]></haxe_doc>
		</copy>
		<get_shapes get="inline" set="null" line="210"><f a=""><c path="nape.shape.ShapeList"/></f></get_shapes>
		<shapes public="1" get="accessor" set="null">
			<c path="nape.shape.ShapeList"/>
			<haxe_doc><![CDATA[* Set of all active shapes using this object.
     * <br/><br/>
     * Activeness of a shape in the sense that the Shape's Body is inside of a Space.
     * <br/><br/>
     * This list is immutable.]]></haxe_doc>
		</shapes>
		<get_userData get="inline" set="null" line="195"><f a=""><d><d/></d></f></get_userData>
		<userData public="1" get="accessor" set="null">
			<d><d/></d>
			<haxe_doc><![CDATA[* Dynamic object for user to store additional data.
     * <br/><br/>
     * This object cannot be set, only its dynamically created
     * properties may be set. In AS3 the type of this property is &#42
     * <br/><br/>
     * This object will be lazily constructed so that until accessed
     * for the first time, will be null internally.
     *
     * @default {}]]></haxe_doc>
		</userData>
		<zpp_inner public="1">
			<c path="zpp_nape.phys.ZPP_Material"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="229">
			<f a="?elasticity:?dynamicFriction:?staticFriction:?density:?rollingFriction">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Construct a new Material object.
     *
     * @param elasticity The coeffecient of elasticity for material.
     *                   (default 0.0)
     * @param dynamicFriction The coeffecient of dynamic friction for
     *                        material. (default 1.0)
     * @param staticFriction The coeffecient of static friction for
     *                       material. (default 2.0)
     * @param density The density of the shape using this material in units
     *                of g/pixel/pixel. (default 1.0)
     * @param rollingFriction The coeffecient of rolling friction for material
     *                        used in circle friction computations. (default 0.001)
     * @return The constructed Material object.</haxe_doc>
		</new>
		<haxe_doc>* Material property providing physical attributes to a Shape.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.shape.Shape" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/shape/Shape.hx">
		<extends path="nape.phys.Interactor"/>
		<toString public="1" set="method" line="660" override="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<copy public="1" set="method" line="654">
			<f a=""><c path="nape.shape.Shape"/></f>
			<haxe_doc><![CDATA[* Produce an exact copy of this Shape.
     * <br/><br/>
     * The copied shape will be identical with the copied Shape's userData
     * object being assigned the same fields as 'this' Shape with the same
     * values copied over by reference for object types.
     *
     * @return A copy of this shape.]]></haxe_doc>
		</copy>
		<contains public="1" set="method" line="616">
			<f a="point">
				<c path="nape.geom.Vec2"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Test containment of world-space coordinate in Shape.
     * <br/><br/>
     * This Shape must be part of a Body so that world coordinates are
     * defined.
     *
     * @param point The point to check for containment.
     * @return True if point is contained within the Shape.
     * @throws If point is null or disposed of.
     * @throws If this shape is not part of a Body.]]></haxe_doc>
		</contains>
		<transform public="1" set="method" line="584">
			<f a="matrix">
				<c path="nape.geom.Mat23"/>
				<c path="nape.shape.Shape"/>
			</f>
			<haxe_doc><![CDATA[* Apply local transformation matrix to Shape.
     * <br/><br/>
     * For Circle shapes, the matrix must be equiorthogonal.
     *
     * @param matrix The matrix to transform Shape by.
     * @return A reference to 'this' Shape.
     * @throws # If matrix is null or singular.
     * @throws # If shape is a Circle, and matrix is not equiorthogonal.
     * @throws # If this shape is part of a static body that is inside of a Space.]]></haxe_doc>
		</transform>
		<rotate public="1" set="method" line="557">
			<f a="angle">
				<x path="Float"/>
				<c path="nape.shape.Shape"/>
			</f>
			<haxe_doc>* Rotate this shape in its local coordinate system.
     *
     * @param angle The number of radians to rotate this Shape by in a clockwise
     *              direction.
     * @return A reference to 'this' Shape.
     * @throws # If this shape is part of a static body that is inside of a Space.</haxe_doc>
		</rotate>
		<scale public="1" set="method" line="527">
			<f a="scalex:scaley">
				<x path="Float"/>
				<x path="Float"/>
				<c path="nape.shape.Shape"/>
			</f>
			<haxe_doc><![CDATA[* Scale this shape in its local coordinate system.
     * <br/><br/>
     * For Circle shapes, scalex and scaley must be exactly equal.
     *
     * @param scalex The x-coordinate scaling to apply to Shape.
     * @param scaley The y-coordinate scaling to apply to Shape.
     * @return A reference to 'this' Shape.
     * @throws # If this shape is part of a static body that is inside of a Space.
     * @throws # If scalex or scaley is 0. Negative values 'are' permitted.]]></haxe_doc>
		</scale>
		<translate public="1" set="method" line="487">
			<f a="translation">
				<c path="nape.geom.Vec2"/>
				<c path="nape.shape.Shape"/>
			</f>
			<haxe_doc><![CDATA[* Translate this shape in its local coordinate system.
     * <br/><br/>
     * This is equivalent to: <code>shape.localCOM.addeq(displacement)</code>
     *
     * @param translation The local translation to apply to Shape.
     * @return A reference to 'this' Shape.
     * @throws # If translation is null or has been disposed of.
     * @throws # If this shape is part of a static body that is inside of a Space.]]></haxe_doc>
		</translate>
		<get_bounds get="inline" set="null" line="473"><f a=""><c path="nape.geom.AABB"/></f></get_bounds>
		<bounds public="1" get="accessor" set="null">
			<c path="nape.geom.AABB"/>
			<haxe_doc><![CDATA[* World space bounding box for this shape.
     * <br/><br/>
     * This value can be accessed even if the Shape is not part of a Body,
     * however attempting to query its values would result in an error in
     * debug builds.
     * <br/><br/>
     * This AABB is immutable.]]></haxe_doc>
		</bounds>
		<set_sensorEnabled get="inline" set="null" line="454"><f a="sensorEnabled">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_sensorEnabled>
		<get_sensorEnabled get="inline" set="null" line="451"><f a=""><x path="Bool"/></f></get_sensorEnabled>
		<sensorEnabled public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Whether this shape is able to interact as sensor.
     * <br/><br/>
     * Unless this field is true, this Shape can never interact as a sensor.
     * <br/><br/>
     * Just because this field is true however, does not mean this shape will always
     * interact as a sensor, the final result is down to the combination of
     * InteractionFilters on the pairing of shapes. Sensor interaction has highest priority.
     *
     * @default false]]></haxe_doc>
		</sensorEnabled>
		<set_fluidEnabled get="inline" set="null" line="429"><f a="fluidEnabled">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_fluidEnabled>
		<get_fluidEnabled get="inline" set="null" line="426"><f a=""><x path="Bool"/></f></get_fluidEnabled>
		<fluidEnabled public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Whether this shape is able to interact as a fluid.
     * <br/><br/>
     * Unless this field is true, this Shape can never interact as a fluid.
     * <br/><br/>
     * Just because this field is true however, does not mean this shape will always
     * interact as a fluid, the final result is down to the combination of
     * InteractionFilters on the pairing of shapes and sensory interaction
     * takes higher priority.
     *
     * @default false]]></haxe_doc>
		</fluidEnabled>
		<set_fluidProperties get="inline" set="null" line="403"><f a="fluidProperties">
	<c path="nape.phys.FluidProperties"/>
	<c path="nape.phys.FluidProperties"/>
</f></set_fluidProperties>
		<get_fluidProperties get="inline" set="null" line="398"><f a=""><c path="nape.phys.FluidProperties"/></f></get_fluidProperties>
		<fluidProperties public="1" get="accessor" set="accessor">
			<c path="nape.phys.FluidProperties"/>
			<haxe_doc><![CDATA[* FluidProperties used by this shape.
     * <br/><br/>
     * This object provides information for buoyancy and fluid drag computations
     * when this shape is interacting as a fluid.
     *
     * @default new FluidProperties();]]></haxe_doc>
		</fluidProperties>
		<set_filter get="inline" set="null" line="378"><f a="filter">
	<c path="nape.dynamics.InteractionFilter"/>
	<c path="nape.dynamics.InteractionFilter"/>
</f></set_filter>
		<get_filter get="inline" set="null" line="375"><f a=""><c path="nape.dynamics.InteractionFilter"/></f></get_filter>
		<filter public="1" get="accessor" set="accessor">
			<c path="nape.dynamics.InteractionFilter"/>
			<haxe_doc>* InteractionFilter used by this shape.
     *
     * @default new InteractionFilter()</haxe_doc>
		</filter>
		<set_material get="inline" set="null" line="358"><f a="material">
	<c path="nape.phys.Material"/>
	<c path="nape.phys.Material"/>
</f></set_material>
		<get_material get="inline" set="null" line="355"><f a=""><c path="nape.phys.Material"/></f></get_material>
		<material public="1" get="accessor" set="accessor">
			<c path="nape.phys.Material"/>
			<haxe_doc>* Material used by this shape.
     *
     * @default new Material()</haxe_doc>
		</material>
		<get_angDrag get="inline" set="null" line="344"><f a=""><x path="Float"/></f></get_angDrag>
		<angDrag public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* Coeffecient of angular fluid drag for this Shape.</haxe_doc>
		</angDrag>
		<get_inertia get="inline" set="null" line="335"><f a=""><x path="Float"/></f></get_inertia>
		<inertia public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* Non-mass weighted moment of inertia for Shape.</haxe_doc>
		</inertia>
		<get_area get="inline" set="null" line="326"><f a=""><x path="Float"/></f></get_area>
		<area public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* Area of the Hhape.</haxe_doc>
		</area>
		<set_localCOM get="inline" set="null" line="305"><f a="localCOM">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_localCOM>
		<get_localCOM get="inline" set="null" line="298"><f a=""><c path="nape.geom.Vec2"/></f></get_localCOM>
		<localCOM public="1" get="accessor" set="accessor">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* Local space centre of mass of this Shape.
     * <br/><br/>
     * This Vec2 can be set and is equivalent to performing the necessary
     * translation of the Shape in local coordinates, and also equivalent
     * to <code>this.localCOM.set(value)</code>.
     * <br/>
     * Setting this value whilst this shape is part of a static Body that
     * is part of a Space is not permitted.]]></haxe_doc>
		</localCOM>
		<get_worldCOM get="inline" set="null" line="277"><f a=""><c path="nape.geom.Vec2"/></f></get_worldCOM>
		<worldCOM public="1" get="accessor" set="null">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* World space centre of mass of this Shape.
     * <br/><br/>
     * This value can be accessed even if Shape is not in a Body, but
     * attempting to query the values of it will return an error in debug
     * builds unless the Shape is in a Body.
     * <br/><br/>
     * This Vec2 is immutable.]]></haxe_doc>
		</worldCOM>
		<get_castPolygon get="inline" set="null" line="263"><f a=""><t path="Null"><c path="nape.shape.Polygon"/></t></f></get_castPolygon>
		<castPolygon public="1" get="accessor" set="null">
			<t path="Null"><c path="nape.shape.Polygon"/></t>
			<haxe_doc>* Faster equivalent to casting this to Polygon type</haxe_doc>
		</castPolygon>
		<get_castCircle get="inline" set="null" line="255"><f a=""><t path="Null"><c path="nape.shape.Circle"/></t></f></get_castCircle>
		<castCircle public="1" get="accessor" set="null">
			<t path="Null"><c path="nape.shape.Circle"/></t>
			<haxe_doc>* Faster equivalent to casting this to Circle type</haxe_doc>
		</castCircle>
		<set_body get="inline" set="null" line="240"><f a="body">
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
</f></set_body>
		<get_body get="inline" set="null" line="237"><f a=""><t path="Null"><c path="nape.phys.Body"/></t></f></get_body>
		<body public="1" get="accessor" set="accessor">
			<t path="Null"><c path="nape.phys.Body"/></t>
			<haxe_doc><![CDATA[* Body this Shape is assigned to.
     * <br/><br/>
     * This value can be set to add Shape to the given Body, and set to null
     * to remove it from its present Body.
     *
     * @default null]]></haxe_doc>
		</body>
		<isPolygon public="1" get="inline" set="null" line="207">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[* Faster equivalent to <code>type == ShapeType.POLYGON</code>
     *
     * @return True if shape is a Polygon type.]]></haxe_doc>
		</isPolygon>
		<isCircle public="1" get="inline" set="null" line="197">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[* Faster equivalent to <code>type == ShapeType.CIRCLE</code>
     *
     * @return True if shape is a Circle type.]]></haxe_doc>
		</isCircle>
		<get_type get="inline" set="null" line="187"><f a=""><c path="nape.shape.ShapeType"/></f></get_type>
		<type public="1" get="accessor" set="null">
			<c path="nape.shape.ShapeType"/>
			<haxe_doc>* Type of shape.</haxe_doc>
		</type>
		<zpp_inner public="1">
			<c path="zpp_nape.shape.ZPP_Shape"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new set="method" line="213">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc>* Base type for Nape Shape's</haxe_doc>
	</class>
	<class path="nape.shape.Circle" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/shape/Circle.hx">
		<extends path="nape.shape.Shape"/>
		<set_radius get="inline" set="null" line="321"><f a="radius">
	<x path="Float"/>
	<x path="Float"/>
</f></set_radius>
		<get_radius get="inline" set="null" line="318"><f a=""><x path="Float"/></f></get_radius>
		<radius public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Radius of circle
     * <br/><br/>
     * This value must be strictly positive, and attempting to set this value
     * whilst this Circle is part of a static Body inside a Space will result
     * in a debug time error.]]></haxe_doc>
		</radius>
		<zpp_inner_zn public="1">
			<c path="zpp_nape.shape.ZPP_Circle"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner_zn>
		<new public="1" set="method" line="196">
			<f a="radius:?localCOM:?material:?filter">
				<x path="Float"/>
				<c path="nape.geom.Vec2"/>
				<c path="nape.phys.Material"/>
				<c path="nape.dynamics.InteractionFilter"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Construct a new Circle
     *
     * @param radius The radius of the circle, this value must be positive.
     * @param localCOM The local offset for the circle. (default &#40;0,0&#41;)
     * @param material The material for this circle. (default new Material&#40;&#41;)
     * @param filter The interaction filter for this circle.
     *               (default new InteractionFilter&#40;&#41;)
     * @return The constructed Circle
     * @throws # If radius is not strictly positive
     * @throws # If localCOM is non-null, but has been disposed of.]]></haxe_doc>
		</new>
		<haxe_doc>* Shape subtype representing a Circle</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.shape.Edge" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/shape/Edge.hx">
		<toString public="1" set="method" line="321">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<get_worldVertex2 get="inline" set="null" line="311"><f a=""><c path="nape.geom.Vec2"/></f></get_worldVertex2>
		<worldVertex2 public="1" get="accessor" set="null">
			<c path="nape.geom.Vec2"/>
			<haxe_doc>* Reference to second world vertex for edge.</haxe_doc>
		</worldVertex2>
		<get_worldVertex1 get="inline" set="null" line="299"><f a=""><c path="nape.geom.Vec2"/></f></get_worldVertex1>
		<worldVertex1 public="1" get="accessor" set="null">
			<c path="nape.geom.Vec2"/>
			<haxe_doc>* Reference to first world vertex for edge.</haxe_doc>
		</worldVertex1>
		<get_localVertex2 get="inline" set="null" line="287"><f a=""><c path="nape.geom.Vec2"/></f></get_localVertex2>
		<localVertex2 public="1" get="accessor" set="null">
			<c path="nape.geom.Vec2"/>
			<haxe_doc>* Reference to second local vertex for edge.</haxe_doc>
		</localVertex2>
		<get_localVertex1 get="inline" set="null" line="275"><f a=""><c path="nape.geom.Vec2"/></f></get_localVertex1>
		<localVertex1 public="1" get="accessor" set="null">
			<c path="nape.geom.Vec2"/>
			<haxe_doc>* Reference to first local vertex for edge.</haxe_doc>
		</localVertex1>
		<get_worldProjection get="inline" set="null" line="262"><f a=""><x path="Float"/></f></get_worldProjection>
		<worldProjection public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc><![CDATA[* World projection of polygon to edge axis.
     * <br/><br/>
     * This value can only be accessed if related Polygon is part of a Body.]]></haxe_doc>
		</worldProjection>
		<get_localProjection get="inline" set="null" line="248"><f a=""><x path="Float"/></f></get_localProjection>
		<localProjection public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* Local projection of polygon onto edge axis.</haxe_doc>
		</localProjection>
		<get_length get="inline" set="null" line="236"><f a=""><x path="Float"/></f></get_length>
		<length public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* Length of edge.</haxe_doc>
		</length>
		<get_worldNormal get="inline" set="null" line="224"><f a=""><c path="nape.geom.Vec2"/></f></get_worldNormal>
		<worldNormal public="1" get="accessor" set="null">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* Normal of edge in world coordinates.
     * <br/><br/>
     * This Vec2 is immutable, and may be accessed even if the related Polygon
     * is not part of a Body but queries to its values will result in a debug
     * build error.]]></haxe_doc>
		</worldNormal>
		<get_localNormal get="inline" set="null" line="208"><f a=""><c path="nape.geom.Vec2"/></f></get_localNormal>
		<localNormal public="1" get="accessor" set="null">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* Normal of edge in local coordinates.
     * <br/><br/>
     * This Vec2 is immutable.]]></haxe_doc>
		</localNormal>
		<get_polygon get="inline" set="null" line="195"><f a=""><c path="nape.shape.Polygon"/></f></get_polygon>
		<polygon public="1" get="accessor" set="null">
			<c path="nape.shape.Polygon"/>
			<haxe_doc>* Reference to Polygon this Edge belongs to.</haxe_doc>
		</polygon>
		<zpp_inner public="1">
			<c path="zpp_nape.shape.ZPP_Edge"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="185">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc>* Edge class providing internal details of Polygon.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.shape.EdgeIterator" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/shape/EdgeIterator.hx">
		<zpp_pool public="1" line="194" static="1">
			<c path="nape.shape.EdgeIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_pool>
		<get public="1" set="method" line="217" static="1">
			<f a="list">
				<c path="nape.shape.EdgeList"/>
				<c path="nape.shape.EdgeIterator"/>
			</f>
			<haxe_doc><![CDATA[* Create iterator for Nape list.
     * <br/><br/>
     * There is no specific reason to use this over: <code>list.iterator()</code>
     * especcialy since this requires writing the class name :)
     * (This function is used internally)
     *
     * @param list The Nape list to create iterator for.
     * @return     An iterator over the Nape list.]]></haxe_doc>
		</get>
		<next public="1" get="inline" set="null" line="264">
			<f a=""><c path="nape.shape.Edge"/></f>
			<haxe_doc>* Return next element in list.
     *
     * @return The next element in iteration.</haxe_doc>
		</next>
		<hasNext public="1" get="inline" set="null" line="240">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Check if there are any elements remaining.
     *
     * @return True if there are more elements to iterator over.</haxe_doc>
		</hasNext>
		<zpp_next public="1">
			<c path="nape.shape.EdgeIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_next>
		<zpp_critical public="1">
			<x path="Bool"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_critical>
		<zpp_i public="1">
			<x path="Int"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_i>
		<zpp_inner public="1">
			<c path="nape.shape.EdgeList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="202">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Haxe Iterator<T> compatible iterator over Nape list.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.shape.EdgeList" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/shape/EdgeList.hx">
		<fromArray public="1" set="method" line="304" static="1">
			<f a="array">
				<c path="Array"><c path="nape.shape.Edge"/></c>
				<c path="nape.shape.EdgeList"/>
			</f>
			<haxe_doc>* Convert standard Array to Nape list.
     *
     * @param array The array to be converted
     * @return An equivalent Nape list.
     * @throws If array argument is null.
     * @throws If array contains elements of type other than Edge</haxe_doc>
		</fromArray>
		<filter public="1" set="method" line="779">
			<f a="lambda">
				<f a="">
					<c path="nape.shape.Edge"/>
					<x path="Bool"/>
				</f>
				<c path="nape.shape.EdgeList"/>
			</f>
			<haxe_doc><![CDATA[* Iterate over list filtering elements.
     * <br/><br/>
     * The given function will be applied to each element, whenever the
     * function returns false, the element will be removed from the list.
     * <br/><br/>
     * Any exception thrown by the supplied function will be treat as a
     * signal to halt iteration acting as a 'break' statement.
     * <br/><br/>
     * This method is to be greatly preferred for filtering logic as
     * it is otherwise unsafe to modify the list during an iteration.
     * <br/><br/>
     * An example of using this method to clean up a list whilst performing
     * actions on the elements.
     * <pre>
     * list.filter(function (obj) {
     *    // perform clean up with obj
     *    return false; // remove from list.
     * });
     * </pre>
     *
     * @param lambda The function to apply to each argument, deciding if
     *               element should be removed.
     * @return A reference to 'this' list.
     * @throws # If lambda argument is null.]]></haxe_doc>
		</filter>
		<foreach public="1" get="inline" set="null" line="732">
			<f a="lambda">
				<f a="">
					<c path="nape.shape.Edge"/>
					<x path="Void"/>
				</f>
				<c path="nape.shape.EdgeList"/>
			</f>
			<haxe_doc><![CDATA[* Iterate over list applying function.
     * <br/><br/>
     * Any exception thrown by the supplied function will be treat as a
     * signal to halt iteration acting as a 'break' statement.
     * <br/><br/>
     * This method should be preferred to using standard haxe iteration
     * as there will be no allocation of an iterator object.
     * <pre>
     * list.foreach(function (obj) {
     *     if (ignore_object(obj)) return; //acts as a 'continue' statement
     *     if (halt_iteration(obj)) throw "": //acts as a 'break' statement
     * });
     * </pre>
     *
     * @param lambda The function to apply to each argument.
     * @return A reference to 'this' list.
     * @throws # If lambda argument is null.]]></haxe_doc>
		</foreach>
		<toString public="1" set="method" line="702">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<merge public="1" set="method" line="684">
			<f a="xs">
				<c path="nape.shape.EdgeList"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Merge given list into this one.
     * <br/><br/>
     * The result is that this list will have all objects from the argument
     * that were not already in the list inserted. You should make no
     * assumption about the order of these insertions.
     *
     * @param xs The list to merge.
     * @throws # If xs argument is null.]]></haxe_doc>
		</merge>
		<copy public="1" set="method" line="662">
			<f a="?deep">
				<x path="Bool"/>
				<c path="nape.shape.EdgeList"/>
			</f>
			<haxe_doc>* Produce a possibly deep copy of list.
     *
     * @param deep If true, then each element will have its own copy
     *             function called instead of simply having its
     *             reference copied over.
     * @return     The copied list.</haxe_doc>
		</copy>
		<iterator public="1" get="inline" set="null" line="647">
			<f a=""><c path="nape.shape.EdgeIterator"/></f>
			<haxe_doc><![CDATA[* Return Haxe iterator for list.
     * <br/><br/>
     * Use of this iterator, whilst stylistically better in Haxe should not
     * be used, in preference for use of the foreach function which will
     * not require allocation of an iterator object.
     * <br/><br/>
     * Equally in AS3, the foreach method should be the preferred way to iterate.]]></haxe_doc>
		</iterator>
		<empty public="1" get="inline" set="null" line="631">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Test if list is empty or not.
     *
     * @return True if list is empty.</haxe_doc>
		</empty>
		<clear public="1" set="method" line="614">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clear the list, removing all elements.
     *
     * @throws # If list is iummutable</haxe_doc>
		</clear>
		<remove public="1" set="method" line="576">
			<f a="obj">
				<c path="nape.shape.Edge"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Remove element from list.
     * <br/><br/>
     * This is a linear time operation.
     *
     * @param obj The object to remove
     * @return True if object was removed from list.
     * @throws # If list is immutable]]></haxe_doc>
		</remove>
		<add public="1" get="inline" set="null" line="563">
			<f a="obj">
				<c path="nape.shape.Edge"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Insert element into list in most effecient way.
     * <br/><br/>
     * This method will defer to either the push or unshift function
     * depending on which is most effecient in the context.
     * <br/><br/>
     * If order of elements is not important then you should always use
     * this function to insert elements.
     *
     * @param obj The object to insert.
     * @return True if object was successfuly inserted.
     * @throws # If list is immutable]]></haxe_doc>
		</add>
		<shift public="1" set="method" line="519">
			<f a=""><c path="nape.shape.Edge"/></f>
			<haxe_doc><![CDATA[* Pop element from front of list.
     * <br/><br/>
     * If you are wanting to clear a list, whilst operating on its elements,
     * consider use of the filter method instead.
     *
     * @returns The element removed from list.
     * @throws # If list is immutable.
     * @throws # If the list is empty.]]></haxe_doc>
		</shift>
		<pop public="1" set="method" line="478">
			<f a=""><c path="nape.shape.Edge"/></f>
			<haxe_doc><![CDATA[* Pop element from back of list.
     * <br/><br/>
     * If you are wanting to clear a list, whilst operating on its elements,
     * consider use of the filter method instead.
     *
     * @returns The element removed from list.
     * @throws # If list is immutable.
     * @throws # If the list is empty.]]></haxe_doc>
		</pop>
		<unshift public="1" set="method" line="447">
			<f a="obj">
				<c path="nape.shape.Edge"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Push element to front of list.
     * <br/><br/>
     * When the order of objects is not important, it is best to use the
     * add() method instead.
     *
     * @param obj The object to insert.
     * @returns True if object was successively inserted.
     * @throws # If list is immutable.]]></haxe_doc>
		</unshift>
		<push public="1" set="method" line="416">
			<f a="obj">
				<c path="nape.shape.Edge"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Push element to back of list.
     * <br/><br/>
     * When the order of objects is not important, it is best to use the
     * add() method instead.
     *
     * @param obj The object to insert.
     * @returns True if object was successively inserted.
     * @throws # If list is immutable.]]></haxe_doc>
		</push>
		<at public="1" set="method" line="363">
			<f a="index">
				<x path="Int"/>
				<c path="nape.shape.Edge"/>
			</f>
			<haxe_doc><![CDATA[* Random access to elements of list by index.
     * <br/><br/>
     * Under normal circumstances, accessing succesive elements via this
     * method will occur in constant time.
     *
     * @param index The index of the element in list to access.
     * @returns The element at the given index.
     * @throws # If index is out of bounds.]]></haxe_doc>
		</at>
		<has public="1" set="method" line="346">
			<f a="obj">
				<c path="nape.shape.Edge"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if element is already in the list
     *
     * @param obj The object to test.
     * @return True if object is in the list.</haxe_doc>
		</has>
		<get_length get="inline" set="null" line="244"><f a=""><x path="Int"/></f></get_length>
		<length public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Length of list.</haxe_doc>
		</length>
		<zpp_inner public="1">
			<c path="zpp_nape.util.ZPP_EdgeList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="695">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Construct a new list.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Nape list of Edge type objects
 * <br/><br/>
 * Internally this list is at present implemented as a linked list with
 * object pooled nodes and iterators with various fast paths made for
 * standard access patterns (For instance accessing successive elements
 * runs in constant time when using random access functions)
 * <br/><br/>
 * Iteration of this list can be done in various ways, but the preferred
 * way on all targets, is through use of the foreach function:
 * <pre>
 * list.foreach(function (obj) {
 * });
 * </pre>
 * This method is inlined so that in haxe no closure will need to be created.
 * <br/><br/>
 * In AS3, a closure would need to be created in general, so for performance
 * reasons you 'may' choose to use iteration as follows:
 * <pre>
 * for (var i:int = 0; i < list.length; i++) {
 *     var obj:Edge = list.at(i);
 * }
 * </pre>
 * <br/>
 * NOTE: It is 'not' safe to modify a list whilst iterating over it.
 * If you wish to remove elements during an iteration you should use the
 * filter method, for example:
 * <pre>
 * list.filter(function (obj) {
 *     // operate on object.
 *     // ...
 *     return (false if you want object to be removed);
 * });
 * </pre>
 * <br/><br/>
 * In AS3, if you wish to avoid a closure generation, you can perform such
 * an iteration in a safe manner as follows:
 * <pre>
 * var i:int = 0;
 * while (i < list.length) {
 *     var obj:Edge = list.at(i);
 *     // operate on object.
 *     // ...
 *     if (should remove obj) {
 *         list.remove(obj);
 *         continue;
 *     }
 *     else i++;
 * }
 * </pre>
 * Or if you are always clearing the list entirely you could write:
 * <pre>
 * while (!list.empty()) {
 *     var obj:Edge = list.pop();
 *     // operate on object.
 *     // ...
 * }
 * </pre>]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.shape.Polygon" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/shape/Polygon.hx">
		<extends path="nape.shape.Shape"/>
		<rect public="1" set="method" line="209" static="1">
			<f a="x:y:width:height:?weak">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="Array"><c path="nape.geom.Vec2"/></c>
			</f>
			<haxe_doc><![CDATA[* Construct a polygon representing a rectangle.
     * <br/><br/>
     * For a dynamic object, you may consider use of the box method instead
     * as dynamic bodies will only respond as expected if their centre of mass
     * is equal to the origin.
     * <br/><br/>
     * The generate polygon will have coordinates equal to:
     * <pre>
     * (x, y) -> (x + width, y + height)
     * </pre>
     * Negative values of width/height are permitted so that the given x/y values
     * may not necessarigly be the top-left corner of rectangle.
     *
     * @param x The x coordinate of rectangle.
     * @param y The y coordinate of rectangle.
     * @param width The width of the ractangle. This value may be negative.
     * @param height The height of the rectangle This value may be negative.
     * @param weak If true, the generated list of vertices will be allocated as
     *             weak Vec2s so that when this list is passed to a Nape function
     *             these Vec2s will be automatically sent back to object pool.
     *             (default false)
     * @return An array of Vec2 representing the given rectangle.]]></haxe_doc>
		</rect>
		<box public="1" set="method" line="231" static="1">
			<f a="width:height:?weak">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="Array"><c path="nape.geom.Vec2"/></c>
			</f>
			<haxe_doc><![CDATA[* Construct a polygon representing an origin centred box.
     * <br/><br/>
     * This method is equivalent to calling: <code>Polygon.rect(-width/2,-height/2,width,height)</code>
     *
     * @param width The width of the box (This value may be negative but will
     *              make no difference).
     * @param height The height of the box (This value may be negative but will
     *              make no difference).
     * @param weak If true, the generated list of vertices will be allocated as
     *             weak Vec2s so that when this list is passed to a Nape function
     *             these Vec2s will be automatically sent back to object pool.
     *             (default false)
     * @return An array of Vec2 representing the given box.]]></haxe_doc>
		</box>
		<regular public="1" set="method" line="257" static="1">
			<f a="xRadius:yRadius:edgeCount:?angleOffset:?weak">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="Array"><c path="nape.geom.Vec2"/></c>
			</f>
			<haxe_doc><![CDATA[* Construct a regular polygon centred at origin.
     * <br/><br/>
     * Vertices are created at positions on the edge of an ellipsoid of given
     * radii, when radii are not equal the vertices will not have an equal
     * angle between them; it will be as though an actual regular polygon were
     * created, and then squashed to conform to the input radii.
     *
     * @param xRadius The x radius of polygon before angleOffset rotation.
     * @param yRadius The y radius of polygon before angleOffset rotation.
     * @param edgeCount The number of edges/vertices in polygon.
     * @param angleOffset The clockwise angular offset to generate vertices at
     *                    in radians. (default 0.0)
     * @param weak If true, the generated list of vertices will be allocated as
     *             weak Vec2s so that when this list is passed to a Nape function
     *             these Vec2s will be automatically sent back to object pool.
     *             (default false)
     * @return An array of Vec2 representing the polygon.]]></haxe_doc>
		</regular>
		<validity public="1" set="method" line="312">
			<f a=""><c path="nape.shape.ValidationResult"/></f>
			<haxe_doc>* Determine validity of polygon for use in a Nape simulation.</haxe_doc>
		</validity>
		<get_edges get="inline" set="null" line="304"><f a=""><c path="nape.shape.EdgeList"/></f></get_edges>
		<edges public="1" get="accessor" set="null">
			<c path="nape.shape.EdgeList"/>
			<haxe_doc><![CDATA[* Set of edges on polygon.
     * <br/><br/>
     * This list is immutable.]]></haxe_doc>
		</edges>
		<get_worldVerts get="inline" set="null" line="293"><f a=""><c path="nape.geom.Vec2List"/></f></get_worldVerts>
		<worldVerts public="1" get="accessor" set="null">
			<c path="nape.geom.Vec2List"/>
			<haxe_doc><![CDATA[* World coordinates of vertices.
     * <br/><br/>
     * This list can be accessed, but any queries of values will result
     * in an error in debug builds unless this Polygon is part of a Body.
     * <br/><br/>
     * This list is immutable.]]></haxe_doc>
		</worldVerts>
		<get_localVerts get="inline" set="null" line="279"><f a=""><c path="nape.geom.Vec2List"/></f></get_localVerts>
		<localVerts public="1" get="accessor" set="null">
			<c path="nape.geom.Vec2List"/>
			<haxe_doc><![CDATA[* Local coordinates of vertices.
     * <br/><br/>
     * This list can be modified, but modifications to a Polygon that is
     * part of a static Body inside of a Space will given an error in
     * debug builds.]]></haxe_doc>
		</localVerts>
		<zpp_inner_zn public="1">
			<c path="zpp_nape.shape.ZPP_Polygon"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner_zn>
		<new public="1" set="method" line="331">
			<f a="localVerts:?material:?filter">
				<d/>
				<c path="nape.phys.Material"/>
				<c path="nape.dynamics.InteractionFilter"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Construct a new Polygon.
     * <br/><br/>
     * The localVerts parameter is typed Dynamic and may be one of:
     * <code>Array&lt;Vec2&gt;, flash.Vector&lt;Vec2&gt;, Vec2List, GeomPoly</code>
     *
     * @param localVerts The local vertices of polygon.
     * @param material The material for this polygon. (default new Material&#40;&#41;)
     * @param filter The interaction filter for this polygon.
     *               (default new InteractionFilter&#40;&#41;)
     * @return The constructed Polygon.
     * @throws # If localVerts is null, or not of the expected Type.
     * @throws # If localVerts contains any disposed or null Vec2.]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Polygon subtype of Shape.
 * <br/><br/>
 * Can be used to simulate any convex polygon.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.shape.ShapeIterator" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/shape/ShapeIterator.hx">
		<zpp_pool public="1" line="194" static="1">
			<c path="nape.shape.ShapeIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_pool>
		<get public="1" set="method" line="217" static="1">
			<f a="list">
				<c path="nape.shape.ShapeList"/>
				<c path="nape.shape.ShapeIterator"/>
			</f>
			<haxe_doc><![CDATA[* Create iterator for Nape list.
     * <br/><br/>
     * There is no specific reason to use this over: <code>list.iterator()</code>
     * especcialy since this requires writing the class name :)
     * (This function is used internally)
     *
     * @param list The Nape list to create iterator for.
     * @return     An iterator over the Nape list.]]></haxe_doc>
		</get>
		<next public="1" get="inline" set="null" line="264">
			<f a=""><c path="nape.shape.Shape"/></f>
			<haxe_doc>* Return next element in list.
     *
     * @return The next element in iteration.</haxe_doc>
		</next>
		<hasNext public="1" get="inline" set="null" line="240">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Check if there are any elements remaining.
     *
     * @return True if there are more elements to iterator over.</haxe_doc>
		</hasNext>
		<zpp_next public="1">
			<c path="nape.shape.ShapeIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_next>
		<zpp_critical public="1">
			<x path="Bool"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_critical>
		<zpp_i public="1">
			<x path="Int"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_i>
		<zpp_inner public="1">
			<c path="nape.shape.ShapeList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="202">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Haxe Iterator<T> compatible iterator over Nape list.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.shape.ShapeList" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/shape/ShapeList.hx">
		<fromArray public="1" set="method" line="304" static="1">
			<f a="array">
				<c path="Array"><c path="nape.shape.Shape"/></c>
				<c path="nape.shape.ShapeList"/>
			</f>
			<haxe_doc>* Convert standard Array to Nape list.
     *
     * @param array The array to be converted
     * @return An equivalent Nape list.
     * @throws If array argument is null.
     * @throws If array contains elements of type other than Shape</haxe_doc>
		</fromArray>
		<filter public="1" set="method" line="779">
			<f a="lambda">
				<f a="">
					<c path="nape.shape.Shape"/>
					<x path="Bool"/>
				</f>
				<c path="nape.shape.ShapeList"/>
			</f>
			<haxe_doc><![CDATA[* Iterate over list filtering elements.
     * <br/><br/>
     * The given function will be applied to each element, whenever the
     * function returns false, the element will be removed from the list.
     * <br/><br/>
     * Any exception thrown by the supplied function will be treat as a
     * signal to halt iteration acting as a 'break' statement.
     * <br/><br/>
     * This method is to be greatly preferred for filtering logic as
     * it is otherwise unsafe to modify the list during an iteration.
     * <br/><br/>
     * An example of using this method to clean up a list whilst performing
     * actions on the elements.
     * <pre>
     * list.filter(function (obj) {
     *    // perform clean up with obj
     *    return false; // remove from list.
     * });
     * </pre>
     *
     * @param lambda The function to apply to each argument, deciding if
     *               element should be removed.
     * @return A reference to 'this' list.
     * @throws # If lambda argument is null.]]></haxe_doc>
		</filter>
		<foreach public="1" get="inline" set="null" line="732">
			<f a="lambda">
				<f a="">
					<c path="nape.shape.Shape"/>
					<x path="Void"/>
				</f>
				<c path="nape.shape.ShapeList"/>
			</f>
			<haxe_doc><![CDATA[* Iterate over list applying function.
     * <br/><br/>
     * Any exception thrown by the supplied function will be treat as a
     * signal to halt iteration acting as a 'break' statement.
     * <br/><br/>
     * This method should be preferred to using standard haxe iteration
     * as there will be no allocation of an iterator object.
     * <pre>
     * list.foreach(function (obj) {
     *     if (ignore_object(obj)) return; //acts as a 'continue' statement
     *     if (halt_iteration(obj)) throw "": //acts as a 'break' statement
     * });
     * </pre>
     *
     * @param lambda The function to apply to each argument.
     * @return A reference to 'this' list.
     * @throws # If lambda argument is null.]]></haxe_doc>
		</foreach>
		<toString public="1" set="method" line="702">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<merge public="1" set="method" line="684">
			<f a="xs">
				<c path="nape.shape.ShapeList"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Merge given list into this one.
     * <br/><br/>
     * The result is that this list will have all objects from the argument
     * that were not already in the list inserted. You should make no
     * assumption about the order of these insertions.
     *
     * @param xs The list to merge.
     * @throws # If xs argument is null.]]></haxe_doc>
		</merge>
		<copy public="1" set="method" line="662">
			<f a="?deep">
				<x path="Bool"/>
				<c path="nape.shape.ShapeList"/>
			</f>
			<haxe_doc>* Produce a possibly deep copy of list.
     *
     * @param deep If true, then each element will have its own copy
     *             function called instead of simply having its
     *             reference copied over.
     * @return     The copied list.</haxe_doc>
		</copy>
		<iterator public="1" get="inline" set="null" line="647">
			<f a=""><c path="nape.shape.ShapeIterator"/></f>
			<haxe_doc><![CDATA[* Return Haxe iterator for list.
     * <br/><br/>
     * Use of this iterator, whilst stylistically better in Haxe should not
     * be used, in preference for use of the foreach function which will
     * not require allocation of an iterator object.
     * <br/><br/>
     * Equally in AS3, the foreach method should be the preferred way to iterate.]]></haxe_doc>
		</iterator>
		<empty public="1" get="inline" set="null" line="631">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Test if list is empty or not.
     *
     * @return True if list is empty.</haxe_doc>
		</empty>
		<clear public="1" set="method" line="614">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clear the list, removing all elements.
     *
     * @throws # If list is iummutable</haxe_doc>
		</clear>
		<remove public="1" set="method" line="576">
			<f a="obj">
				<c path="nape.shape.Shape"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Remove element from list.
     * <br/><br/>
     * This is a linear time operation.
     *
     * @param obj The object to remove
     * @return True if object was removed from list.
     * @throws # If list is immutable]]></haxe_doc>
		</remove>
		<add public="1" get="inline" set="null" line="563">
			<f a="obj">
				<c path="nape.shape.Shape"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Insert element into list in most effecient way.
     * <br/><br/>
     * This method will defer to either the push or unshift function
     * depending on which is most effecient in the context.
     * <br/><br/>
     * If order of elements is not important then you should always use
     * this function to insert elements.
     *
     * @param obj The object to insert.
     * @return True if object was successfuly inserted.
     * @throws # If list is immutable]]></haxe_doc>
		</add>
		<shift public="1" set="method" line="519">
			<f a=""><c path="nape.shape.Shape"/></f>
			<haxe_doc><![CDATA[* Pop element from front of list.
     * <br/><br/>
     * If you are wanting to clear a list, whilst operating on its elements,
     * consider use of the filter method instead.
     *
     * @returns The element removed from list.
     * @throws # If list is immutable.
     * @throws # If the list is empty.]]></haxe_doc>
		</shift>
		<pop public="1" set="method" line="478">
			<f a=""><c path="nape.shape.Shape"/></f>
			<haxe_doc><![CDATA[* Pop element from back of list.
     * <br/><br/>
     * If you are wanting to clear a list, whilst operating on its elements,
     * consider use of the filter method instead.
     *
     * @returns The element removed from list.
     * @throws # If list is immutable.
     * @throws # If the list is empty.]]></haxe_doc>
		</pop>
		<unshift public="1" set="method" line="447">
			<f a="obj">
				<c path="nape.shape.Shape"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Push element to front of list.
     * <br/><br/>
     * When the order of objects is not important, it is best to use the
     * add() method instead.
     *
     * @param obj The object to insert.
     * @returns True if object was successively inserted.
     * @throws # If list is immutable.]]></haxe_doc>
		</unshift>
		<push public="1" set="method" line="416">
			<f a="obj">
				<c path="nape.shape.Shape"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Push element to back of list.
     * <br/><br/>
     * When the order of objects is not important, it is best to use the
     * add() method instead.
     *
     * @param obj The object to insert.
     * @returns True if object was successively inserted.
     * @throws # If list is immutable.]]></haxe_doc>
		</push>
		<at public="1" set="method" line="363">
			<f a="index">
				<x path="Int"/>
				<c path="nape.shape.Shape"/>
			</f>
			<haxe_doc><![CDATA[* Random access to elements of list by index.
     * <br/><br/>
     * Under normal circumstances, accessing succesive elements via this
     * method will occur in constant time.
     *
     * @param index The index of the element in list to access.
     * @returns The element at the given index.
     * @throws # If index is out of bounds.]]></haxe_doc>
		</at>
		<has public="1" set="method" line="346">
			<f a="obj">
				<c path="nape.shape.Shape"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if element is already in the list
     *
     * @param obj The object to test.
     * @return True if object is in the list.</haxe_doc>
		</has>
		<get_length get="inline" set="null" line="244"><f a=""><x path="Int"/></f></get_length>
		<length public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Length of list.</haxe_doc>
		</length>
		<zpp_inner public="1">
			<c path="zpp_nape.util.ZPP_ShapeList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="695">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Construct a new list.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Nape list of Shape type objects
 * <br/><br/>
 * Internally this list is at present implemented as a linked list with
 * object pooled nodes and iterators with various fast paths made for
 * standard access patterns (For instance accessing successive elements
 * runs in constant time when using random access functions)
 * <br/><br/>
 * Iteration of this list can be done in various ways, but the preferred
 * way on all targets, is through use of the foreach function:
 * <pre>
 * list.foreach(function (obj) {
 * });
 * </pre>
 * This method is inlined so that in haxe no closure will need to be created.
 * <br/><br/>
 * In AS3, a closure would need to be created in general, so for performance
 * reasons you 'may' choose to use iteration as follows:
 * <pre>
 * for (var i:int = 0; i < list.length; i++) {
 *     var obj:Shape = list.at(i);
 * }
 * </pre>
 * <br/>
 * NOTE: It is 'not' safe to modify a list whilst iterating over it.
 * If you wish to remove elements during an iteration you should use the
 * filter method, for example:
 * <pre>
 * list.filter(function (obj) {
 *     // operate on object.
 *     // ...
 *     return (false if you want object to be removed);
 * });
 * </pre>
 * <br/><br/>
 * In AS3, if you wish to avoid a closure generation, you can perform such
 * an iteration in a safe manner as follows:
 * <pre>
 * var i:int = 0;
 * while (i < list.length) {
 *     var obj:Shape = list.at(i);
 *     // operate on object.
 *     // ...
 *     if (should remove obj) {
 *         list.remove(obj);
 *         continue;
 *     }
 *     else i++;
 * }
 * </pre>
 * Or if you are always clearing the list entirely you could write:
 * <pre>
 * while (!list.empty()) {
 *     var obj:Shape = list.pop();
 *     // operate on object.
 *     // ...
 * }
 * </pre>]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.shape.ShapeType" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/shape/ShapeType.hx">
		<CIRCLE public="1" get="accessor" set="null" static="1">
			<c path="nape.shape.ShapeType"/>
			<haxe_doc>* Circle shape type</haxe_doc>
		</CIRCLE>
		<get_CIRCLE get="inline" set="null" line="201" static="1"><f a=""><c path="nape.shape.ShapeType"/></f></get_CIRCLE>
		<POLYGON public="1" get="accessor" set="null" static="1">
			<c path="nape.shape.ShapeType"/>
			<haxe_doc>* Polygon shape type</haxe_doc>
		</POLYGON>
		<get_POLYGON get="inline" set="null" line="214" static="1"><f a=""><c path="nape.shape.ShapeType"/></f></get_POLYGON>
		<toString public="1" set="method" line="189">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<new public="1" set="method" line="181">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc>* Enumeration of Nape Shape types.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.shape.ValidationResult" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/shape/ValidationResult.hx">
		<VALID public="1" get="accessor" set="null" static="1">
			<c path="nape.shape.ValidationResult"/>
			<haxe_doc>* Denotes polygon is valid for simulation in Nape.</haxe_doc>
		</VALID>
		<get_VALID get="inline" set="null" line="203" static="1"><f a=""><c path="nape.shape.ValidationResult"/></f></get_VALID>
		<DEGENERATE public="1" get="accessor" set="null" static="1">
			<c path="nape.shape.ValidationResult"/>
			<haxe_doc>* Denotes polygon is degenerate (has zero area).</haxe_doc>
		</DEGENERATE>
		<get_DEGENERATE get="inline" set="null" line="216" static="1"><f a=""><c path="nape.shape.ValidationResult"/></f></get_DEGENERATE>
		<CONCAVE public="1" get="accessor" set="null" static="1">
			<c path="nape.shape.ValidationResult"/>
			<haxe_doc>* Denotes polygon is concave.</haxe_doc>
		</CONCAVE>
		<get_CONCAVE get="inline" set="null" line="229" static="1"><f a=""><c path="nape.shape.ValidationResult"/></f></get_CONCAVE>
		<SELF_INTERSECTING public="1" get="accessor" set="null" static="1">
			<c path="nape.shape.ValidationResult"/>
			<haxe_doc>* Denotes polygon is self-intersecting.</haxe_doc>
		</SELF_INTERSECTING>
		<get_SELF_INTERSECTING get="inline" set="null" line="242" static="1"><f a=""><c path="nape.shape.ValidationResult"/></f></get_SELF_INTERSECTING>
		<toString public="1" set="method" line="189">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<new public="1" set="method" line="181">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc>* Enumeration of validation results for a Polygon.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.space.Broadphase" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/space/Broadphase.hx">
		<DYNAMIC_AABB_TREE public="1" get="accessor" set="null" static="1">
			<c path="nape.space.Broadphase"/>
			<haxe_doc><![CDATA[* Dynamic AABB Tree broadphase.
     * <br/><br/>
     * This broadphase uses a pair of binary trees with objects inserted based
     * on containment of their AABB.
     * <br/><br/>
     * This is a general purpose broadphase which does not suffer for objects
     * of varying sizes, or objects moving very quickly and is well set for such
     * acts as ray casting and spatial queries like objectsInAABB of the Space type.
     * <br/><br/>
     * This is the default broadphase nape will use.]]></haxe_doc>
		</DYNAMIC_AABB_TREE>
		<get_DYNAMIC_AABB_TREE get="inline" set="null" line="210" static="1"><f a=""><c path="nape.space.Broadphase"/></f></get_DYNAMIC_AABB_TREE>
		<SWEEP_AND_PRUNE public="1" get="accessor" set="null" static="1">
			<c path="nape.space.Broadphase"/>
			<haxe_doc><![CDATA[* Sweep and prune broadphase.
     * <br/><br/>
     * This is a very simple broadphase using the x-axis to keep objects
     * sorted by their minimum x coordinate.
     * <br/><br/>
     * Performance of this broadphase is generally good and in some circumstances
     * superior to the DYNAMIC_AABB_TREE broadphase.
     * <br/><br/>
     * This broadphase will however be much slower for things such as ray casts and
     * spatial queries like objectsInAABB on the Space type.
     * Also in cases where lots of objects are moving very quickly or when there is a
     * large variety in the size of objects.
     * <br/><br/>
     * Due to the simplicity of this broadphase, it serves as a good test should you
     * ever feel there might be something going wrong with the DYNAMIC_AABB_TREE
     * broadphase type.]]></haxe_doc>
		</SWEEP_AND_PRUNE>
		<get_SWEEP_AND_PRUNE get="inline" set="null" line="238" static="1"><f a=""><c path="nape.space.Broadphase"/></f></get_SWEEP_AND_PRUNE>
		<toString public="1" set="method" line="189">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</toString>
		<new public="1" set="method" line="181">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc>* Enumeration of available broadphase collision types that Spaces may use.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.space.Space" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/space/Space.hx">
		<rayMultiCast public="1" set="method" line="1048">
			<f a="ray:?inner:?filter:?output">
				<c path="nape.geom.Ray"/>
				<x path="Bool"/>
				<c path="nape.dynamics.InteractionFilter"/>
				<c path="nape.geom.RayResultList"/>
				<c path="nape.geom.RayResultList"/>
			</f>
			<haxe_doc><![CDATA[* Perform a ray cast for all valid results.
     * <br/><br/>
     * This method will return all intersections (in distance order) of ray
     * with shapes in the space up to the ray's maxDistance.
     * <br/><br/>
     * If the filter argument is null, then all shapes will be intersectable
     * otherwise only those for whose filter agrees to 'collide'.
     *
     * @param ray The ray to cast through space.
     * @param inner If true then inner surfaces of shapes will also be intersected.
     *              otherwise only the outer surfaces. (default false)
     * @param filter Optional filter to pick and choose shapes, based on whether
     *               the filters agree to collide. (default null)
     * @param output A list to append results to instead of allocating a new one (default null)
     * @return All valid results of ray cast in distance order from closest to furthest.
     * @throws # If ray is null.]]></haxe_doc>
		</rayMultiCast>
		<rayCast public="1" set="method" line="1023">
			<f a="ray:?inner:?filter">
				<c path="nape.geom.Ray"/>
				<x path="Bool"/>
				<c path="nape.dynamics.InteractionFilter"/>
				<t path="Null"><c path="nape.geom.RayResult"/></t>
			</f>
			<haxe_doc><![CDATA[* Perform a ray cast for closest result.
     * <br/><br/>
     * This method will return only the closest result (if any), to find more
     * the first result, use the rayMultiCast method. The ray will not be
     * cast beyond its maxDistance.
     * <br/><br/>
     * If the filter argument is null, then all shapes will be intersectable
     * otherwise only those for whose filter agrees to 'collide'.
     *
     * @param ray The ray to cast through space.
     * @param inner If true then inner surfaces of shapes will also be intersected.
     *              otherwise only the outer surfaces. (default false)
     * @param filter Optional filter to pick and choose shapes, based on whether
     *               the filters agree to collide. (default null)
     * @return The closest result (if any) of ray intersection.
     * @throws # If ray is null.]]></haxe_doc>
		</rayCast>
		<convexMultiCast public="1" set="method" line="992">
			<f a="shape:deltaTime:?liveSweep:?filter:output">
				<c path="nape.shape.Shape"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="nape.dynamics.InteractionFilter"/>
				<c path="nape.geom.ConvexResultList"/>
				<c path="nape.geom.ConvexResultList"/>
			</f>
			<haxe_doc><![CDATA[* Perform a convex cast for all collisions in time order.
     * <br/><br/>
     * This method will return all collisions, or an empty list if there are none.
     * The shape will not be
     * swept further than the time delta provided. Shapes already intersecting
     * the sweep shape at t = 0 are ignored.
     * <br/><br/>
     * If the filter argument is null, then all shapes will be collidable
     * otherwise only those for whose filter agrees to 'collide'.
     *
     * @param shape The Shape to be cast through space. This shape must belong
     *              to a body whose velocity is used to define the sweep.
     * @param deltaTime The amount of time to sweep the shape forward.
     * @param liveSweep If true, then moving objects in the space will have their motion considered during the sweep. Otherwise; like with normal rayCast, objects in the space are considered un-moving for the cast. (default false)
     * @param filter Optional filter to pick and choose shapes, based on whether
     *               the filters agree to collide. (default null)
     * @param output A list to append results to instead of allocating a new one (default null)
     * @return The collision results in time order.
     * @throws # If shape is null, or not part of a body.
     * @throws # If deltaTime is negative.]]></haxe_doc>
		</convexMultiCast>
		<convexCast public="1" set="method" line="957">
			<f a="shape:deltaTime:?liveSweep:?filter">
				<c path="nape.shape.Shape"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="nape.dynamics.InteractionFilter"/>
				<t path="Null"><c path="nape.geom.ConvexResult"/></t>
			</f>
			<haxe_doc><![CDATA[* Perform a convex cast for soonest collision.
     * <br/><br/>
     * This method will return only the soonest collision result (if any), to find
     * more than this, use the convexMultiCast method. The shape will not be
     * swept further than the time delta provided.
     * Shapes already intersecting
     * the sweep shape at t = 0 are ignored.
     * <br/><br/>
     * If the filter argument is null, then all shapes will be collidable
     * otherwise only those for whose filter agrees to 'collide'.
     *
     * @param shape The Shape to be cast through space. This shape must belong
     *              to a body whose velocity is used to define the sweep.
     * @param deltaTime The amount of time to sweep the shape forward.
     * @param liveSweep If true, then moving objects in the space will have their motion considered during the sweep. Otherwise; like with normal rayCast, objects in the space are considered un-moving for the cast. (default false)
     * @param filter Optional filter to pick and choose shapes, based on whether
     *               the filters agree to collide. (default null)
     * @return The soonest result (if any) of convex intersection.
     * @throws # If shape is null, or not part of a body.
     * @throws # If deltaTime is negative.]]></haxe_doc>
		</convexCast>
		<bodiesInBody public="1" set="method" line="924">
			<f a="body:?filter:?output">
				<c path="nape.phys.Body"/>
				<c path="nape.dynamics.InteractionFilter"/>
				<c path="nape.phys.BodyList"/>
				<c path="nape.phys.BodyList"/>
			</f>
			<haxe_doc><![CDATA[* Evaluate all Bodies given a Body.
     * <br/><br/>
     * If the filter argument is non-null, then only bodies with a shape
     * classified as being part of the input body, whose filter agrees to collide
     * will be considered. The input body is considered a purely geometric
     *
     * @param body The body to use in classifying other bodies.
     * @param filter Optional filter to pick and choose shapes, based on whether
     *               the filters agree to collide. (default null)
     * @param output Optional list to append results to instead of creating a new list (default null).
     * @return A list of all the bodies for given body.
     * @throws # If body is null.
     * @throws # If body has a shape that is a polygon, and that polygon is not 'valid']]></haxe_doc>
		</bodiesInBody>
		<shapesInBody public="1" set="method" line="898">
			<f a="body:?filter:?output">
				<c path="nape.phys.Body"/>
				<c path="nape.dynamics.InteractionFilter"/>
				<c path="nape.shape.ShapeList"/>
				<c path="nape.shape.ShapeList"/>
			</f>
			<haxe_doc><![CDATA[* Evaluate all Shapes given a Body.
     * <br/><br/>
     * If the filter argument is non-null, then only shapes who's filter
     * agrees to 'collide' will be considered. The input body's shape's own filters
     * are never used in this method. The input body is considered a purely
     * geometric object.
     *
     * @param body The body to use in classifying other shapes.
     * @param filter Optional filter to pick and choose shapes, based on whether
     *               the filters agree to collide. (default null)
     * @param output Optional list to append results to instead of creating a new list (default null).
     * @return A list of all the shapes for given body.
     * @throws # If body is null.
     * @throws # If body has a shape that is a polygon, and that polygon is not 'valid']]></haxe_doc>
		</shapesInBody>
		<bodiesInShape public="1" set="method" line="870">
			<f a="shape:?containment:?filter:?output">
				<c path="nape.shape.Shape"/>
				<x path="Bool"/>
				<c path="nape.dynamics.InteractionFilter"/>
				<c path="nape.phys.BodyList"/>
				<c path="nape.phys.BodyList"/>
			</f>
			<haxe_doc><![CDATA[* Evaluate all Bodies given a shape.
     * <br/><br/>
     * If the filter argument is non-null, then only bodies with a shape
     * classified as being part of the input shape, whose filter agrees to collide
     * will be considered. The input shape is considered a purely geometric
     * <br/><br/>
     * The input shape must be part of a Body so as to be well defined.
     *
     * @param shape The shape to use in classifying other shapes.
     * @param containment If true, then only Bodies entirely contained (Rather
     *                    than simply intersecting) will be considered.
     *                    (default false)
     * @param filter Optional filter to pick and choose shapes, based on whether
     *               the filters agree to collide. (default null)
     * @param output Optional list to append results to instead of creating a new list (default null).
     * @return A list of all the bodies for given shape.
     * @throws # If shape is null or not part of a body.
     * @throws # If shape is a polygon, and that polygon is not 'valid']]></haxe_doc>
		</bodiesInShape>
		<shapesInShape public="1" set="method" line="838">
			<f a="shape:?containment:?filter:?output">
				<c path="nape.shape.Shape"/>
				<x path="Bool"/>
				<c path="nape.dynamics.InteractionFilter"/>
				<c path="nape.shape.ShapeList"/>
				<c path="nape.shape.ShapeList"/>
			</f>
			<haxe_doc><![CDATA[* Evaluate all Shapes given another shape.
     * <br/><br/>
     * If the filter argument is non-null, then only shapes who's filter
     * agrees to 'collide' will be considered. The input shape's own filter
     * is never used in this method. The input shape is considered a purely
     * geometric object.
     * <br/><br/>
     * The input shape must be part of a Body so as to be well defined.
     *
     * @param shape The shape to use in classifying other shapes.
     * @param containment If true, then only Shapes entirely contained (Rather
     *                    than simply intersected) will be considered.
     *                    (default false)
     * @param filter Optional filter to pick and choose shapes, based on whether
     *               the filters agree to collide. (default null)
     * @param output Optional list to append results to instead of creating a new list (default null).
     * @return A list of all the shapes for given shape.
     * @throws # If shape is null or not part of a body.
     * @throws # If shape is a polygon, and that polygon is not 'valid']]></haxe_doc>
		</shapesInShape>
		<bodiesInCircle public="1" set="method" line="791">
			<f a="position:radius:?containment:?filter:?output">
				<c path="nape.geom.Vec2"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="nape.dynamics.InteractionFilter"/>
				<c path="nape.phys.BodyList"/>
				<c path="nape.phys.BodyList"/>
			</f>
			<haxe_doc><![CDATA[* Evaluate all Bodies given a circle.
     * <br/><br/>
     * If the filter argument is non-null, then only bodies with a shape
     * classified as being part of the circle, whose filter agrees to collide
     * will be considered.
     *
     * @param position The position of the centre of the circle.
     * @param radius The radius of the circle.
     * @param containment If true, then only Bodies entirely contained (Rather
     *                    than simply intersecting) will be considered. If a
     *                    filter is supplied, only shapes that agree to collide
     *                    will be used in this containment check.
     *                    (default false)
     * @param filter Optional filter to pick and choose shapes, based on whether
     *               the filters agree to collide. (default null)
     * @param output Optional list to append results to instead of creating a new list (default null).
     * @return A list of all the shapes for given circle.
     * @throws # If positions is null or disposed of.
     * @throws # If radius is not strictly positive.]]></haxe_doc>
		</bodiesInCircle>
		<shapesInCircle public="1" set="method" line="744">
			<f a="position:radius:?containment:?filter:?output">
				<c path="nape.geom.Vec2"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="nape.dynamics.InteractionFilter"/>
				<c path="nape.shape.ShapeList"/>
				<c path="nape.shape.ShapeList"/>
			</f>
			<haxe_doc><![CDATA[* Evaluate all Shapes given a circle.
     * <br/><br/>
     * If the filter argument is non-null, then only shapes who's filter
     * agrees to 'collide' will be considered.
     *
     * @param position The position of the centre of the circle.
     * @param radius The radius of the circle.
     * @param containment If true, then only Shapes entirely contained (Rather
     *                    than simply intersected) will be considered.
     *                    (default false)
     * @param filter Optional filter to pick and choose shapes, based on whether
     *               the filters agree to collide. (default null)
     * @param output Optional list to append results to instead of creating a new list (default null).
     * @return A list of all the shapes for given circle.
     * @throws # If positions is null or disposed of.
     * @throws # If radius is not strictly positive.]]></haxe_doc>
		</shapesInCircle>
		<bodiesInAABB public="1" set="method" line="718">
			<f a="aabb:?containment:?strict:?filter:?output">
				<c path="nape.geom.AABB"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="nape.dynamics.InteractionFilter"/>
				<c path="nape.phys.BodyList"/>
				<c path="nape.phys.BodyList"/>
			</f>
			<haxe_doc><![CDATA[* Evaluate all Bodies given an AABB.
     * <br/><br/>
     * If the filter argument is non-null, then only bodies with a shape
     * classified as being part of the AABB, whose filter agrees to collide
     * will be considered.
     *
     * @param aabb The bounding box to query bodies by,
     * @param containment If true, then only Bodies entirely contained (Rather
     *                    than simply intersecting) will be considered.
     *                    (default false)
     * @param strict If false, then the body's shape's bounding box will be used to
     *               classify the shapes of the body, instead of the Shape itself.
     *               (default true)
     * @param filter Optional filter to pick and choose shapes, based on whether
     *               the filters agree to collide. (default null)
     * @param output Optional list to append results to instead of creating a new list (default null).
     * @return A list of all the shapes for given AABB.
     * @throws # If AABB is null, or is degenerate.]]></haxe_doc>
		</bodiesInAABB>
		<shapesInAABB public="1" set="method" line="690">
			<f a="aabb:?containment:?strict:?filter:?output">
				<c path="nape.geom.AABB"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="nape.dynamics.InteractionFilter"/>
				<c path="nape.shape.ShapeList"/>
				<c path="nape.shape.ShapeList"/>
			</f>
			<haxe_doc><![CDATA[* Evaluate all Shapes given an AABB.
     * <br/><br/>
     * If the filter argument is non-null, then only shapes who's filter
     * agrees to 'collide' will be considered.
     *
     * @param aabb The bounding box to query shapes by,
     * @param containment If true, then only Shapes entirely contained (Rather
     *                    than simply intersected) will be considered.
     *                    (default false)
     * @param strict If false, then the Shape's bounding box will be used to
     *               classify the Shape, instead of the Shape itself.
     *               (default true)
     * @param filter Optional filter to pick and choose shapes, based on whether
     *               the filters agree to collide. (default null)
     * @param output Optional list to append results to instead of creating a new list (default null).
     * @return A list of all the shapes for given AABB.
     * @throws # If AABB is null, or is degenerate.]]></haxe_doc>
		</shapesInAABB>
		<bodiesUnderPoint public="1" set="method" line="647">
			<f a="point:?filter:?output">
				<c path="nape.geom.Vec2"/>
				<c path="nape.dynamics.InteractionFilter"/>
				<c path="nape.phys.BodyList"/>
				<c path="nape.phys.BodyList"/>
			</f>
			<haxe_doc><![CDATA[* Evaluate all Bodies under a given Point.
     * <br/><br/>
     * If the filter argument is non-null, then only bodies with a shape containing
     * the given point whose filter agrees to 'collide' will be considered.
     *
     * @param point The point to evaluate bodies.
     * @param filter Optional filter to pick and choose shapes, based on whether
     *               the filters agree to collide. (default null)
     * @param output Optional list to append results to instead of creating a new list (default null).
     * @return A list of all the Bodies containing the given point.
     * @throws # If point is null or disposed of.]]></haxe_doc>
		</bodiesUnderPoint>
		<shapesUnderPoint public="1" set="method" line="610">
			<f a="point:?filter:?output">
				<c path="nape.geom.Vec2"/>
				<c path="nape.dynamics.InteractionFilter"/>
				<c path="nape.shape.ShapeList"/>
				<c path="nape.shape.ShapeList"/>
			</f>
			<haxe_doc><![CDATA[* Evaluate all Shapes under a given Point.
     * <br/><br/>
     * If the filter argument is non-null, then only shapes who's filter
     * agrees to 'collide' will be considered.
     *
     * @param point The point to evaluate shapes.
     * @param filter Optional filter to pick and choose shapes, based on whether
     *               the filters agree to collide. (default null)
     * @param output Optional list to append results to instead of creating a new list (default null).
     * @return A list of all the Shapes containing the given point.
     * @throws # If point is null or disposed of.]]></haxe_doc>
		</shapesUnderPoint>
		<interactionType public="1" set="method" line="578">
			<f a="shape1:shape2">
				<c path="nape.shape.Shape"/>
				<c path="nape.shape.Shape"/>
				<t path="Null"><c path="nape.callbacks.InteractionType"/></t>
			</f>
			<haxe_doc><![CDATA[* Determine the interaction type that would occur between a pair of Shapes.
     * <br/><br/>
     * This function takes into account everything possible, and ignoring the
     * callback system will tell you precisely the type of interaction (if any
     * at all) which will occur between these Shapes.
     * <br/><br/>
     * This function can only work if the Shapes belong to a Body.
     * <br/><br/>
     * This function can only make use of any constraints 'ignore' property
     * to determine if 'null' should be returned if the constraints being used
     * are inside of a Space.
     *
     * @param shape1 The first Shape to test.
     * @param shape2 The second Shape to test.
     * @return The interaction type that will occur between these shapes, or null
     *         if no interaction will occur.
     * @throws # If either shape is null, or is not contained within a body.]]></haxe_doc>
		</interactionType>
		<get_elapsedTime get="inline" set="null" line="527"><f a=""><x path="Float"/></f></get_elapsedTime>
		<elapsedTime public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The elapsed simulation time.
     * <br/><br/>
     * This is the total amount of 'time' that has elapsed in the Space simulation.]]></haxe_doc>
		</elapsedTime>
		<get_timeStamp get="inline" set="null" line="517"><f a=""><x path="Int"/></f></get_timeStamp>
		<timeStamp public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc><![CDATA[* The time stamp of this Space object.
     * <br/><br/>
     * This is equal to the number of times that space.step(..) has been invoked.]]></haxe_doc>
		</timeStamp>
		<step public="1" set="method" line="501">
			<f a="deltaTime:?velocityIterations:?positionIterations">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Step simulation forward in time.
     *
     * @param deltaTime The number of seconds to simulate. For 60fps physics
     *                  you would use a value of 1/60.
     * @param velocityIterations The number of iterations to use in resolving
     *                           errors in the velocities of objects. This is
     *                           together with collision detection the most
     *                           expensive phase of a simulation update, as well
     *                           as the most important for stable results.
     *                           (default 10)
     * @param positionIterations The number of iterations to use in resolving
     *                           errors in the positions of objects. This is
     *                           far more lightweight than velocity iterations,
     *                           as well as being less important for the
     *                           stability of results. (default 10)
     * @throws # If deltaTime is not strictly positive.
     * @throws # If either of the number of iterations is not strictly positive.</haxe_doc>
		</step>
		<clear public="1" set="method" line="475">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Clear the Space of all objects.
     * <br/><br/>
     * Things such as the elapsed simulation time, and time step will too be
     * reset to 0.
     * <br/><br/>
     * Parameters such as gravity, and worldLinearDrag will be untouched by
     * this operation.]]></haxe_doc>
		</clear>
		<get_listeners get="inline" set="null" line="462"><f a=""><c path="nape.callbacks.ListenerList"/></f></get_listeners>
		<listeners public="1" get="accessor" set="null">
			<c path="nape.callbacks.ListenerList"/>
			<haxe_doc><![CDATA[* List of all Listeners in space.
     * <br/><br/>
     * This list is mutable, and adding an element to this list is one way of
     * adding a Listener to this Space equivalent to: <code>listener.space = space</code>]]></haxe_doc>
		</listeners>
		<get_arbiters get="inline" set="null" line="446"><f a=""><c path="nape.dynamics.ArbiterList"/></f></get_arbiters>
		<arbiters public="1" get="accessor" set="null">
			<c path="nape.dynamics.ArbiterList"/>
			<haxe_doc><![CDATA[* List of all active arbiters in Space.
     * <br/><br/>
     * This list is immutable.]]></haxe_doc>
		</arbiters>
		<get_world get="inline" set="null" line="436"><f a=""><c path="nape.phys.Body"/></f></get_world>
		<world public="1" get="accessor" set="null">
			<c path="nape.phys.Body"/>
			<haxe_doc><![CDATA[* Static, immutable Body for constraint purposes.
     * <br/><br/>
     * This is a completely static, uncollidable, uninteractable Body
     * with no Shapes, that cannot be modified in any way.
     * <br/><br/>
     * Its purpose is to provide a means for attaching Constraints
     * from one Body to the Space itself, for instance pinning a body
     * against a static point in space.]]></haxe_doc>
		</world>
		<visitCompounds public="1" set="method" line="415">
			<f a="lambda">
				<f a="">
					<c path="nape.phys.Compound"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Apply given function to all compounds in space.
     * <br/><br/>
     * This method is a way to iterate over 'every' Compound in the Space
     * regardless of containment in another Compound.
     *
     * @param lambda The function to apply to each Compound.
     * @throws # If lambda is null.]]></haxe_doc>
		</visitCompounds>
		<visitConstraints public="1" set="method" line="399">
			<f a="lambda">
				<f a="">
					<c path="nape.constraint.Constraint"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Apply given function to all constraints in space.
     * <br/><br/>
     * This method is a way to iterate over 'every' Constraint in the Space
     * regardless of containment in a Compound.
     *
     * @param lambda The function to apply to each Constraint.
     * @throws # If lambda is null.]]></haxe_doc>
		</visitConstraints>
		<visitBodies public="1" set="method" line="383">
			<f a="lambda">
				<f a="">
					<c path="nape.phys.Body"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Apply given function to all bodies in space.
     * <br/><br/>
     * This method is a way to iterate over 'every' Body in the Space
     * regardless of containment in a Compound.
     *
     * @param lambda The function to apply to each Body.
     * @throws # If lambda is null.]]></haxe_doc>
		</visitBodies>
		<get_liveConstraints get="inline" set="null" line="371"><f a=""><c path="nape.constraint.ConstraintList"/></f></get_liveConstraints>
		<liveConstraints public="1" get="accessor" set="null">
			<c path="nape.constraint.ConstraintList"/>
			<haxe_doc><![CDATA[* List of all active Constraints in space.
     * <br/><br/>
     * This list contains all constraints regardless of their containment in a Compound.
     * <br/><br/>
     * This list is immutable.]]></haxe_doc>
		</liveConstraints>
		<get_constraints get="inline" set="null" line="359"><f a=""><c path="nape.constraint.ConstraintList"/></f></get_constraints>
		<constraints public="1" get="accessor" set="null">
			<c path="nape.constraint.ConstraintList"/>
			<haxe_doc><![CDATA[* List of all Constraints directly placed in space.
     * <br/><br/>
     * This list is mutable, and adding an element to this list is one way of
     * adding a Constraint to this Space equivalent to: <code>constraint.space = space</code>
     * <br/><br/>
     * This list is only those bodies directly placed in the space, any
     * constraint that is a child of a Compound will not be in this list.]]></haxe_doc>
		</constraints>
		<get_liveBodies get="inline" set="null" line="345"><f a=""><c path="nape.phys.BodyList"/></f></get_liveBodies>
		<liveBodies public="1" get="accessor" set="null">
			<c path="nape.phys.BodyList"/>
			<haxe_doc><![CDATA[* List of all active dynamic Bodies in space.
     * <br/><br/>
     * This list contains all dynamic bodies that are awake regardless of their containment in a Compound.
     * <br/><br/>
     * This list is immutable.]]></haxe_doc>
		</liveBodies>
		<get_bodies get="inline" set="null" line="333"><f a=""><c path="nape.phys.BodyList"/></f></get_bodies>
		<bodies public="1" get="accessor" set="null">
			<c path="nape.phys.BodyList"/>
			<haxe_doc><![CDATA[* List of all Bodys directly placed in space.
     * <br/><br/>
     * This list is mutable, and adding an element to this list is one way of
     * adding a Body to this Space equivalent to: <code>body.space = space</code>
     * <br/><br/>
     * This list is only those bodies directly placed in the space, any
     * body that is a child of a Compound will not be in this list.]]></haxe_doc>
		</bodies>
		<get_compounds get="inline" set="null" line="319"><f a=""><c path="nape.phys.CompoundList"/></f></get_compounds>
		<compounds public="1" get="accessor" set="null">
			<c path="nape.phys.CompoundList"/>
			<haxe_doc><![CDATA[* List of all Compounds directly placed in space.
     * <br/><br/>
     * This list is mutable, and adding an element to this list is one way of
     * adding a Compound to this Space equivalent to: <code>compound.space = space</code>
     * <br/><br/>
     * This list is only those compounds directly placed in the space, any
     * compound that is a child of another compound will not be in this list.]]></haxe_doc>
		</compounds>
		<set_worldLinearDrag get="inline" set="null" line="298"><f a="worldLinearDrag">
	<x path="Float"/>
	<x path="Float"/>
</f></set_worldLinearDrag>
		<get_worldLinearDrag get="inline" set="null" line="295"><f a=""><x path="Float"/></f></get_worldLinearDrag>
		<worldLinearDrag public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Linear drag applied to all bodies in Space.
     * <br/><br/>
     * This represents the fraction of a body's linear velocity which will be
     * removed per second. This value has no unit attached.
     *
     * @default 0.015]]></haxe_doc>
		</worldLinearDrag>
		<set_worldAngularDrag get="inline" set="null" line="275"><f a="worldAngularDrag">
	<x path="Float"/>
	<x path="Float"/>
</f></set_worldAngularDrag>
		<get_worldAngularDrag get="inline" set="null" line="272"><f a=""><x path="Float"/></f></get_worldAngularDrag>
		<worldAngularDrag public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Angular drag applied to all bodies in Space.
     * <br/><br/>
     * This represents the fraction of a body's angular velocity which will be
     * removed per second. This value has no unit attached.
     *
     * @default 0.015]]></haxe_doc>
		</worldAngularDrag>
		<set_sortContacts get="inline" set="null" line="256"><f a="sortContacts">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_sortContacts>
		<get_sortContacts get="inline" set="null" line="253"><f a=""><x path="Bool"/></f></get_sortContacts>
		<sortContacts public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Flag controlling sorting of contact points.
     * <br/><br/>
     * If true, then collisions will be resolved in an order defined by their
     * penetration depths. This can be shown to improve stability of the physics
     * as well as making simulations more consistent regardless of which broadphase
     * is used.
     * <br/><br/>
     * Having sorting enabled obviously incurs a cost, and you may consider
     * disabling it if you are having issues with performance (Though things
     * such as number of physics iterations will have much greater bearing on
     * performance than this, especcialy since enabling this may permit you
     * to use less iterations).
     *
     * @default true]]></haxe_doc>
		</sortContacts>
		<get_broadphase get="inline" set="null" line="232"><f a=""><c path="nape.space.Broadphase"/></f></get_broadphase>
		<broadphase public="1" get="accessor" set="null">
			<c path="nape.space.Broadphase"/>
			<haxe_doc>* Broadphase type in use.</haxe_doc>
		</broadphase>
		<set_gravity get="inline" set="null" line="213"><f a="gravity">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_gravity>
		<get_gravity get="inline" set="null" line="209"><f a=""><c path="nape.geom.Vec2"/></f></get_gravity>
		<gravity public="1" get="accessor" set="accessor">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* Space gravity.
     * <br/><br/>
     * Units are of pixels/second/second
     * @default (0,0)]]></haxe_doc>
		</gravity>
		<get_userData get="inline" set="null" line="195"><f a=""><d><d/></d></f></get_userData>
		<userData public="1" get="accessor" set="null">
			<d><d/></d>
			<haxe_doc><![CDATA[* Dynamic object for user to store additional data.
     * <br/><br/>
     * This object cannot be set, only its dynamically created
     * properties may be set. In AS3 the type of this property is &#42
     * <br/><br/>
     * This object will be lazily constructed so that until accessed
     * for the first time, will be null internally.
     *
     * @default {}]]></haxe_doc>
		</userData>
		<zpp_inner public="1">
			<c path="zpp_nape.space.ZPP_Space"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="538">
			<f a="?gravity:?broadphase">
				<c path="nape.geom.Vec2"/>
				<c path="nape.space.Broadphase"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Construct a new Space object.
     *
     * @param gravity The gravity of this space. (default &#40;0,0&#41;)
     * @param broadphase The broadphase type to use. (default DYNAMIC_AABB_TREE)
     * @return The constructed Space object.
     * @throws # If gravity is non-null, and has been disposed of.]]></haxe_doc>
		</new>
		<haxe_doc>* The heart of all Nape simulations.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.util.Debug" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/nape/util/Debug.hx">
		<version public="1" set="method" line="183" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Query Nape version</haxe_doc>
		</version>
		<clearObjectPools public="1" set="method" line="189" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Force clear all object pools, both internal and public.</haxe_doc>
		</clearObjectPools>
		<haxe_doc><![CDATA[* Debug class providing general utilities
 * <br/><br/>
 * Also serves as the base type for Debug draws.]]></haxe_doc>
	</class>
	<class path="sandbox.Base" params="" file="src/haxe/sandbox/Main.hx" module="sandbox.Main"><foo static="1"><x path="Int"/></foo></class>
	<class path="sandbox.Main" params="" file="src/haxe/sandbox/Main.hx">
		<extends path="sandbox.Base"/>
		<main set="method" line="14" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":keep"/></meta>
		</main>
		<foo set="method" line="17" static="1"><f a="arg1:arg2">
	<c path="nape.phys.BodyIterator"/>
	<c path="String"/>
	<x path="Int"/>
</f></foo>
		<haxe_doc set="method" line="24" static="1">
			<f a="foo:bar:baz">
				<x path="Int"/>
				<c path="Array"><x path="Int"/></c>
				<c path="sandbox.Main"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Description of this method</haxe_doc>
		</haxe_doc>
		<haxe_doc>* Description of this class</haxe_doc>
	</class>
	<class path="zpp_nape.ZPP_Const" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/Const.hx" module="zpp_nape.Const">
		<POSINF public="1" get="inline" set="null" line="184" static="1"><f a=""><x path="Float"/></f></POSINF>
		<NEGINF public="1" get="inline" set="null" line="188" static="1"><f a=""><x path="Float"/></f></NEGINF>
		<FMAX public="1" get="inline" set="null" line="193" static="1"><x path="Float"/></FMAX>
	</class>
	<class path="zpp_nape.ZPP_ID" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/ID.hx" module="zpp_nape.ID">
		<_Constraint public="1" line="176" static="1"><x path="Int"/></_Constraint>
		<Constraint public="1" set="method" line="177" static="1"><f a=""><x path="Int"/></f></Constraint>
		<_Interactor public="1" line="180" static="1"><x path="Int"/></_Interactor>
		<Interactor public="1" set="method" line="181" static="1"><f a=""><x path="Int"/></f></Interactor>
		<_CbType public="1" line="184" static="1"><x path="Int"/></_CbType>
		<CbType public="1" set="method" line="185" static="1"><f a=""><x path="Int"/></f></CbType>
		<_CbSet public="1" line="188" static="1"><x path="Int"/></_CbSet>
		<CbSet public="1" set="method" line="189" static="1"><f a=""><x path="Int"/></f></CbSet>
		<_Listener public="1" line="192" static="1"><x path="Int"/></_Listener>
		<Listener public="1" set="method" line="193" static="1"><f a=""><x path="Int"/></f></Listener>
		<_ZPP_SimpleVert public="1" line="196" static="1"><x path="Int"/></_ZPP_SimpleVert>
		<ZPP_SimpleVert public="1" set="method" line="197" static="1"><f a=""><x path="Int"/></f></ZPP_SimpleVert>
		<_ZPP_SimpleSeg public="1" line="200" static="1"><x path="Int"/></_ZPP_SimpleSeg>
		<ZPP_SimpleSeg public="1" set="method" line="201" static="1"><f a=""><x path="Int"/></f></ZPP_SimpleSeg>
		<_Space public="1" line="204" static="1"><x path="Int"/></_Space>
		<Space public="1" set="method" line="205" static="1"><f a=""><x path="Int"/></f></Space>
		<_InteractionGroup public="1" line="208" static="1"><x path="Int"/></_InteractionGroup>
		<InteractionGroup public="1" set="method" line="209" static="1"><f a=""><x path="Int"/></f></InteractionGroup>
	</class>
	<class path="zpp_nape.callbacks.ZPP_Callback" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/callbacks/Callback.hx" module="zpp_nape.callbacks.Callback">
		<internal public="1" line="179" static="1"><x path="Bool"/></internal>
		<zpp_pool public="1" line="369" static="1"><c path="zpp_nape.callbacks.ZPP_Callback"/></zpp_pool>
		<constraint public="1"><c path="zpp_nape.constraint.ZPP_Constraint"/></constraint>
		<body public="1"><c path="zpp_nape.phys.ZPP_Body"/></body>
		<genarbs public="1" get="inline" set="null" line="416"><f a=""><x path="Void"/></f></genarbs>
		<pre_swapped public="1"><x path="Bool"/></pre_swapped>
		<pre_arbiter public="1"><c path="zpp_nape.dynamics.ZPP_Arbiter"/></pre_arbiter>
		<wrap_arbiters public="1"><c path="nape.dynamics.ArbiterList"/></wrap_arbiters>
		<set public="1"><c path="zpp_nape.space.ZPP_CallbackSet"/></set>
		<int2 public="1"><c path="zpp_nape.phys.ZPP_Interactor"/></int2>
		<int1 public="1"><c path="zpp_nape.phys.ZPP_Interactor"/></int1>
		<alloc public="1" get="inline" set="null" line="407"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="395"><f a=""><x path="Void"/></f></free>
		<rev_at public="1" set="method" line="356"><f a="i">
	<x path="Int"/>
	<c path="zpp_nape.callbacks.ZPP_Callback"/>
</f></rev_at>
		<at public="1" set="method" line="343"><f a="i">
	<x path="Int"/>
	<c path="zpp_nape.callbacks.ZPP_Callback"/>
</f></at>
		<cyclePrev public="1" set="method" line="331"><f a="o">
	<c path="zpp_nape.callbacks.ZPP_Callback"/>
	<c path="zpp_nape.callbacks.ZPP_Callback"/>
</f></cyclePrev>
		<cycleNext public="1" set="method" line="319"><f a="o">
	<c path="zpp_nape.callbacks.ZPP_Callback"/>
	<c path="zpp_nape.callbacks.ZPP_Callback"/>
</f></cycleNext>
		<rotateR public="1" set="method" line="316"><f a=""><x path="Void"/></f></rotateR>
		<rotateL public="1" set="method" line="313"><f a=""><x path="Void"/></f></rotateL>
		<splice public="1" set="method" line="298"><f a="o">
	<c path="zpp_nape.callbacks.ZPP_Callback"/>
	<c path="zpp_nape.callbacks.ZPP_Callback"/>
</f></splice>
		<clear public="1" set="method" line="295"><f a=""><x path="Void"/></f></clear>
		<empty public="1" set="method" line="292"><f a=""><x path="Bool"/></f></empty>
		<pop_rev public="1" set="method" line="276"><f a=""><c path="zpp_nape.callbacks.ZPP_Callback"/></f></pop_rev>
		<pop public="1" set="method" line="260"><f a=""><c path="zpp_nape.callbacks.ZPP_Callback"/></f></pop>
		<push_rev public="1" set="method" line="244"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_Callback"/>
	<x path="Void"/>
</f></push_rev>
		<push public="1" set="method" line="228"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_Callback"/>
	<x path="Void"/>
</f></push>
		<length public="1"><x path="Int"/></length>
		<prev public="1"><c path="zpp_nape.callbacks.ZPP_Callback"/></prev>
		<next public="1"><c path="zpp_nape.callbacks.ZPP_Callback"/></next>
		<index public="1"><x path="Int"/></index>
		<space public="1"><c path="zpp_nape.space.ZPP_Space"/></space>
		<listener public="1"><c path="zpp_nape.callbacks.ZPP_Listener"/></listener>
		<event public="1"><x path="Int"/></event>
		<wrapper_int public="1" set="method" line="207"><f a=""><t path="Null"><c path="nape.callbacks.InteractionCallback"/></t></f></wrapper_int>
		<wrapper_con public="1" set="method" line="194"><f a=""><t path="Null"><c path="nape.callbacks.ConstraintCallback"/></t></f></wrapper_con>
		<wrapper_body public="1" set="method" line="181"><f a=""><t path="Null"><c path="nape.callbacks.BodyCallback"/></t></f></wrapper_body>
		<outer_int public="1"><t path="Null"><c path="nape.callbacks.InteractionCallback"/></t></outer_int>
		<outer_con public="1"><t path="Null"><c path="nape.callbacks.ConstraintCallback"/></t></outer_con>
		<outer_body public="1"><t path="Null"><c path="nape.callbacks.BodyCallback"/></t></outer_body>
		<new public="1" set="method" line="436"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.callbacks.ZPP_CbSet" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/callbacks/CbSet.hx" module="zpp_nape.callbacks.CbSet">
		<zpp_pool public="1" line="178" static="1"><c path="zpp_nape.callbacks.ZPP_CbSet"/></zpp_pool>
		<setlt public="1" set="method" line="440" static="1"><f a="a:b">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<x path="Bool"/>
</f></setlt>
		<get public="1" set="method" line="545" static="1"><f a="cbTypes">
	<c path="zpp_nape.util.ZNPList_ZPP_CbType"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
</f></get>
		<compatible get="inline" set="null" line="581" static="1"><f a="i:a:b">
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<x path="Bool"/>
</f></compatible>
		<empty_intersection public="1" get="inline" set="null" line="585" static="1"><f a="a:b">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<x path="Bool"/>
</f></empty_intersection>
		<single_intersection public="1" set="method" line="588" static="1"><f a="a:b:i">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
	<x path="Bool"/>
</f></single_intersection>
		<find_all public="1" get="inline" set="null" line="592" static="1"><f a="a:b:event:cb">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<x path="Int"/>
	<f a="">
		<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></find_all>
		<alloc public="1" get="inline" set="null" line="520"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="471"><f a=""><x path="Void"/></f></free>
		<remInteractor public="1" get="inline" set="null" line="437"><f a="intx">
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<x path="Void"/>
</f></remInteractor>
		<remConstraint public="1" get="inline" set="null" line="432"><f a="con">
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
	<x path="Void"/>
</f></remConstraint>
		<addInteractor public="1" get="inline" set="null" line="427"><f a="intx">
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<x path="Void"/>
</f></addInteractor>
		<addConstraint public="1" get="inline" set="null" line="422"><f a="con">
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
	<x path="Void"/>
</f></addConstraint>
		<wrap_constraints public="1"><c path="nape.constraint.ConstraintList"/></wrap_constraints>
		<constraints public="1"><c path="zpp_nape.util.ZNPList_ZPP_Constraint"/></constraints>
		<wrap_interactors public="1"><c path="nape.phys.InteractorList"/></wrap_interactors>
		<interactors public="1"><c path="zpp_nape.util.ZNPList_ZPP_Interactor"/></interactors>
		<validate public="1" set="method" line="410"><f a=""><x path="Void"/></f></validate>
		<realvalidate_conlisteners public="1" set="method" line="368"><f a=""><x path="Void"/></f></realvalidate_conlisteners>
		<validate_conlisteners public="1" get="inline" set="null" line="362"><f a=""><x path="Void"/></f></validate_conlisteners>
		<invalidate_conlisteners public="1" get="inline" set="null" line="355"><f a=""><x path="Void"/></f></invalidate_conlisteners>
		<zip_conlisteners public="1"><x path="Bool"/></zip_conlisteners>
		<conlisteners public="1"><c path="zpp_nape.util.ZNPList_ZPP_ConstraintListener"/></conlisteners>
		<realvalidate_bodylisteners public="1" set="method" line="309"><f a=""><x path="Void"/></f></realvalidate_bodylisteners>
		<validate_bodylisteners public="1" get="inline" set="null" line="303"><f a=""><x path="Void"/></f></validate_bodylisteners>
		<invalidate_bodylisteners public="1" get="inline" set="null" line="296"><f a=""><x path="Void"/></f></invalidate_bodylisteners>
		<zip_bodylisteners public="1"><x path="Bool"/></zip_bodylisteners>
		<bodylisteners public="1"><c path="zpp_nape.util.ZNPList_ZPP_BodyListener"/></bodylisteners>
		<realvalidate_listeners public="1" set="method" line="250"><f a=""><x path="Void"/></f></realvalidate_listeners>
		<validate_listeners public="1" get="inline" set="null" line="244"><f a=""><x path="Void"/></f></validate_listeners>
		<invalidate_listeners public="1" get="inline" set="null" line="237"><f a=""><x path="Void"/></f></invalidate_listeners>
		<zip_listeners public="1"><x path="Bool"/></zip_listeners>
		<listeners public="1"><c path="zpp_nape.util.ZNPList_ZPP_InteractionListener"/></listeners>
		<invalidate_pairs public="1" set="method" line="223"><f a=""><x path="Void"/></f></invalidate_pairs>
		<decrement public="1" get="inline" set="null" line="212"><f a=""><x path="Bool"/></f></decrement>
		<increment public="1" get="inline" set="null" line="207"><f a=""><x path="Void"/></f></increment>
		<cbpairs public="1"><c path="zpp_nape.util.ZNPList_ZPP_CbSetPair"/></cbpairs>
		<manager public="1"><c path="zpp_nape.space.ZPP_CbSetManager"/></manager>
		<id public="1"><x path="Int"/></id>
		<next public="1"><c path="zpp_nape.callbacks.ZPP_CbSet"/></next>
		<count public="1"><x path="Int"/></count>
		<cbTypes public="1"><c path="zpp_nape.util.ZNPList_ZPP_CbType"/></cbTypes>
		<new public="1" set="method" line="455"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.callbacks.ZPP_CbSetPair" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/callbacks/CbSetPair.hx" module="zpp_nape.callbacks.CbSetPair">
		<zpp_pool public="1" line="178" static="1"><c path="zpp_nape.callbacks.ZPP_CbSetPair"/></zpp_pool>
		<get public="1" get="inline" set="null" line="217" static="1"><f a="a:b">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
</f></get>
		<setlt public="1" get="inline" set="null" line="247" static="1"><f a="x:y">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<x path="Bool"/>
</f></setlt>
		<forall public="1" get="inline" set="null" line="341"><f a="event:cb">
	<x path="Int"/>
	<f a="">
		<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></forall>
		<single_intersection public="1" get="inline" set="null" line="327"><f a="i">
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
	<x path="Bool"/>
</f></single_intersection>
		<empty_intersection public="1" get="inline" set="null" line="314"><f a=""><x path="Bool"/></f></empty_intersection>
		<__validate public="1" set="method" line="278"><f a=""><x path="Void"/></f></__validate>
		<validate public="1" get="inline" set="null" line="272"><f a=""><x path="Void"/></f></validate>
		<invalidate public="1" get="inline" set="null" line="267"><f a=""><x path="Void"/></f></invalidate>
		<listeners public="1"><c path="zpp_nape.util.ZNPList_ZPP_InteractionListener"/></listeners>
		<zip_listeners public="1"><x path="Bool"/></zip_listeners>
		<compatible get="inline" set="null" line="260"><f a="i">
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
	<x path="Bool"/>
</f></compatible>
		<alloc public="1" get="inline" set="null" line="210"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="204"><f a=""><x path="Void"/></f></free>
		<next public="1"><c path="zpp_nape.callbacks.ZPP_CbSetPair"/></next>
		<b public="1"><c path="zpp_nape.callbacks.ZPP_CbSet"/></b>
		<a public="1"><c path="zpp_nape.callbacks.ZPP_CbSet"/></a>
		<new public="1" set="method" line="213"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_InteractionListener" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="3080"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
</f></at>
		<iterator_at public="1" set="method" line="3067"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionListener"/>
</f></iterator_at>
		<back public="1" set="method" line="3058"><f a=""><c path="zpp_nape.callbacks.ZPP_InteractionListener"/></f></back>
		<front public="1" get="inline" set="null" line="3055"><f a=""><c path="zpp_nape.callbacks.ZPP_InteractionListener"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="3025"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="3020"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="3017"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="3012"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="2997"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="2991"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="2986"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="2982"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionListener"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionListener"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="2936"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionListener"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionListener"/>
</f></inlined_erase>
		<erase public="1" set="method" line="2931"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionListener"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionListener"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="2908"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="2895"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="2870"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="2859"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="2846"><f a=""><c path="zpp_nape.callbacks.ZPP_InteractionListener"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="2841"><f a=""><c path="zpp_nape.callbacks.ZPP_InteractionListener"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="2808"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="2803"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="2760"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionListener"/>
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionListener"/>
</f></inlined_insert>
		<insert public="1" set="method" line="2755"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionListener"/>
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionListener"/>
</f></insert>
		<addAll public="1" set="method" line="2737"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_InteractionListener"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="2700"><f a="o">
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
</f></inlined_add>
		<add public="1" set="method" line="2695"><f a="o">
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="2690"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionListener"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="2682"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_InteractionListener"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_InteractionListener"/></head>
		<new public="1" set="method" line="2679"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_BodyListener" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="4748"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.callbacks.ZPP_BodyListener"/>
</f></at>
		<iterator_at public="1" set="method" line="4735"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_BodyListener"/>
</f></iterator_at>
		<back public="1" set="method" line="4726"><f a=""><c path="zpp_nape.callbacks.ZPP_BodyListener"/></f></back>
		<front public="1" get="inline" set="null" line="4723"><f a=""><c path="zpp_nape.callbacks.ZPP_BodyListener"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="4693"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_BodyListener"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="4688"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_BodyListener"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="4685"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="4680"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="4665"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="4659"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="4654"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="4650"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_BodyListener"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_BodyListener"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="4604"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_BodyListener"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_BodyListener"/>
</f></inlined_erase>
		<erase public="1" set="method" line="4599"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_BodyListener"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_BodyListener"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="4576"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_BodyListener"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="4563"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_BodyListener"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="4538"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_BodyListener"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="4527"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_BodyListener"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="4514"><f a=""><c path="zpp_nape.callbacks.ZPP_BodyListener"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="4509"><f a=""><c path="zpp_nape.callbacks.ZPP_BodyListener"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="4476"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="4471"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="4428"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_BodyListener"/>
	<c path="zpp_nape.callbacks.ZPP_BodyListener"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_BodyListener"/>
</f></inlined_insert>
		<insert public="1" set="method" line="4423"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_BodyListener"/>
	<c path="zpp_nape.callbacks.ZPP_BodyListener"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_BodyListener"/>
</f></insert>
		<addAll public="1" set="method" line="4405"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_BodyListener"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="4368"><f a="o">
	<c path="zpp_nape.callbacks.ZPP_BodyListener"/>
	<c path="zpp_nape.callbacks.ZPP_BodyListener"/>
</f></inlined_add>
		<add public="1" set="method" line="4363"><f a="o">
	<c path="zpp_nape.callbacks.ZPP_BodyListener"/>
	<c path="zpp_nape.callbacks.ZPP_BodyListener"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="4358"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_BodyListener"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="4350"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_BodyListener"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_BodyListener"/></head>
		<new public="1" set="method" line="4347"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_ConstraintListener" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="5165"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.callbacks.ZPP_ConstraintListener"/>
</f></at>
		<iterator_at public="1" set="method" line="5152"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_ConstraintListener"/>
</f></iterator_at>
		<back public="1" set="method" line="5143"><f a=""><c path="zpp_nape.callbacks.ZPP_ConstraintListener"/></f></back>
		<front public="1" get="inline" set="null" line="5140"><f a=""><c path="zpp_nape.callbacks.ZPP_ConstraintListener"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="5110"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_ConstraintListener"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="5105"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_ConstraintListener"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="5102"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="5097"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="5082"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="5076"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="5071"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="5067"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_ConstraintListener"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_ConstraintListener"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="5021"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_ConstraintListener"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_ConstraintListener"/>
</f></inlined_erase>
		<erase public="1" set="method" line="5016"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_ConstraintListener"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_ConstraintListener"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="4993"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_ConstraintListener"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="4980"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_ConstraintListener"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="4955"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_ConstraintListener"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="4944"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_ConstraintListener"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="4931"><f a=""><c path="zpp_nape.callbacks.ZPP_ConstraintListener"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="4926"><f a=""><c path="zpp_nape.callbacks.ZPP_ConstraintListener"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="4893"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="4888"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="4845"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_ConstraintListener"/>
	<c path="zpp_nape.callbacks.ZPP_ConstraintListener"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_ConstraintListener"/>
</f></inlined_insert>
		<insert public="1" set="method" line="4840"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_ConstraintListener"/>
	<c path="zpp_nape.callbacks.ZPP_ConstraintListener"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_ConstraintListener"/>
</f></insert>
		<addAll public="1" set="method" line="4822"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_ConstraintListener"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="4785"><f a="o">
	<c path="zpp_nape.callbacks.ZPP_ConstraintListener"/>
	<c path="zpp_nape.callbacks.ZPP_ConstraintListener"/>
</f></inlined_add>
		<add public="1" set="method" line="4780"><f a="o">
	<c path="zpp_nape.callbacks.ZPP_ConstraintListener"/>
	<c path="zpp_nape.callbacks.ZPP_ConstraintListener"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="4775"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_ConstraintListener"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="4767"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_ConstraintListener"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_ConstraintListener"/></head>
		<new public="1" set="method" line="4764"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_Constraint" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="2246"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
</f></at>
		<iterator_at public="1" set="method" line="2233"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Constraint"/>
</f></iterator_at>
		<back public="1" set="method" line="2224"><f a=""><c path="zpp_nape.constraint.ZPP_Constraint"/></f></back>
		<front public="1" get="inline" set="null" line="2221"><f a=""><c path="zpp_nape.constraint.ZPP_Constraint"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="2191"><f a="obj">
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="2186"><f a="obj">
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="2183"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="2178"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="2163"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="2157"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="2152"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="2148"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_Constraint"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Constraint"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="2102"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_Constraint"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Constraint"/>
</f></inlined_erase>
		<erase public="1" set="method" line="2097"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_Constraint"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Constraint"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="2074"><f a="obj">
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="2061"><f a="obj">
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="2036"><f a="obj">
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="2025"><f a="obj">
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="2012"><f a=""><c path="zpp_nape.constraint.ZPP_Constraint"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="2007"><f a=""><c path="zpp_nape.constraint.ZPP_Constraint"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="1974"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="1969"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="1926"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_Constraint"/>
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Constraint"/>
</f></inlined_insert>
		<insert public="1" set="method" line="1921"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_Constraint"/>
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Constraint"/>
</f></insert>
		<addAll public="1" set="method" line="1903"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_Constraint"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="1866"><f a="o">
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
</f></inlined_add>
		<add public="1" set="method" line="1861"><f a="o">
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="1856"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_Constraint"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="1848"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_Constraint"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Constraint"/></head>
		<new public="1" set="method" line="1845"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_Interactor" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="3914"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.phys.ZPP_Interactor"/>
</f></at>
		<iterator_at public="1" set="method" line="3901"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Interactor"/>
</f></iterator_at>
		<back public="1" set="method" line="3892"><f a=""><c path="zpp_nape.phys.ZPP_Interactor"/></f></back>
		<front public="1" get="inline" set="null" line="3889"><f a=""><c path="zpp_nape.phys.ZPP_Interactor"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="3859"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="3854"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="3851"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="3846"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="3831"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="3825"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="3820"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="3816"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_Interactor"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Interactor"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="3770"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_Interactor"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Interactor"/>
</f></inlined_erase>
		<erase public="1" set="method" line="3765"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_Interactor"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Interactor"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="3742"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="3729"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="3704"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="3693"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="3680"><f a=""><c path="zpp_nape.phys.ZPP_Interactor"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="3675"><f a=""><c path="zpp_nape.phys.ZPP_Interactor"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="3642"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="3637"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="3594"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_Interactor"/>
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Interactor"/>
</f></inlined_insert>
		<insert public="1" set="method" line="3589"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_Interactor"/>
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Interactor"/>
</f></insert>
		<addAll public="1" set="method" line="3571"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_Interactor"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="3534"><f a="o">
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<c path="zpp_nape.phys.ZPP_Interactor"/>
</f></inlined_add>
		<add public="1" set="method" line="3529"><f a="o">
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<c path="zpp_nape.phys.ZPP_Interactor"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="3524"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_Interactor"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="3516"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_Interactor"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Interactor"/></head>
		<new public="1" set="method" line="3513"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_CbSet" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="3497"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
</f></at>
		<iterator_at public="1" set="method" line="3484"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSet"/>
</f></iterator_at>
		<back public="1" set="method" line="3475"><f a=""><c path="zpp_nape.callbacks.ZPP_CbSet"/></f></back>
		<front public="1" get="inline" set="null" line="3472"><f a=""><c path="zpp_nape.callbacks.ZPP_CbSet"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="3442"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="3437"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="3434"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="3429"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="3414"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="3408"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="3403"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="3399"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSet"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSet"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="3353"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSet"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSet"/>
</f></inlined_erase>
		<erase public="1" set="method" line="3348"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSet"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSet"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="3325"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="3312"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="3287"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="3276"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="3263"><f a=""><c path="zpp_nape.callbacks.ZPP_CbSet"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="3258"><f a=""><c path="zpp_nape.callbacks.ZPP_CbSet"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="3225"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="3220"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="3177"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSet"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSet"/>
</f></inlined_insert>
		<insert public="1" set="method" line="3172"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSet"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSet"/>
</f></insert>
		<addAll public="1" set="method" line="3154"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_CbSet"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="3117"><f a="o">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
</f></inlined_add>
		<add public="1" set="method" line="3112"><f a="o">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="3107"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSet"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="3099"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_CbSet"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_CbSet"/></head>
		<new public="1" set="method" line="3096"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.callbacks.ZPP_CbType" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/callbacks/CbType.hx" module="zpp_nape.callbacks.CbType">
		<setlt public="1" get="inline" set="null" line="180" static="1"><f a="a:b">
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<x path="Bool"/>
</f></setlt>
		<ANY_SHAPE public="1" line="348" static="1"><c path="nape.callbacks.CbType"/></ANY_SHAPE>
		<ANY_BODY public="1" line="349" static="1"><c path="nape.callbacks.CbType"/></ANY_BODY>
		<ANY_COMPOUND public="1" line="350" static="1"><c path="nape.callbacks.CbType"/></ANY_COMPOUND>
		<ANY_CONSTRAINT public="1" line="351" static="1"><c path="nape.callbacks.CbType"/></ANY_CONSTRAINT>
		<invalidateconstraint public="1" get="inline" set="null" line="338"><f a=""><x path="Void"/></f></invalidateconstraint>
		<removeconstraint public="1" get="inline" set="null" line="332"><f a="x">
	<c path="zpp_nape.callbacks.ZPP_ConstraintListener"/>
	<x path="Void"/>
</f></removeconstraint>
		<addconstraint public="1" get="inline" set="null" line="304"><f a="x">
	<c path="zpp_nape.callbacks.ZPP_ConstraintListener"/>
	<x path="Void"/>
</f></addconstraint>
		<conlisteners public="1"><c path="zpp_nape.util.ZNPList_ZPP_ConstraintListener"/></conlisteners>
		<invalidatebody public="1" get="inline" set="null" line="291"><f a=""><x path="Void"/></f></invalidatebody>
		<removebody public="1" get="inline" set="null" line="285"><f a="x">
	<c path="zpp_nape.callbacks.ZPP_BodyListener"/>
	<x path="Void"/>
</f></removebody>
		<addbody public="1" get="inline" set="null" line="257"><f a="x">
	<c path="zpp_nape.callbacks.ZPP_BodyListener"/>
	<x path="Void"/>
</f></addbody>
		<bodylisteners public="1"><c path="zpp_nape.util.ZNPList_ZPP_BodyListener"/></bodylisteners>
		<invalidateint public="1" get="inline" set="null" line="244"><f a=""><x path="Void"/></f></invalidateint>
		<removeint public="1" get="inline" set="null" line="238"><f a="x">
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
	<x path="Void"/>
</f></removeint>
		<addint public="1" get="inline" set="null" line="210"><f a="x">
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
	<x path="Void"/>
</f></addint>
		<listeners public="1"><c path="zpp_nape.util.ZNPList_ZPP_InteractionListener"/></listeners>
		<remInteractor public="1" get="inline" set="null" line="204"><f a="intx">
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<x path="Void"/>
</f></remInteractor>
		<remConstraint public="1" get="inline" set="null" line="199"><f a="con">
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
	<x path="Void"/>
</f></remConstraint>
		<addInteractor public="1" get="inline" set="null" line="194"><f a="intx">
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<x path="Void"/>
</f></addInteractor>
		<addConstraint public="1" get="inline" set="null" line="189"><f a="con">
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
	<x path="Void"/>
</f></addConstraint>
		<wrap_constraints public="1"><c path="nape.constraint.ConstraintList"/></wrap_constraints>
		<constraints public="1"><c path="zpp_nape.util.ZNPList_ZPP_Constraint"/></constraints>
		<wrap_interactors public="1"><c path="nape.phys.InteractorList"/></wrap_interactors>
		<interactors public="1"><c path="zpp_nape.util.ZNPList_ZPP_Interactor"/></interactors>
		<cbsets public="1"><c path="zpp_nape.util.ZNPList_ZPP_CbSet"/></cbsets>
		<id public="1"><x path="Int"/></id>
		<userData public="1"><d><d/></d></userData>
		<outer public="1"><c path="nape.callbacks.CbType"/></outer>
		<new public="1" set="method" line="352"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.callbacks.ZPP_Listener" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/callbacks/Listener.hx" module="zpp_nape.callbacks.Listener">
		<internal public="1" line="177" static="1"><x path="Bool"/></internal>
		<setlt public="1" get="inline" set="null" line="191" static="1"><f a="a:b">
	<c path="zpp_nape.callbacks.ZPP_Listener"/>
	<c path="zpp_nape.callbacks.ZPP_Listener"/>
	<x path="Bool"/>
</f></setlt>
		<removedFromSpace public="1" set="method" line="197"><f a=""><x path="Void"/></f></removedFromSpace>
		<addedToSpace public="1" set="method" line="196"><f a=""><x path="Void"/></f></addedToSpace>
		<invalidate_precedence public="1" set="method" line="195"><f a=""><x path="Void"/></f></invalidate_precedence>
		<swapEvent public="1" set="method" line="194"><f a="event">
	<x path="Int"/>
	<x path="Void"/>
</f></swapEvent>
		<space public="1"><t path="Null"><c path="zpp_nape.space.ZPP_Space"/></t></space>
		<interaction public="1"><t path="Null"><c path="zpp_nape.callbacks.ZPP_InteractionListener"/></t></interaction>
		<constraint public="1"><t path="Null"><c path="zpp_nape.callbacks.ZPP_ConstraintListener"/></t></constraint>
		<body public="1"><t path="Null"><c path="zpp_nape.callbacks.ZPP_BodyListener"/></t></body>
		<precedence public="1"><x path="Int"/></precedence>
		<event public="1"><x path="Int"/></event>
		<type public="1"><x path="Int"/></type>
		<id public="1"><x path="Int"/></id>
		<outer public="1"><c path="nape.callbacks.Listener"/></outer>
		<new set="method" line="187"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.callbacks.ZPP_BodyListener" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/callbacks/Listener.hx" module="zpp_nape.callbacks.Listener">
		<extends path="zpp_nape.callbacks.ZPP_Listener"/>
		<swapEvent public="1" set="method" line="256" override="1"><f a="newev">
	<x path="Int"/>
	<x path="Void"/>
</f></swapEvent>
		<invalidate_precedence public="1" set="method" line="250" override="1"><f a=""><x path="Void"/></f></invalidate_precedence>
		<cbtype_change set="method" line="245"><f a="cb:included:added">
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></cbtype_change>
		<removedFromSpace public="1" set="method" line="232" override="1"><f a=""><x path="Void"/></f></removedFromSpace>
		<addedToSpace public="1" set="method" line="219" override="1"><f a=""><x path="Void"/></f></addedToSpace>
		<immutable_options set="method" line="205"><f a=""><x path="Void"/></f></immutable_options>
		<handler public="1"><f a="">
	<c path="nape.callbacks.BodyCallback"/>
	<x path="Void"/>
</f></handler>
		<options public="1"><c path="zpp_nape.callbacks.ZPP_OptionType"/></options>
		<outer_zn public="1"><c path="nape.callbacks.BodyListener"/></outer_zn>
		<new public="1" set="method" line="211"><f a="options:event:handler">
	<c path="nape.callbacks.OptionType"/>
	<x path="Int"/>
	<f a="">
		<c path="nape.callbacks.BodyCallback"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></new>
	</class>
	<class path="zpp_nape.callbacks.ZPP_ConstraintListener" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/callbacks/Listener.hx" module="zpp_nape.callbacks.Listener">
		<extends path="zpp_nape.callbacks.ZPP_Listener"/>
		<swapEvent public="1" set="method" line="324" override="1"><f a="newev">
	<x path="Int"/>
	<x path="Void"/>
</f></swapEvent>
		<invalidate_precedence public="1" set="method" line="318" override="1"><f a=""><x path="Void"/></f></invalidate_precedence>
		<cbtype_change set="method" line="313"><f a="cb:included:added">
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></cbtype_change>
		<removedFromSpace public="1" set="method" line="300" override="1"><f a=""><x path="Void"/></f></removedFromSpace>
		<addedToSpace public="1" set="method" line="287" override="1"><f a=""><x path="Void"/></f></addedToSpace>
		<immutable_options set="method" line="273"><f a=""><x path="Void"/></f></immutable_options>
		<handler public="1"><f a="">
	<c path="nape.callbacks.ConstraintCallback"/>
	<x path="Void"/>
</f></handler>
		<options public="1"><c path="zpp_nape.callbacks.ZPP_OptionType"/></options>
		<outer_zn public="1"><c path="nape.callbacks.ConstraintListener"/></outer_zn>
		<new public="1" set="method" line="279"><f a="options:event:handler">
	<c path="nape.callbacks.OptionType"/>
	<x path="Int"/>
	<f a="">
		<c path="nape.callbacks.ConstraintCallback"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_CbType" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="578"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
</f></at>
		<iterator_at public="1" set="method" line="565"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CbType"/>
</f></iterator_at>
		<back public="1" set="method" line="556"><f a=""><c path="zpp_nape.callbacks.ZPP_CbType"/></f></back>
		<front public="1" get="inline" set="null" line="553"><f a=""><c path="zpp_nape.callbacks.ZPP_CbType"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="523"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="518"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="515"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="510"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="495"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="489"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="484"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="480"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_CbType"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CbType"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="434"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_CbType"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CbType"/>
</f></inlined_erase>
		<erase public="1" set="method" line="429"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_CbType"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CbType"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="406"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="393"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="368"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="357"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="344"><f a=""><c path="zpp_nape.callbacks.ZPP_CbType"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="339"><f a=""><c path="zpp_nape.callbacks.ZPP_CbType"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="306"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="301"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="258"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_CbType"/>
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CbType"/>
</f></inlined_insert>
		<insert public="1" set="method" line="253"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_CbType"/>
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CbType"/>
</f></insert>
		<addAll public="1" set="method" line="235"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_CbType"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="198"><f a="o">
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
</f></inlined_add>
		<add public="1" set="method" line="193"><f a="o">
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="188"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_CbType"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="180"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_CbType"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_CbType"/></head>
		<new public="1" set="method" line="177"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.callbacks.ZPP_InteractionListener" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/callbacks/Listener.hx" module="zpp_nape.callbacks.Listener">
		<extends path="zpp_nape.callbacks.ZPP_Listener"/>
		<UCbSet line="383" static="1"><c path="zpp_nape.util.ZNPList_ZPP_CbSet"/></UCbSet>
		<VCbSet line="384" static="1"><c path="zpp_nape.util.ZNPList_ZPP_CbSet"/></VCbSet>
		<WCbSet line="385" static="1"><c path="zpp_nape.util.ZNPList_ZPP_CbSet"/></WCbSet>
		<UCbType line="462" static="1"><c path="zpp_nape.util.ZNPList_ZPP_CbType"/></UCbType>
		<VCbType line="463" static="1"><c path="zpp_nape.util.ZNPList_ZPP_CbType"/></VCbType>
		<WCbType line="464" static="1"><c path="zpp_nape.util.ZNPList_ZPP_CbType"/></WCbType>
		<swapEvent public="1" set="method" line="710" override="1"><f a="newev">
	<x path="Int"/>
	<x path="Void"/>
</f></swapEvent>
		<cbtype_change set="method" line="703"><f a="options:cb:included:added">
	<c path="zpp_nape.callbacks.ZPP_OptionType"/>
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></cbtype_change>
		<cbtype_change2 set="method" line="700"><f a="cb:included:added">
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></cbtype_change2>
		<cbtype_change1 set="method" line="697"><f a="cb:included:added">
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></cbtype_change1>
		<invalidate_precedence public="1" set="method" line="678" override="1"><f a=""><x path="Void"/></f></invalidate_precedence>
		<removedFromSpace public="1" set="method" line="659" override="1"><f a=""><x path="Void"/></f></removedFromSpace>
		<addedToSpace public="1" set="method" line="640" override="1"><f a=""><x path="Void"/></f></addedToSpace>
		<with_union get="inline" set="null" line="611"><f a="lambda">
	<f a="">
		<c path="zpp_nape.callbacks.ZPP_CbType"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></with_union>
		<with_uniquesets set="method" line="541"><f a="fresh">
	<x path="Bool"/>
	<x path="Void"/>
</f></with_uniquesets>
		<CbTypeset get="inline" set="null" line="467"><f a="A:B:lambda">
	<c path="zpp_nape.util.ZNPList_ZPP_CbType"/>
	<c path="zpp_nape.util.ZNPList_ZPP_CbType"/>
	<f a=":">
		<c path="zpp_nape.callbacks.ZPP_CbType"/>
		<c path="zpp_nape.callbacks.ZPP_CbType"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></CbTypeset>
		<CbSetset get="inline" set="null" line="388"><f a="A:B:lambda">
	<c path="zpp_nape.util.ZNPList_ZPP_CbSet"/>
	<c path="zpp_nape.util.ZNPList_ZPP_CbSet"/>
	<f a=":">
		<c path="zpp_nape.callbacks.ZPP_CbSet"/>
		<c path="zpp_nape.callbacks.ZPP_CbSet"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></CbSetset>
		<wake public="1" set="method" line="360"><f a=""><x path="Void"/></f></wake>
		<setInteractionType public="1" get="inline" set="null" line="348"><f a="itype">
	<x path="Int"/>
	<x path="Void"/>
</f></setInteractionType>
		<handlerp public="1"><t path="Null"><f a="">
	<c path="nape.callbacks.PreCallback"/>
	<t path="Null"><c path="nape.callbacks.PreFlag"/></t>
</f></t></handlerp>
		<pure public="1"><x path="Bool"/></pure>
		<allowSleepingCallbacks public="1"><x path="Bool"/></allowSleepingCallbacks>
		<handleri public="1"><t path="Null"><f a="">
	<c path="nape.callbacks.InteractionCallback"/>
	<x path="Void"/>
</f></t></handleri>
		<options2 public="1"><c path="zpp_nape.callbacks.ZPP_OptionType"/></options2>
		<options1 public="1"><c path="zpp_nape.callbacks.ZPP_OptionType"/></options1>
		<itype public="1"><x path="Int"/></itype>
		<outer_znp public="1"><t path="Null"><c path="nape.callbacks.PreListener"/></t></outer_znp>
		<outer_zni public="1"><t path="Null"><c path="nape.callbacks.InteractionListener"/></t></outer_zni>
		<new public="1" set="method" line="351"><f a="options1:options2:event:type">
	<c path="nape.callbacks.OptionType"/>
	<c path="nape.callbacks.OptionType"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="zpp_nape.callbacks.ZPP_OptionType" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/callbacks/OptionType.hx" module="zpp_nape.callbacks.OptionType">
		<argument public="1" set="method" line="350" static="1"><f a="val">
	<d/>
	<c path="nape.callbacks.OptionType"/>
</f></argument>
		<append public="1" set="method" line="312"><f a="list:val">
	<c path="zpp_nape.util.ZNPList_ZPP_CbType"/>
	<d/>
	<x path="Void"/>
</f></append>
		<set public="1" set="method" line="289"><f a="options">
	<c path="zpp_nape.callbacks.ZPP_OptionType"/>
	<c path="zpp_nape.callbacks.ZPP_OptionType"/>
</f></set>
		<append_type set="method" line="263"><f a="list:val">
	<c path="zpp_nape.util.ZNPList_ZPP_CbType"/>
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<x path="Void"/>
</f></append_type>
		<effect_change public="1" get="inline" set="null" line="225"><f a="val:included:added">
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></effect_change>
		<nonemptyintersection public="1" set="method" line="203"><f a="xs:ys">
	<c path="zpp_nape.util.ZNPList_ZPP_CbType"/>
	<c path="zpp_nape.util.ZNPList_ZPP_CbType"/>
	<x path="Bool"/>
</f></nonemptyintersection>
		<compatible public="1" get="inline" set="null" line="200"><f a="xs">
	<c path="zpp_nape.util.ZNPList_ZPP_CbType"/>
	<x path="Bool"/>
</f></compatible>
		<included public="1" get="inline" set="null" line="196"><f a="xs">
	<c path="zpp_nape.util.ZNPList_ZPP_CbType"/>
	<x path="Bool"/>
</f></included>
		<excluded public="1" get="inline" set="null" line="192"><f a="xs">
	<c path="zpp_nape.util.ZNPList_ZPP_CbType"/>
	<x path="Bool"/>
</f></excluded>
		<setup_excludes public="1" set="method" line="188"><f a=""><x path="Void"/></f></setup_excludes>
		<setup_includes public="1" set="method" line="185"><f a=""><x path="Void"/></f></setup_includes>
		<wrap_excludes public="1"><c path="nape.callbacks.CbTypeList"/></wrap_excludes>
		<wrap_includes public="1"><c path="nape.callbacks.CbTypeList"/></wrap_includes>
		<excludes public="1"><c path="zpp_nape.util.ZNPList_ZPP_CbType"/></excludes>
		<includes public="1"><c path="zpp_nape.util.ZNPList_ZPP_CbType"/></includes>
		<handler public="1"><t path="Null"><f a="::">
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></t></handler>
		<outer public="1"><c path="nape.callbacks.OptionType"/></outer>
		<new public="1" set="method" line="179"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.constraint.ZPP_Constraint" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/constraint/Constraint.hx" module="zpp_nape.constraint.Constraint">
		<copyto public="1" set="method" line="539"><f a="ret">
	<c path="nape.constraint.Constraint"/>
	<x path="Void"/>
</f></copyto>
		<copy public="1" set="method" line="536"><f a="?dict:?todo">
	<c path="Array"><c path="zpp_nape.constraint.ZPP_CopyHelper"/></c>
	<c path="Array"><c path="zpp_nape.constraint.ZPP_CopyHelper"/></c>
	<c path="nape.constraint.Constraint"/>
</f></copy>
		<draw public="1" set="method" line="535"><f a="g">
	<c path="nape.util.Debug"/>
	<x path="Void"/>
</f></draw>
		<wake public="1" set="method" line="532"><f a=""><x path="Void"/></f></wake>
		<applyImpulsePos public="1" set="method" line="521"><f a=""><x path="Bool"/></f></applyImpulsePos>
		<applyImpulseVel public="1" set="method" line="509"><f a=""><x path="Bool"/></f></applyImpulseVel>
		<preStep public="1" set="method" line="497"><f a="dt">
	<x path="Float"/>
	<x path="Bool"/>
</f></preStep>
		<pre_dt public="1"><x path="Float"/></pre_dt>
		<warmStart public="1" set="method" line="485"><f a=""><x path="Void"/></f></warmStart>
		<broken public="1" set="method" line="483"><f a=""><x path="Void"/></f></broken>
		<pair_exists public="1" set="method" line="471"><f a="id:di">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></pair_exists>
		<forest public="1" set="method" line="460"><f a=""><x path="Void"/></f></forest>
		<wake_connected public="1" set="method" line="449"><f a=""><x path="Void"/></f></wake_connected>
		<validate public="1" set="method" line="438"><f a=""><x path="Void"/></f></validate>
		<clearcache public="1" set="method" line="427"><f a=""><x path="Void"/></f></clearcache>
		<inactiveBodies public="1" set="method" line="416"><f a=""><x path="Void"/></f></inactiveBodies>
		<activeBodies public="1" set="method" line="405"><f a=""><x path="Void"/></f></activeBodies>
		<inactiveOrOutSpace public="1" set="method" line="383"><f a=""><x path="Void"/></f></inactiveOrOutSpace>
		<activeInSpace public="1" set="method" line="353"><f a=""><x path="Void"/></f></activeInSpace>
		<removedFromSpace public="1" set="method" line="341"><f a=""><x path="Void"/></f></removedFromSpace>
		<addedToSpace public="1" set="method" line="329"><f a=""><x path="Void"/></f></addedToSpace>
		<deactivate public="1" set="method" line="326"><f a=""><x path="Void"/></f></deactivate>
		<activate public="1" set="method" line="323"><f a=""><x path="Void"/></f></activate>
		<dealloc_cbSet public="1" set="method" line="289"><f a=""><x path="Void"/></f></dealloc_cbSet>
		<alloc_cbSet public="1" set="method" line="275"><f a=""><x path="Void"/></f></alloc_cbSet>
		<insert_cbtype public="1" set="method" line="248"><f a="cb">
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<x path="Void"/>
</f></insert_cbtype>
		<wrap_cbTypes_adder set="method" line="244"><f a="cb">
	<c path="nape.callbacks.CbType"/>
	<x path="Bool"/>
</f></wrap_cbTypes_adder>
		<wrap_cbTypes_subber set="method" line="230"><f a="pcb">
	<c path="nape.callbacks.CbType"/>
	<x path="Void"/>
</f></wrap_cbTypes_subber>
		<immutable_cbTypes set="method" line="226"><f a=""><x path="Void"/></f></immutable_cbTypes>
		<setupcbTypes public="1" set="method" line="216"><f a=""><x path="Void"/></f></setupcbTypes>
		<wrap_cbTypes public="1"><c path="nape.callbacks.CbTypeList"/></wrap_cbTypes>
		<cbSet public="1"><c path="zpp_nape.callbacks.ZPP_CbSet"/></cbSet>
		<cbTypes public="1"><c path="zpp_nape.util.ZNPList_ZPP_CbType"/></cbTypes>
		<immutable_midstep public="1" set="method" line="208"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></immutable_midstep>
		<__velocity public="1"><x path="Bool"/></__velocity>
		<ignore public="1"><x path="Bool"/></ignore>
		<component public="1"><c path="zpp_nape.space.ZPP_Component"/></component>
		<removeOnBreak public="1"><x path="Bool"/></removeOnBreak>
		<breakUnderError public="1"><x path="Bool"/></breakUnderError>
		<breakUnderForce public="1"><x path="Bool"/></breakUnderForce>
		<maxError public="1"><x path="Float"/></maxError>
		<maxForce public="1"><x path="Float"/></maxForce>
		<damping public="1"><x path="Float"/></damping>
		<frequency public="1"><x path="Float"/></frequency>
		<stiff public="1"><x path="Bool"/></stiff>
		<active public="1"><x path="Bool"/></active>
		<space public="1"><c path="zpp_nape.space.ZPP_Space"/></space>
		<compound public="1"><c path="zpp_nape.phys.ZPP_Compound"/></compound>
		<userData public="1"><d><d/></d></userData>
		<id public="1"><x path="Int"/></id>
		<clear public="1" set="method" line="176"><f a=""><x path="Void"/></f></clear>
		<outer public="1"><c path="nape.constraint.Constraint"/></outer>
		<new public="1" set="method" line="193"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.constraint.ZPP_AngleJoint" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/constraint/AngleJoint.hx" module="zpp_nape.constraint.AngleJoint">
		<extends path="zpp_nape.constraint.ZPP_Constraint"/>
		<draw public="1" set="method" line="579" override="1"><f a="g">
	<c path="nape.util.Debug"/>
	<x path="Void"/>
</f></draw>
		<applyImpulsePos public="1" set="method" line="532" override="1"><f a=""><x path="Bool"/></f></applyImpulsePos>
		<applyImpulseVel public="1" set="method" line="493" override="1"><f a=""><x path="Bool"/></f></applyImpulseVel>
		<warmStart public="1" set="method" line="481" override="1"><f a=""><x path="Void"/></f></warmStart>
		<preStep public="1" set="method" line="417" override="1"><f a="dt">
	<x path="Float"/>
	<x path="Bool"/>
</f></preStep>
		<clearcache public="1" set="method" line="412" override="1"><f a=""><x path="Void"/></f></clearcache>
		<pair_exists public="1" set="method" line="409" override="1"><f a="id:di">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></pair_exists>
		<forest public="1" set="method" line="311" override="1"><f a=""><x path="Void"/></f></forest>
		<wake_connected public="1" set="method" line="307" override="1"><f a=""><x path="Void"/></f></wake_connected>
		<validate public="1" set="method" line="300" override="1"><f a=""><x path="Void"/></f></validate>
		<copy public="1" set="method" line="245" override="1"><f a="?dict:?todo">
	<c path="Array"><c path="zpp_nape.constraint.ZPP_CopyHelper"/></c>
	<c path="Array"><c path="zpp_nape.constraint.ZPP_CopyHelper"/></c>
	<c path="nape.constraint.Constraint"/>
</f></copy>
		<stepped public="1"><x path="Bool"/></stepped>
		<bias public="1"><x path="Float"/></bias>
		<gamma public="1"><x path="Float"/></gamma>
		<jMax public="1"><x path="Float"/></jMax>
		<jAcc public="1"><x path="Float"/></jAcc>
		<kMass public="1"><x path="Float"/></kMass>
		<b2 public="1"><c path="zpp_nape.phys.ZPP_Body"/></b2>
		<b1 public="1"><c path="zpp_nape.phys.ZPP_Body"/></b1>
		<inactiveBodies public="1" set="method" line="229" override="1"><f a=""><x path="Void"/></f></inactiveBodies>
		<activeBodies public="1" set="method" line="221" override="1"><f a=""><x path="Void"/></f></activeBodies>
		<bodyImpulse public="1" set="method" line="214"><f a="b">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="nape.geom.Vec3"/>
</f></bodyImpulse>
		<is_slack public="1" get="inline" set="null" line="184"><f a=""><x path="Bool"/></f></is_slack>
		<scale public="1"><x path="Float"/></scale>
		<equal public="1"><x path="Bool"/></equal>
		<slack public="1"><x path="Bool"/></slack>
		<jointMax public="1"><x path="Float"/></jointMax>
		<jointMin public="1"><x path="Float"/></jointMin>
		<ratio public="1"><x path="Float"/></ratio>
		<outer_zn public="1"><c path="nape.constraint.AngleJoint"/></outer_zn>
		<new public="1" set="method" line="292"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.constraint.ZPP_CopyHelper" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/constraint/Constraint.hx" module="zpp_nape.constraint.Constraint">
		<dict public="1" set="method" line="560" static="1"><f a="id:bc">
	<x path="Int"/>
	<c path="nape.phys.Body"/>
	<c path="zpp_nape.constraint.ZPP_CopyHelper"/>
</f></dict>
		<todo public="1" set="method" line="566" static="1"><f a="id:cb">
	<x path="Int"/>
	<f a="">
		<c path="nape.phys.Body"/>
		<x path="Void"/>
	</f>
	<c path="zpp_nape.constraint.ZPP_CopyHelper"/>
</f></todo>
		<cb public="1"><f a="">
	<c path="nape.phys.Body"/>
	<x path="Void"/>
</f></cb>
		<bc public="1"><c path="nape.phys.Body"/></bc>
		<id public="1"><x path="Int"/></id>
		<new set="method" line="559"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.constraint.ZPP_DistanceJoint" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/constraint/DistanceJoint.hx" module="zpp_nape.constraint.DistanceJoint">
		<extends path="zpp_nape.constraint.ZPP_Constraint"/>
		<draw public="1" set="method" line="1288" override="1"><f a="g">
	<c path="nape.util.Debug"/>
	<x path="Void"/>
</f></draw>
		<applyImpulsePos public="1" set="method" line="977" override="1"><f a=""><x path="Bool"/></f></applyImpulsePos>
		<applyImpulseVel public="1" set="method" line="887" override="1"><f a=""><x path="Bool"/></f></applyImpulseVel>
		<warmStart public="1" set="method" line="823" override="1"><f a=""><x path="Void"/></f></warmStart>
		<preStep public="1" set="method" line="687" override="1"><f a="dt">
	<x path="Float"/>
	<x path="Bool"/>
</f></preStep>
		<clearcache public="1" set="method" line="683" override="1"><f a=""><x path="Void"/></f></clearcache>
		<pair_exists public="1" set="method" line="680" override="1"><f a="id:di">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></pair_exists>
		<forest public="1" set="method" line="582" override="1"><f a=""><x path="Void"/></f></forest>
		<wake_connected public="1" set="method" line="578" override="1"><f a=""><x path="Void"/></f></wake_connected>
		<validate public="1" set="method" line="571" override="1"><f a=""><x path="Void"/></f></validate>
		<copy public="1" set="method" line="433" override="1"><f a="?dict:?todo">
	<c path="Array"><c path="zpp_nape.constraint.ZPP_CopyHelper"/></c>
	<c path="Array"><c path="zpp_nape.constraint.ZPP_CopyHelper"/></c>
	<c path="nape.constraint.Constraint"/>
</f></copy>
		<stepped public="1"><x path="Bool"/></stepped>
		<bias public="1"><x path="Float"/></bias>
		<gamma public="1"><x path="Float"/></gamma>
		<jMax public="1"><x path="Float"/></jMax>
		<jAcc public="1"><x path="Float"/></jAcc>
		<kMass public="1"><x path="Float"/></kMass>
		<wrap_a2 public="1"><c path="nape.geom.Vec2"/></wrap_a2>
		<setup_a2 public="1" set="method" line="420"><f a=""><x path="Void"/></f></setup_a2>
		<invalidate_a2 set="method" line="396"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></invalidate_a2>
		<validate_a2 set="method" line="374"><f a=""><x path="Void"/></f></validate_a2>
		<a2rely public="1"><x path="Float"/></a2rely>
		<a2relx public="1"><x path="Float"/></a2relx>
		<a2localy public="1"><x path="Float"/></a2localy>
		<a2localx public="1"><x path="Float"/></a2localx>
		<b2 public="1"><c path="zpp_nape.phys.ZPP_Body"/></b2>
		<wrap_a1 public="1"><c path="nape.geom.Vec2"/></wrap_a1>
		<setup_a1 public="1" set="method" line="362"><f a=""><x path="Void"/></f></setup_a1>
		<invalidate_a1 set="method" line="338"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></invalidate_a1>
		<validate_a1 set="method" line="316"><f a=""><x path="Void"/></f></validate_a1>
		<a1rely public="1"><x path="Float"/></a1rely>
		<a1relx public="1"><x path="Float"/></a1relx>
		<a1localy public="1"><x path="Float"/></a1localy>
		<a1localx public="1"><x path="Float"/></a1localx>
		<b1 public="1"><c path="zpp_nape.phys.ZPP_Body"/></b1>
		<inactiveBodies public="1" set="method" line="303" override="1"><f a=""><x path="Void"/></f></inactiveBodies>
		<activeBodies public="1" set="method" line="295" override="1"><f a=""><x path="Void"/></f></activeBodies>
		<bodyImpulse public="1" set="method" line="288"><f a="b">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="nape.geom.Vec3"/>
</f></bodyImpulse>
		<cx2 public="1"><x path="Float"/></cx2>
		<cx1 public="1"><x path="Float"/></cx1>
		<ny public="1"><x path="Float"/></ny>
		<nx public="1"><x path="Float"/></nx>
		<is_slack public="1" get="inline" set="null" line="182"><f a=""><x path="Bool"/></f></is_slack>
		<equal public="1"><x path="Bool"/></equal>
		<slack public="1"><x path="Bool"/></slack>
		<jointMax public="1"><x path="Float"/></jointMax>
		<jointMin public="1"><x path="Float"/></jointMin>
		<outer_zn public="1"><c path="nape.constraint.DistanceJoint"/></outer_zn>
		<new public="1" set="method" line="480"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.constraint.ZPP_LineJoint" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/constraint/LineJoint.hx" module="zpp_nape.constraint.LineJoint">
		<extends path="zpp_nape.constraint.ZPP_Constraint"/>
		<draw public="1" set="method" line="1571" override="1"><f a="g">
	<c path="nape.util.Debug"/>
	<x path="Void"/>
</f></draw>
		<applyImpulsePos public="1" set="method" line="1279" override="1"><f a=""><x path="Bool"/></f></applyImpulsePos>
		<applyImpulseVel public="1" set="method" line="1076" override="1"><f a=""><x path="Bool"/></f></applyImpulseVel>
		<warmStart public="1" set="method" line="994" override="1"><f a=""><x path="Void"/></f></warmStart>
		<preStep public="1" set="method" line="778" override="1"><f a="dt">
	<x path="Float"/>
	<x path="Bool"/>
</f></preStep>
		<clearcache public="1" set="method" line="755" override="1"><f a=""><x path="Void"/></f></clearcache>
		<pair_exists public="1" set="method" line="752" override="1"><f a="id:di">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></pair_exists>
		<forest public="1" set="method" line="654" override="1"><f a=""><x path="Void"/></f></forest>
		<wake_connected public="1" set="method" line="650" override="1"><f a=""><x path="Void"/></f></wake_connected>
		<validate public="1" set="method" line="642" override="1"><f a=""><x path="Void"/></f></validate>
		<copy public="1" set="method" line="442" override="1"><f a="?dict:?todo">
	<c path="Array"><c path="zpp_nape.constraint.ZPP_CopyHelper"/></c>
	<c path="Array"><c path="zpp_nape.constraint.ZPP_CopyHelper"/></c>
	<c path="nape.constraint.Constraint"/>
</f></copy>
		<stepped public="1"><x path="Bool"/></stepped>
		<biasy public="1"><x path="Float"/></biasy>
		<biasx public="1"><x path="Float"/></biasx>
		<gamma public="1"><x path="Float"/></gamma>
		<jMax public="1"><x path="Float"/></jMax>
		<jAccy public="1"><x path="Float"/></jAccy>
		<jAccx public="1"><x path="Float"/></jAccx>
		<kMassc public="1"><x path="Float"/></kMassc>
		<kMassb public="1"><x path="Float"/></kMassb>
		<kMassa public="1"><x path="Float"/></kMassa>
		<validate_norm public="1" set="method" line="402"><f a=""><x path="Void"/></f></validate_norm>
		<wrap_n public="1"><c path="nape.geom.Vec2"/></wrap_n>
		<setup_n public="1" set="method" line="395"><f a=""><x path="Void"/></f></setup_n>
		<invalidate_n set="method" line="368"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></invalidate_n>
		<validate_n set="method" line="346"><f a=""><x path="Void"/></f></validate_n>
		<nrely public="1"><x path="Float"/></nrely>
		<nrelx public="1"><x path="Float"/></nrelx>
		<nlocaly public="1"><x path="Float"/></nlocaly>
		<nlocalx public="1"><x path="Float"/></nlocalx>
		<zip_n public="1"><x path="Bool"/></zip_n>
		<wrap_a2 public="1"><c path="nape.geom.Vec2"/></wrap_a2>
		<setup_a2 public="1" set="method" line="334"><f a=""><x path="Void"/></f></setup_a2>
		<invalidate_a2 set="method" line="310"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></invalidate_a2>
		<validate_a2 set="method" line="288"><f a=""><x path="Void"/></f></validate_a2>
		<a2rely public="1"><x path="Float"/></a2rely>
		<a2relx public="1"><x path="Float"/></a2relx>
		<a2localy public="1"><x path="Float"/></a2localy>
		<a2localx public="1"><x path="Float"/></a2localx>
		<b2 public="1"><c path="zpp_nape.phys.ZPP_Body"/></b2>
		<wrap_a1 public="1"><c path="nape.geom.Vec2"/></wrap_a1>
		<setup_a1 public="1" set="method" line="276"><f a=""><x path="Void"/></f></setup_a1>
		<invalidate_a1 set="method" line="252"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></invalidate_a1>
		<validate_a1 set="method" line="230"><f a=""><x path="Void"/></f></validate_a1>
		<a1rely public="1"><x path="Float"/></a1rely>
		<a1relx public="1"><x path="Float"/></a1relx>
		<a1localy public="1"><x path="Float"/></a1localy>
		<a1localx public="1"><x path="Float"/></a1localx>
		<b1 public="1"><c path="zpp_nape.phys.ZPP_Body"/></b1>
		<inactiveBodies public="1" set="method" line="217" override="1"><f a=""><x path="Void"/></f></inactiveBodies>
		<activeBodies public="1" set="method" line="209" override="1"><f a=""><x path="Void"/></f></activeBodies>
		<bodyImpulse public="1" set="method" line="184"><f a="b">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="nape.geom.Vec3"/>
</f></bodyImpulse>
		<cx2 public="1"><x path="Float"/></cx2>
		<cx1 public="1"><x path="Float"/></cx1>
		<dot2 public="1"><x path="Float"/></dot2>
		<dot1 public="1"><x path="Float"/></dot1>
		<equal public="1"><x path="Bool"/></equal>
		<jointMax public="1"><x path="Float"/></jointMax>
		<jointMin public="1"><x path="Float"/></jointMin>
		<scale public="1"><x path="Float"/></scale>
		<outer_zn public="1"><c path="nape.constraint.LineJoint"/></outer_zn>
		<new public="1" set="method" line="489"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.constraint.ZPP_MotorJoint" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/constraint/MotorJoint.hx" module="zpp_nape.constraint.MotorJoint">
		<extends path="zpp_nape.constraint.ZPP_Constraint"/>
		<applyImpulsePos public="1" set="method" line="435" override="1"><f a=""><x path="Bool"/></f></applyImpulsePos>
		<applyImpulseVel public="1" set="method" line="402" override="1"><f a=""><x path="Bool"/></f></applyImpulseVel>
		<warmStart public="1" set="method" line="396" override="1"><f a=""><x path="Void"/></f></warmStart>
		<preStep public="1" set="method" line="375" override="1"><f a="dt">
	<x path="Float"/>
	<x path="Bool"/>
</f></preStep>
		<clearcache public="1" set="method" line="371" override="1"><f a=""><x path="Void"/></f></clearcache>
		<pair_exists public="1" set="method" line="368" override="1"><f a="id:di">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></pair_exists>
		<forest public="1" set="method" line="270" override="1"><f a=""><x path="Void"/></f></forest>
		<wake_connected public="1" set="method" line="266" override="1"><f a=""><x path="Void"/></f></wake_connected>
		<validate public="1" set="method" line="260" override="1"><f a=""><x path="Void"/></f></validate>
		<copy public="1" set="method" line="207" override="1"><f a="?dict:?todo">
	<c path="Array"><c path="zpp_nape.constraint.ZPP_CopyHelper"/></c>
	<c path="Array"><c path="zpp_nape.constraint.ZPP_CopyHelper"/></c>
	<c path="nape.constraint.Constraint"/>
</f></copy>
		<stepped public="1"><x path="Bool"/></stepped>
		<jMax public="1"><x path="Float"/></jMax>
		<jAcc public="1"><x path="Float"/></jAcc>
		<kMass public="1"><x path="Float"/></kMass>
		<b2 public="1"><c path="zpp_nape.phys.ZPP_Body"/></b2>
		<b1 public="1"><c path="zpp_nape.phys.ZPP_Body"/></b1>
		<inactiveBodies public="1" set="method" line="193" override="1"><f a=""><x path="Void"/></f></inactiveBodies>
		<activeBodies public="1" set="method" line="185" override="1"><f a=""><x path="Void"/></f></activeBodies>
		<bodyImpulse public="1" set="method" line="178"><f a="b">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="nape.geom.Vec3"/>
</f></bodyImpulse>
		<rate public="1"><x path="Float"/></rate>
		<ratio public="1"><x path="Float"/></ratio>
		<outer_zn public="1"><c path="nape.constraint.MotorJoint"/></outer_zn>
		<new public="1" set="method" line="254"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.constraint.ZPP_PivotJoint" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/constraint/PivotJoint.hx" module="zpp_nape.constraint.PivotJoint">
		<extends path="zpp_nape.constraint.ZPP_Constraint"/>
		<draw public="1" set="method" line="1342" override="1"><f a="g">
	<c path="nape.util.Debug"/>
	<x path="Void"/>
</f></draw>
		<applyImpulsePos public="1" set="method" line="1034" override="1"><f a=""><x path="Bool"/></f></applyImpulsePos>
		<applyImpulseVel public="1" set="method" line="858" override="1"><f a=""><x path="Bool"/></f></applyImpulseVel>
		<warmStart public="1" set="method" line="794" override="1"><f a=""><x path="Void"/></f></warmStart>
		<preStep public="1" set="method" line="615" override="1"><f a="dt">
	<x path="Float"/>
	<x path="Bool"/>
</f></preStep>
		<clearcache public="1" set="method" line="592" override="1"><f a=""><x path="Void"/></f></clearcache>
		<pair_exists public="1" set="method" line="589" override="1"><f a="id:di">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></pair_exists>
		<forest public="1" set="method" line="491" override="1"><f a=""><x path="Void"/></f></forest>
		<wake_connected public="1" set="method" line="487" override="1"><f a=""><x path="Void"/></f></wake_connected>
		<validate public="1" set="method" line="481" override="1"><f a=""><x path="Void"/></f></validate>
		<copy public="1" set="method" line="325" override="1"><f a="?dict:?todo">
	<c path="Array"><c path="zpp_nape.constraint.ZPP_CopyHelper"/></c>
	<c path="Array"><c path="zpp_nape.constraint.ZPP_CopyHelper"/></c>
	<c path="nape.constraint.Constraint"/>
</f></copy>
		<stepped public="1"><x path="Bool"/></stepped>
		<biasy public="1"><x path="Float"/></biasy>
		<biasx public="1"><x path="Float"/></biasx>
		<gamma public="1"><x path="Float"/></gamma>
		<jMax public="1"><x path="Float"/></jMax>
		<jAccy public="1"><x path="Float"/></jAccy>
		<jAccx public="1"><x path="Float"/></jAccx>
		<kMassc public="1"><x path="Float"/></kMassc>
		<kMassb public="1"><x path="Float"/></kMassb>
		<kMassa public="1"><x path="Float"/></kMassa>
		<wrap_a2 public="1"><c path="nape.geom.Vec2"/></wrap_a2>
		<setup_a2 public="1" set="method" line="308"><f a=""><x path="Void"/></f></setup_a2>
		<invalidate_a2 set="method" line="284"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></invalidate_a2>
		<validate_a2 set="method" line="262"><f a=""><x path="Void"/></f></validate_a2>
		<a2rely public="1"><x path="Float"/></a2rely>
		<a2relx public="1"><x path="Float"/></a2relx>
		<a2localy public="1"><x path="Float"/></a2localy>
		<a2localx public="1"><x path="Float"/></a2localx>
		<b2 public="1"><c path="zpp_nape.phys.ZPP_Body"/></b2>
		<wrap_a1 public="1"><c path="nape.geom.Vec2"/></wrap_a1>
		<setup_a1 public="1" set="method" line="250"><f a=""><x path="Void"/></f></setup_a1>
		<invalidate_a1 set="method" line="226"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></invalidate_a1>
		<validate_a1 set="method" line="204"><f a=""><x path="Void"/></f></validate_a1>
		<a1rely public="1"><x path="Float"/></a1rely>
		<a1relx public="1"><x path="Float"/></a1relx>
		<a1localy public="1"><x path="Float"/></a1localy>
		<a1localx public="1"><x path="Float"/></a1localx>
		<b1 public="1"><c path="zpp_nape.phys.ZPP_Body"/></b1>
		<inactiveBodies public="1" set="method" line="191" override="1"><f a=""><x path="Void"/></f></inactiveBodies>
		<activeBodies public="1" set="method" line="183" override="1"><f a=""><x path="Void"/></f></activeBodies>
		<bodyImpulse public="1" set="method" line="176"><f a="b">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="nape.geom.Vec3"/>
</f></bodyImpulse>
		<outer_zn public="1"><c path="nape.constraint.PivotJoint"/></outer_zn>
		<new public="1" set="method" line="372"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.constraint.ZPP_PulleyJoint" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/constraint/PulleyJoint.hx" module="zpp_nape.constraint.PulleyJoint">
		<extends path="zpp_nape.constraint.ZPP_Constraint"/>
		<draw public="1" set="method" line="2192" override="1"><f a="g">
	<c path="nape.util.Debug"/>
	<x path="Void"/>
</f></draw>
		<applyImpulsePos public="1" set="method" line="1633" override="1"><f a=""><x path="Bool"/></f></applyImpulsePos>
		<applyImpulseVel public="1" set="method" line="1487" override="1"><f a=""><x path="Bool"/></f></applyImpulseVel>
		<warmStart public="1" set="method" line="1367" override="1"><f a=""><x path="Void"/></f></warmStart>
		<preStep public="1" set="method" line="1165" override="1"><f a="dt">
	<x path="Float"/>
	<x path="Bool"/>
</f></preStep>
		<clearcache public="1" set="method" line="1161" override="1"><f a=""><x path="Void"/></f></clearcache>
		<pair_exists public="1" set="method" line="1158" override="1"><f a="id:di">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></pair_exists>
		<forest public="1" set="method" line="964" override="1"><f a=""><x path="Void"/></f></forest>
		<wake_connected public="1" set="method" line="958" override="1"><f a=""><x path="Void"/></f></wake_connected>
		<validate public="1" set="method" line="950" override="1"><f a=""><x path="Void"/></f></validate>
		<copy public="1" set="method" line="646" override="1"><f a="?dict:?todo">
	<c path="Array"><c path="zpp_nape.constraint.ZPP_CopyHelper"/></c>
	<c path="Array"><c path="zpp_nape.constraint.ZPP_CopyHelper"/></c>
	<c path="nape.constraint.Constraint"/>
</f></copy>
		<stepped public="1"><x path="Bool"/></stepped>
		<bias public="1"><x path="Float"/></bias>
		<gamma public="1"><x path="Float"/></gamma>
		<jMax public="1"><x path="Float"/></jMax>
		<jAcc public="1"><x path="Float"/></jAcc>
		<kMass public="1"><x path="Float"/></kMass>
		<wrap_a4 public="1"><c path="nape.geom.Vec2"/></wrap_a4>
		<setup_a4 public="1" set="method" line="633"><f a=""><x path="Void"/></f></setup_a4>
		<invalidate_a4 set="method" line="609"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></invalidate_a4>
		<validate_a4 set="method" line="587"><f a=""><x path="Void"/></f></validate_a4>
		<a4rely public="1"><x path="Float"/></a4rely>
		<a4relx public="1"><x path="Float"/></a4relx>
		<a4localy public="1"><x path="Float"/></a4localy>
		<a4localx public="1"><x path="Float"/></a4localx>
		<b4 public="1"><c path="zpp_nape.phys.ZPP_Body"/></b4>
		<wrap_a3 public="1"><c path="nape.geom.Vec2"/></wrap_a3>
		<setup_a3 public="1" set="method" line="575"><f a=""><x path="Void"/></f></setup_a3>
		<invalidate_a3 set="method" line="551"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></invalidate_a3>
		<validate_a3 set="method" line="529"><f a=""><x path="Void"/></f></validate_a3>
		<a3rely public="1"><x path="Float"/></a3rely>
		<a3relx public="1"><x path="Float"/></a3relx>
		<a3localy public="1"><x path="Float"/></a3localy>
		<a3localx public="1"><x path="Float"/></a3localx>
		<b3 public="1"><c path="zpp_nape.phys.ZPP_Body"/></b3>
		<wrap_a2 public="1"><c path="nape.geom.Vec2"/></wrap_a2>
		<setup_a2 public="1" set="method" line="517"><f a=""><x path="Void"/></f></setup_a2>
		<invalidate_a2 set="method" line="493"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></invalidate_a2>
		<validate_a2 set="method" line="471"><f a=""><x path="Void"/></f></validate_a2>
		<a2rely public="1"><x path="Float"/></a2rely>
		<a2relx public="1"><x path="Float"/></a2relx>
		<a2localy public="1"><x path="Float"/></a2localy>
		<a2localx public="1"><x path="Float"/></a2localx>
		<b2 public="1"><c path="zpp_nape.phys.ZPP_Body"/></b2>
		<wrap_a1 public="1"><c path="nape.geom.Vec2"/></wrap_a1>
		<setup_a1 public="1" set="method" line="459"><f a=""><x path="Void"/></f></setup_a1>
		<invalidate_a1 set="method" line="435"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></invalidate_a1>
		<validate_a1 set="method" line="413"><f a=""><x path="Void"/></f></validate_a1>
		<a1rely public="1"><x path="Float"/></a1rely>
		<a1relx public="1"><x path="Float"/></a1relx>
		<a1localy public="1"><x path="Float"/></a1localy>
		<a1localx public="1"><x path="Float"/></a1localx>
		<b1 public="1"><c path="zpp_nape.phys.ZPP_Body"/></b1>
		<inactiveBodies public="1" set="method" line="394" override="1"><f a=""><x path="Void"/></f></inactiveBodies>
		<activeBodies public="1" set="method" line="380" override="1"><f a=""><x path="Void"/></f></activeBodies>
		<bodyImpulse public="1" set="method" line="353"><f a="b">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="nape.geom.Vec3"/>
</f></bodyImpulse>
		<cx4 public="1"><x path="Float"/></cx4>
		<cx3 public="1"><x path="Float"/></cx3>
		<cx2 public="1"><x path="Float"/></cx2>
		<cx1 public="1"><x path="Float"/></cx1>
		<n34y public="1"><x path="Float"/></n34y>
		<n34x public="1"><x path="Float"/></n34x>
		<n12y public="1"><x path="Float"/></n12y>
		<n12x public="1"><x path="Float"/></n12x>
		<is_slack public="1" get="inline" set="null" line="183"><f a=""><x path="Bool"/></f></is_slack>
		<equal public="1"><x path="Bool"/></equal>
		<slack public="1"><x path="Bool"/></slack>
		<jointMax public="1"><x path="Float"/></jointMax>
		<jointMin public="1"><x path="Float"/></jointMin>
		<ratio public="1"><x path="Float"/></ratio>
		<outer_zn public="1"><c path="nape.constraint.PulleyJoint"/></outer_zn>
		<new public="1" set="method" line="735"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.constraint.ZPP_UserConstraint" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/constraint/UserConstraint.hx" module="zpp_nape.constraint.UserConstraint">
		<extends path="zpp_nape.constraint.ZPP_Constraint"/>
		<draw public="1" set="method" line="564" override="1"><f a="g">
	<c path="nape.util.Debug"/>
	<x path="Void"/>
</f></draw>
		<applyImpulsePos public="1" set="method" line="533" override="1"><f a=""><x path="Bool"/></f></applyImpulsePos>
		<applyImpulseVel public="1" set="method" line="499" override="1"><f a=""><x path="Bool"/></f></applyImpulseVel>
		<jOld><t path="nape.TArray"><x path="Float"/></t></jOld>
		<J><t path="nape.TArray"><x path="Float"/></t></J>
		<warmStart public="1" set="method" line="477" override="1"><f a=""><x path="Void"/></f></warmStart>
		<vec3><c path="nape.geom.Vec3"/></vec3>
		<preStep public="1" set="method" line="441" override="1"><f a="dt">
	<x path="Float"/>
	<x path="Bool"/>
</f></preStep>
		<Keff public="1"><t path="nape.TArray"><x path="Float"/></t></Keff>
		<jMax public="1"><x path="Float"/></jMax>
		<velonly public="1"><x path="Bool"/></velonly>
		<gamma public="1"><x path="Float"/></gamma>
		<soft public="1"><x path="Float"/></soft>
		<transform public="1" set="method" line="415"><f a="L:x">
	<t path="nape.TArray"><x path="Float"/></t>
	<t path="nape.TArray"><x path="Float"/></t>
	<x path="Void"/>
</f></transform>
		<y><t path="nape.TArray"><x path="Float"/></t></y>
		<solve public="1" set="method" line="392"><f a="m">
	<t path="nape.TArray"><x path="Float"/></t>
	<t path="nape.TArray"><x path="Float"/></t>
</f></solve>
		<L><t path="nape.TArray"><x path="Float"/></t></L>
		<_clamp public="1" set="method" line="384"><f a="v:max">
	<t path="nape.TArray"><x path="Float"/></t>
	<x path="Float"/>
	<x path="Void"/>
</f></_clamp>
		<lsq public="1" set="method" line="379"><f a="v">
	<t path="nape.TArray"><x path="Float"/></t>
	<x path="Float"/>
</f></lsq>
		<clearcache public="1" set="method" line="375" override="1"><f a=""><x path="Void"/></f></clearcache>
		<broken public="1" set="method" line="372" override="1"><f a=""><x path="Void"/></f></broken>
		<pair_exists public="1" set="method" line="356" override="1"><f a="id:di">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></pair_exists>
		<forest public="1" set="method" line="304" override="1"><f a=""><x path="Void"/></f></forest>
		<wake_connected public="1" set="method" line="299" override="1"><f a=""><x path="Void"/></f></wake_connected>
		<validate public="1" set="method" line="295" override="1"><f a=""><x path="Void"/></f></validate>
		<copy public="1" set="method" line="254" override="1"><f a="?dict:?todo">
	<c path="Array"><c path="zpp_nape.constraint.ZPP_CopyHelper"/></c>
	<c path="Array"><c path="zpp_nape.constraint.ZPP_CopyHelper"/></c>
	<c path="nape.constraint.Constraint"/>
</f></copy>
		<stepped public="1"><x path="Bool"/></stepped>
		<inactiveBodies public="1" set="method" line="248" override="1"><f a=""><x path="Void"/></f></inactiveBodies>
		<activeBodies public="1" set="method" line="243" override="1"><f a=""><x path="Void"/></f></activeBodies>
		<bodyImpulse public="1" set="method" line="237"><f a="b">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="nape.geom.Vec3"/>
</f></bodyImpulse>
		<remBody public="1" set="method" line="207"><f a="b">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Bool"/>
</f></remBody>
		<addBody public="1" set="method" line="183"><f a="b">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Void"/>
</f></addBody>
		<bias public="1"><t path="nape.TArray"><x path="Float"/></t></bias>
		<jAcc public="1"><t path="nape.TArray"><x path="Float"/></t></jAcc>
		<dim public="1"><x path="Int"/></dim>
		<bodies public="1"><t path="nape.TArray"><c path="zpp_nape.constraint.ZPP_UserBody"/></t></bodies>
		<bindVec2_invalidate public="1" set="method" line="176"><f a="_">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></bindVec2_invalidate>
		<outer_zn public="1"><c path="nape.constraint.UserConstraint"/></outer_zn>
		<new public="1" set="method" line="260"><f a="dim:velonly">
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="zpp_nape.constraint.ZPP_UserBody" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/constraint/UserConstraint.hx" module="zpp_nape.constraint.UserConstraint">
		<body public="1"><c path="zpp_nape.phys.ZPP_Body"/></body>
		<cnt public="1"><x path="Int"/></cnt>
		<new public="1" set="method" line="572"><f a="cnt:body">
	<x path="Int"/>
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="zpp_nape.constraint.ZPP_WeldJoint" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/constraint/WeldJoint.hx" module="zpp_nape.constraint.WeldJoint">
		<extends path="zpp_nape.constraint.ZPP_Constraint"/>
		<draw public="1" set="method" line="1531" override="1"><f a="g">
	<c path="nape.util.Debug"/>
	<x path="Void"/>
</f></draw>
		<applyImpulsePos public="1" set="method" line="1143" override="1"><f a=""><x path="Bool"/></f></applyImpulsePos>
		<applyImpulseVel public="1" set="method" line="922" override="1"><f a=""><x path="Bool"/></f></applyImpulseVel>
		<warmStart public="1" set="method" line="858" override="1"><f a=""><x path="Void"/></f></warmStart>
		<preStep public="1" set="method" line="628" override="1"><f a="dt">
	<x path="Float"/>
	<x path="Bool"/>
</f></preStep>
		<clearcache public="1" set="method" line="602" override="1"><f a=""><x path="Void"/></f></clearcache>
		<pair_exists public="1" set="method" line="599" override="1"><f a="id:di">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></pair_exists>
		<forest public="1" set="method" line="501" override="1"><f a=""><x path="Void"/></f></forest>
		<wake_connected public="1" set="method" line="497" override="1"><f a=""><x path="Void"/></f></wake_connected>
		<validate public="1" set="method" line="491" override="1"><f a=""><x path="Void"/></f></validate>
		<copy public="1" set="method" line="331" override="1"><f a="?dict:?todo">
	<c path="Array"><c path="zpp_nape.constraint.ZPP_CopyHelper"/></c>
	<c path="Array"><c path="zpp_nape.constraint.ZPP_CopyHelper"/></c>
	<c path="nape.constraint.Constraint"/>
</f></copy>
		<stepped public="1"><x path="Bool"/></stepped>
		<biasz public="1"><x path="Float"/></biasz>
		<biasy public="1"><x path="Float"/></biasy>
		<biasx public="1"><x path="Float"/></biasx>
		<gamma public="1"><x path="Float"/></gamma>
		<jMax public="1"><x path="Float"/></jMax>
		<jAccz public="1"><x path="Float"/></jAccz>
		<jAccy public="1"><x path="Float"/></jAccy>
		<jAccx public="1"><x path="Float"/></jAccx>
		<kMassf public="1"><x path="Float"/></kMassf>
		<kMasse public="1"><x path="Float"/></kMasse>
		<kMassc public="1"><x path="Float"/></kMassc>
		<kMassd public="1"><x path="Float"/></kMassd>
		<kMassb public="1"><x path="Float"/></kMassb>
		<kMassa public="1"><x path="Float"/></kMassa>
		<phase public="1"><x path="Float"/></phase>
		<wrap_a2 public="1"><c path="nape.geom.Vec2"/></wrap_a2>
		<setup_a2 public="1" set="method" line="308"><f a=""><x path="Void"/></f></setup_a2>
		<invalidate_a2 set="method" line="284"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></invalidate_a2>
		<validate_a2 set="method" line="262"><f a=""><x path="Void"/></f></validate_a2>
		<a2rely public="1"><x path="Float"/></a2rely>
		<a2relx public="1"><x path="Float"/></a2relx>
		<a2localy public="1"><x path="Float"/></a2localy>
		<a2localx public="1"><x path="Float"/></a2localx>
		<b2 public="1"><c path="zpp_nape.phys.ZPP_Body"/></b2>
		<wrap_a1 public="1"><c path="nape.geom.Vec2"/></wrap_a1>
		<setup_a1 public="1" set="method" line="250"><f a=""><x path="Void"/></f></setup_a1>
		<invalidate_a1 set="method" line="226"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></invalidate_a1>
		<validate_a1 set="method" line="204"><f a=""><x path="Void"/></f></validate_a1>
		<a1rely public="1"><x path="Float"/></a1rely>
		<a1relx public="1"><x path="Float"/></a1relx>
		<a1localy public="1"><x path="Float"/></a1localy>
		<a1localx public="1"><x path="Float"/></a1localx>
		<b1 public="1"><c path="zpp_nape.phys.ZPP_Body"/></b1>
		<inactiveBodies public="1" set="method" line="191" override="1"><f a=""><x path="Void"/></f></inactiveBodies>
		<activeBodies public="1" set="method" line="183" override="1"><f a=""><x path="Void"/></f></activeBodies>
		<bodyImpulse public="1" set="method" line="176"><f a="b">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="nape.geom.Vec3"/>
</f></bodyImpulse>
		<outer_zn public="1"><c path="nape.constraint.WeldJoint"/></outer_zn>
		<new public="1" set="method" line="378"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.dynamics.ZPP_Arbiter" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/dynamics/Arbiter.hx" module="zpp_nape.dynamics.Arbiter">
		<internal public="1" line="179" static="1"><x path="Bool"/></internal>
		<COL public="1" line="261" static="1"><x path="Int"/></COL>
		<FLUID public="1" line="262" static="1"><x path="Int"/></FLUID>
		<SENSOR public="1" line="263" static="1"><x path="Int"/></SENSOR>
		<sup_retire public="1" get="inline" set="null" line="308"><f a=""><x path="Void"/></f></sup_retire>
		<sup_assign public="1" get="inline" set="null" line="290"><f a="s1:s2:id:di">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></sup_assign>
		<lazyRetire public="1" get="inline" set="null" line="269"><f a="s:?b">
	<c path="zpp_nape.space.ZPP_Space"/>
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Void"/>
</f></lazyRetire>
		<sensorarb public="1"><c path="zpp_nape.dynamics.ZPP_SensorArbiter"/></sensorarb>
		<fluidarb public="1"><c path="zpp_nape.dynamics.ZPP_FluidArbiter"/></fluidarb>
		<colarb public="1"><c path="zpp_nape.dynamics.ZPP_ColArbiter"/></colarb>
		<type public="1"><x path="Int"/></type>
		<swap_features public="1" get="inline" set="null" line="235"><f a=""><x path="Void"/></f></swap_features>
		<pair public="1"><c path="zpp_nape.space.ZPP_AABBPair"/></pair>
		<ws2 public="1"><c path="zpp_nape.shape.ZPP_Shape"/></ws2>
		<ws1 public="1"><c path="zpp_nape.shape.ZPP_Shape"/></ws1>
		<b2 public="1"><c path="zpp_nape.phys.ZPP_Body"/></b2>
		<b1 public="1"><c path="zpp_nape.phys.ZPP_Body"/></b1>
		<invalidated public="1"><x path="Bool"/></invalidated>
		<acting public="1" get="inline" set="null" line="224"><f a=""><x path="Bool"/></f></acting>
		<immState public="1"><x path="Int"/></immState>
		<fresh public="1"><x path="Bool"/></fresh>
		<continuous public="1"><x path="Bool"/></continuous>
		<presentable public="1"><x path="Bool"/></presentable>
		<intchange public="1"><x path="Bool"/></intchange>
		<present public="1"><x path="Int"/></present>
		<sleeping public="1"><x path="Bool"/></sleeping>
		<cleared public="1"><x path="Bool"/></cleared>
		<active public="1"><x path="Bool"/></active>
		<endGenerated public="1"><x path="Int"/></endGenerated>
		<sleep_stamp public="1"><x path="Int"/></sleep_stamp>
		<up_stamp public="1"><x path="Int"/></up_stamp>
		<stamp public="1"><x path="Int"/></stamp>
		<di public="1"><x path="Int"/></di>
		<id public="1"><x path="Int"/></id>
		<hnext public="1"><c path="zpp_nape.dynamics.ZPP_Arbiter"/></hnext>
		<inactiveme public="1" get="inline" set="null" line="199"><f a=""><x path="Bool"/></f></inactiveme>
		<wrapper public="1" set="method" line="180"><f a=""><c path="nape.dynamics.Arbiter"/></f></wrapper>
		<outer public="1"><c path="nape.dynamics.Arbiter"/></outer>
		<new public="1" set="method" line="203"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.dynamics.ZPP_SensorArbiter" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/dynamics/Arbiter.hx" module="zpp_nape.dynamics.Arbiter">
		<extends path="zpp_nape.dynamics.ZPP_Arbiter"/>
		<zpp_pool public="1" line="357" static="1"><c path="zpp_nape.dynamics.ZPP_SensorArbiter"/></zpp_pool>
		<makeimmutable public="1" get="inline" set="null" line="442"><f a=""><x path="Void"/></f></makeimmutable>
		<makemutable public="1" get="inline" set="null" line="439"><f a=""><x path="Void"/></f></makemutable>
		<retire public="1" get="inline" set="null" line="417"><f a=""><x path="Void"/></f></retire>
		<assign public="1" get="inline" set="null" line="412"><f a="s1:s2:id:di">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></assign>
		<free public="1" get="inline" set="null" line="395"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="383"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.dynamics.ZPP_SensorArbiter"/></next>
		<new public="1" set="method" line="405"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.dynamics.ZPP_FluidArbiter" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/dynamics/Arbiter.hx" module="zpp_nape.dynamics.Arbiter">
		<extends path="zpp_nape.dynamics.ZPP_Arbiter"/>
		<zpp_pool public="1" line="448" static="1"><c path="zpp_nape.dynamics.ZPP_FluidArbiter"/></zpp_pool>
		<applyImpulseVel public="1" get="inline" set="null" line="1301"><f a=""><x path="Void"/></f></applyImpulseVel>
		<warmStart public="1" get="inline" set="null" line="1267"><f a=""><x path="Void"/></f></warmStart>
		<preStep public="1" get="inline" set="null" line="708"><f a="s:dt">
	<c path="zpp_nape.space.ZPP_Space"/>
	<x path="Float"/>
	<x path="Void"/>
</f></preStep>
		<pre_dt public="1"><x path="Float"/></pre_dt>
		<inject public="1" get="inline" set="null" line="682"><f a="area:cx:cy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></inject>
		<makeimmutable public="1" get="inline" set="null" line="676"><f a=""><x path="Void"/></f></makeimmutable>
		<makemutable public="1" get="inline" set="null" line="670"><f a=""><x path="Void"/></f></makemutable>
		<mutable public="1"><x path="Bool"/></mutable>
		<retire public="1" get="inline" set="null" line="646"><f a=""><x path="Void"/></f></retire>
		<assign public="1" get="inline" set="null" line="600"><f a="s1:s2:id:di">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></assign>
		<getposition public="1" set="method" line="565"><f a=""><x path="Void"/></f></getposition>
		<wrap_position public="1"><c path="nape.geom.Vec2"/></wrap_position>
		<position_invalidate set="method" line="542"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></position_invalidate>
		<position_validate set="method" line="517"><f a=""><x path="Void"/></f></position_validate>
		<buoyy public="1"><x path="Float"/></buoyy>
		<buoyx public="1"><x path="Float"/></buoyx>
		<ny public="1"><x path="Float"/></ny>
		<nx public="1"><x path="Float"/></nx>
		<lgamma public="1"><x path="Float"/></lgamma>
		<dampy public="1"><x path="Float"/></dampy>
		<dampx public="1"><x path="Float"/></dampx>
		<vMassc public="1"><x path="Float"/></vMassc>
		<vMassb public="1"><x path="Float"/></vMassb>
		<vMassa public="1"><x path="Float"/></vMassa>
		<agamma public="1"><x path="Float"/></agamma>
		<adamp public="1"><x path="Float"/></adamp>
		<wMass public="1"><x path="Float"/></wMass>
		<nodrag public="1"><x path="Bool"/></nodrag>
		<r2y public="1"><x path="Float"/></r2y>
		<r2x public="1"><x path="Float"/></r2x>
		<r1y public="1"><x path="Float"/></r1y>
		<r1x public="1"><x path="Float"/></r1x>
		<overlap public="1"><x path="Float"/></overlap>
		<centroidy public="1"><x path="Float"/></centroidy>
		<centroidx public="1"><x path="Float"/></centroidx>
		<free public="1" get="inline" set="null" line="486"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="474"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.dynamics.ZPP_FluidArbiter"/></next>
		<outer_zn public="1"><c path="nape.dynamics.FluidArbiter"/></outer_zn>
		<new public="1" set="method" line="572"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.dynamics.ZPP_ColArbiter" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/dynamics/Arbiter.hx" module="zpp_nape.dynamics.Arbiter">
		<extends path="zpp_nape.dynamics.ZPP_Arbiter"/>
		<FACE1 public="1" get="inline" set="null" line="1459" static="1"><x path="Int"/></FACE1>
		<FACE2 public="1" get="inline" set="null" line="1460" static="1"><x path="Int"/></FACE2>
		<CIRCLE public="1" get="inline" set="null" line="1461" static="1"><x path="Int"/></CIRCLE>
		<zpp_pool public="1" line="1479" static="1"><c path="zpp_nape.dynamics.ZPP_ColArbiter"/></zpp_pool>
		<applyImpulsePos public="1" get="inline" set="null" line="2335"><f a=""><x path="Void"/></f></applyImpulsePos>
		<applyImpulseVel public="1" get="inline" set="null" line="2190"><f a=""><x path="Void"/></f></applyImpulseVel>
		<warmStart public="1" get="inline" set="null" line="2120"><f a=""><x path="Void"/></f></warmStart>
		<preStep public="1" get="inline" set="null" line="1875"><f a="dt">
	<x path="Float"/>
	<x path="Bool"/>
</f></preStep>
		<pre_dt public="1"><x path="Float"/></pre_dt>
		<cleanupContacts public="1" get="inline" set="null" line="1785"><f a=""><x path="Bool"/></f></cleanupContacts>
		<setupcontacts public="1" set="method" line="1776"><f a=""><x path="Void"/></f></setupcontacts>
		<contacts_subber set="method" line="1737"><f a="x">
	<c path="nape.dynamics.Contact"/>
	<x path="Void"/>
</f></contacts_subber>
		<contacts_adder set="method" line="1731"><f a="x">
	<c path="nape.dynamics.Contact"/>
	<x path="Bool"/>
</f></contacts_adder>
		<makeimmutable public="1" get="inline" set="null" line="1726"><f a=""><x path="Void"/></f></makeimmutable>
		<makemutable public="1" get="inline" set="null" line="1719"><f a=""><x path="Void"/></f></makemutable>
		<mutable public="1"><x path="Bool"/></mutable>
		<retire public="1" get="inline" set="null" line="1675"><f a=""><x path="Void"/></f></retire>
		<validate_props public="1" get="inline" set="null" line="1667"><f a=""><x path="Void"/></f></validate_props>
		<calcProperties public="1" get="inline" set="null" line="1647"><f a=""><x path="Void"/></f></calcProperties>
		<assign public="1" get="inline" set="null" line="1639"><f a="s1:s2:id:di">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></assign>
		<injectContact public="1" get="inline" set="null" line="1551"><f a="px:py:nx:ny:dist:hash:?posOnly">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
</f></injectContact>
		<stat public="1"><x path="Bool"/></stat>
		<free public="1" get="inline" set="null" line="1525"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="1513"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.dynamics.ZPP_ColArbiter"/></next>
		<hpc2 public="1"><x path="Bool"/></hpc2>
		<hc2 public="1"><x path="Bool"/></hc2>
		<oc2 public="1"><c path="zpp_nape.dynamics.ZPP_Contact"/></oc2>
		<c2 public="1"><c path="zpp_nape.dynamics.ZPP_IContact"/></c2>
		<oc1 public="1"><c path="zpp_nape.dynamics.ZPP_Contact"/></oc1>
		<c1 public="1"><c path="zpp_nape.dynamics.ZPP_IContact"/></c1>
		<__ref_vertex public="1"><x path="Int"/></__ref_vertex>
		<__ref_edge2 public="1"><c path="zpp_nape.shape.ZPP_Edge"/></__ref_edge2>
		<__ref_edge1 public="1"><c path="zpp_nape.shape.ZPP_Edge"/></__ref_edge1>
		<biasCoef><x path="Float"/></biasCoef>
		<rev public="1"><x path="Bool"/></rev>
		<radius public="1"><x path="Float"/></radius>
		<lproj public="1"><x path="Float"/></lproj>
		<lnormy public="1"><x path="Float"/></lnormy>
		<lnormx public="1"><x path="Float"/></lnormx>
		<ptype public="1"><x path="Int"/></ptype>
		<surfacey public="1"><x path="Float"/></surfacey>
		<surfacex public="1"><x path="Float"/></surfacex>
		<k2y><x path="Float"/></k2y>
		<k2x><x path="Float"/></k2x>
		<k1y><x path="Float"/></k1y>
		<k1x><x path="Float"/></k1x>
		<rt2b><x path="Float"/></rt2b>
		<rn2b><x path="Float"/></rn2b>
		<rt2a><x path="Float"/></rt2a>
		<rn2a><x path="Float"/></rn2a>
		<rt1b><x path="Float"/></rt1b>
		<rn1b><x path="Float"/></rn1b>
		<rt1a><x path="Float"/></rt1a>
		<rn1a><x path="Float"/></rn1a>
		<jrAcc public="1"><x path="Float"/></jrAcc>
		<rMass public="1"><x path="Float"/></rMass>
		<Kc><x path="Float"/></Kc>
		<Kb><x path="Float"/></Kb>
		<Ka><x path="Float"/></Ka>
		<kMassc><x path="Float"/></kMassc>
		<kMassb><x path="Float"/></kMassb>
		<kMassa><x path="Float"/></kMassa>
		<getnormal public="1" set="method" line="1431"><f a=""><x path="Void"/></f></getnormal>
		<wrap_normal public="1"><c path="nape.geom.Vec2"/></wrap_normal>
		<normal_validate set="method" line="1407"><f a=""><x path="Void"/></f></normal_validate>
		<ny public="1"><x path="Float"/></ny>
		<nx public="1"><x path="Float"/></nx>
		<innards public="1"><c path="zpp_nape.dynamics.ZPP_IContact"/></innards>
		<wrap_contacts public="1"><c path="nape.dynamics.ContactList"/></wrap_contacts>
		<contacts public="1"><c path="zpp_nape.dynamics.ZPP_Contact"/></contacts>
		<s2 public="1"><c path="zpp_nape.shape.ZPP_Shape"/></s2>
		<s1 public="1"><c path="zpp_nape.shape.ZPP_Shape"/></s1>
		<userdef_rfric public="1"><x path="Bool"/></userdef_rfric>
		<userdef_restitution public="1"><x path="Bool"/></userdef_restitution>
		<userdef_stat_fric public="1"><x path="Bool"/></userdef_stat_fric>
		<userdef_dyn_fric public="1"><x path="Bool"/></userdef_dyn_fric>
		<rfric public="1"><x path="Float"/></rfric>
		<restitution public="1"><x path="Float"/></restitution>
		<stat_fric public="1"><x path="Float"/></stat_fric>
		<dyn_fric public="1"><x path="Float"/></dyn_fric>
		<outer_zn public="1"><c path="nape.dynamics.CollisionArbiter"/></outer_zn>
		<new public="1" set="method" line="1503"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.dynamics.ZPP_Contact" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/dynamics/Contact.hx" module="zpp_nape.dynamics.Contact">
		<internal public="1" line="176" static="1"><x path="Bool"/></internal>
		<zpp_pool public="1" line="244" static="1"><c path="zpp_nape.dynamics.ZPP_Contact"/></zpp_pool>
		<at public="1" set="method" line="611"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
</f></at>
		<iterator_at public="1" set="method" line="598"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
</f></iterator_at>
		<back public="1" set="method" line="589"><f a=""><c path="zpp_nape.dynamics.ZPP_Contact"/></f></back>
		<front public="1" get="inline" set="null" line="586"><f a=""><c path="zpp_nape.dynamics.ZPP_Contact"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="556"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="551"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="548"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="543"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="528"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="522"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="517"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="513"><f a="pre:n">
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
	<x path="Int"/>
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="481"><f a="pre">
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
</f></inlined_erase>
		<erase public="1" set="method" line="476"><f a="pre">
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="453"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="440"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="415"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="404"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="391"><f a=""><c path="zpp_nape.dynamics.ZPP_Contact"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="386"><f a=""><c path="zpp_nape.dynamics.ZPP_Contact"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="367"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="362"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="337"><f a="cur:o">
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
</f></inlined_insert>
		<insert public="1" set="method" line="332"><f a="cur:o">
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
</f></insert>
		<addAll public="1" set="method" line="314"><f a="x">
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="295"><f a="o">
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
</f></inlined_add>
		<add public="1" set="method" line="290"><f a="o">
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="285"><f a="i">
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<_inuse public="1"><x path="Bool"/></_inuse>
		<begin public="1" get="inline" set="null" line="276"><f a=""><c path="zpp_nape.dynamics.ZPP_Contact"/></f></begin>
		<elem public="1" get="inline" set="null" line="271"><f a=""><c path="zpp_nape.dynamics.ZPP_Contact"/></f></elem>
		<next public="1"><c path="zpp_nape.dynamics.ZPP_Contact"/></next>
		<alloc public="1" get="inline" set="null" line="243"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="238"><f a=""><x path="Void"/></f></free>
		<elasticity public="1"><x path="Float"/></elasticity>
		<dist public="1"><x path="Float"/></dist>
		<fresh public="1"><x path="Bool"/></fresh>
		<hash public="1"><x path="Int"/></hash>
		<stamp public="1"><x path="Int"/></stamp>
		<posOnly public="1"><x path="Bool"/></posOnly>
		<active public="1"><x path="Bool"/></active>
		<inner public="1"><c path="zpp_nape.dynamics.ZPP_IContact"/></inner>
		<arbiter public="1"><c path="zpp_nape.dynamics.ZPP_Arbiter"/></arbiter>
		<inactiveme public="1" set="method" line="221"><f a=""><x path="Bool"/></f></inactiveme>
		<getposition public="1" set="method" line="214"><f a=""><x path="Void"/></f></getposition>
		<wrap_position public="1"><c path="nape.geom.Vec2"/></wrap_position>
		<position_validate set="method" line="188"><f a=""><x path="Void"/></f></position_validate>
		<py public="1"><x path="Float"/></py>
		<px public="1"><x path="Float"/></px>
		<wrapper public="1" set="method" line="177"><f a=""><c path="nape.dynamics.Contact"/></f></wrapper>
		<outer public="1"><c path="nape.dynamics.Contact"/></outer>
		<new public="1" set="method" line="233"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.dynamics.ZPP_IContact" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/dynamics/Contact.hx" module="zpp_nape.dynamics.Contact">
		<at public="1" set="method" line="984"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
</f></at>
		<iterator_at public="1" set="method" line="971"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
</f></iterator_at>
		<back public="1" set="method" line="962"><f a=""><c path="zpp_nape.dynamics.ZPP_IContact"/></f></back>
		<front public="1" get="inline" set="null" line="959"><f a=""><c path="zpp_nape.dynamics.ZPP_IContact"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="929"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="924"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="921"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="916"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="901"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="895"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="890"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="886"><f a="pre:n">
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
	<x path="Int"/>
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="854"><f a="pre">
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
</f></inlined_erase>
		<erase public="1" set="method" line="849"><f a="pre">
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="826"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="813"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="788"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="777"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="764"><f a=""><c path="zpp_nape.dynamics.ZPP_IContact"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="759"><f a=""><c path="zpp_nape.dynamics.ZPP_IContact"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="740"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="735"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="710"><f a="cur:o">
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
</f></inlined_insert>
		<insert public="1" set="method" line="705"><f a="cur:o">
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
</f></insert>
		<addAll public="1" set="method" line="687"><f a="x">
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="668"><f a="o">
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
</f></inlined_add>
		<add public="1" set="method" line="663"><f a="o">
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="658"><f a="i">
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<_inuse public="1"><x path="Bool"/></_inuse>
		<begin public="1" get="inline" set="null" line="649"><f a=""><c path="zpp_nape.dynamics.ZPP_IContact"/></f></begin>
		<elem public="1" get="inline" set="null" line="644"><f a=""><c path="zpp_nape.dynamics.ZPP_IContact"/></f></elem>
		<next public="1"><c path="zpp_nape.dynamics.ZPP_IContact"/></next>
		<lr2y public="1"><x path="Float"/></lr2y>
		<lr2x public="1"><x path="Float"/></lr2x>
		<lr1y public="1"><x path="Float"/></lr1y>
		<lr1x public="1"><x path="Float"/></lr1x>
		<jtAcc public="1"><x path="Float"/></jtAcc>
		<jnAcc public="1"><x path="Float"/></jnAcc>
		<friction public="1"><x path="Float"/></friction>
		<bounce public="1"><x path="Float"/></bounce>
		<tMass public="1"><x path="Float"/></tMass>
		<nMass public="1"><x path="Float"/></nMass>
		<r2y public="1"><x path="Float"/></r2y>
		<r2x public="1"><x path="Float"/></r2x>
		<r1y public="1"><x path="Float"/></r1y>
		<r1x public="1"><x path="Float"/></r1x>
		<new public="1" set="method" line="640"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.dynamics.ZPP_InteractionFilter" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/dynamics/InteractionFilter.hx" module="zpp_nape.dynamics.InteractionFilter">
		<zpp_pool public="1" line="176" static="1"><c path="zpp_nape.dynamics.ZPP_InteractionFilter"/></zpp_pool>
		<invalidate public="1" set="method" line="304"><f a=""><x path="Void"/></f></invalidate>
		<shouldFlow public="1" get="inline" set="null" line="301"><f a="x">
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<x path="Bool"/>
</f></shouldFlow>
		<fluidMask public="1"><x path="Int"/></fluidMask>
		<fluidGroup public="1"><x path="Int"/></fluidGroup>
		<shouldSense public="1" get="inline" set="null" line="294"><f a="x">
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<x path="Bool"/>
</f></shouldSense>
		<sensorMask public="1"><x path="Int"/></sensorMask>
		<sensorGroup public="1"><x path="Int"/></sensorGroup>
		<shouldCollide public="1" get="inline" set="null" line="287"><f a="x">
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<x path="Bool"/>
</f></shouldCollide>
		<collisionMask public="1"><x path="Int"/></collisionMask>
		<collisionGroup public="1"><x path="Int"/></collisionGroup>
		<copy public="1" set="method" line="256"><f a=""><c path="zpp_nape.dynamics.ZPP_InteractionFilter"/></f></copy>
		<remShape public="1" get="inline" set="null" line="248"><f a="shape">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></remShape>
		<addShape public="1" get="inline" set="null" line="243"><f a="shape">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></addShape>
		<feature_cons public="1" get="inline" set="null" line="238"><f a=""><x path="Void"/></f></feature_cons>
		<wrap_shapes public="1"><c path="nape.shape.ShapeList"/></wrap_shapes>
		<shapes public="1"><c path="zpp_nape.util.ZNPList_ZPP_Shape"/></shapes>
		<alloc public="1" get="inline" set="null" line="233"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="228"><f a=""><x path="Void"/></f></free>
		<wrapper public="1" set="method" line="202"><f a=""><c path="nape.dynamics.InteractionFilter"/></f></wrapper>
		<outer public="1"><c path="nape.dynamics.InteractionFilter"/></outer>
		<userData public="1"><d><d/></d></userData>
		<next public="1"><c path="zpp_nape.dynamics.ZPP_InteractionFilter"/></next>
		<new public="1" set="method" line="251"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.dynamics.ZPP_InteractionGroup" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/dynamics/InteractionGroup.hx" module="zpp_nape.dynamics.InteractionGroup">
		<SHAPE public="1" line="220" static="1"><x path="Int"/></SHAPE>
		<BODY public="1" line="221" static="1"><x path="Int"/></BODY>
		<remInteractor public="1" get="inline" set="null" line="246"><f a="intx:?flag">
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<x path="Int"/>
	<x path="Void"/>
</f></remInteractor>
		<addInteractor public="1" get="inline" set="null" line="241"><f a="intx">
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<x path="Void"/>
</f></addInteractor>
		<remGroup public="1" get="inline" set="null" line="235"><f a="group">
	<c path="zpp_nape.dynamics.ZPP_InteractionGroup"/>
	<x path="Void"/>
</f></remGroup>
		<addGroup public="1" get="inline" set="null" line="229"><f a="group">
	<c path="zpp_nape.dynamics.ZPP_InteractionGroup"/>
	<x path="Void"/>
</f></addGroup>
		<invalidate public="1" set="method" line="197"><f a="?force">
	<x path="Bool"/>
	<x path="Void"/>
</f></invalidate>
		<depth public="1"><x path="Int"/></depth>
		<wrap_interactors public="1"><c path="nape.phys.InteractorList"/></wrap_interactors>
		<interactors public="1"><c path="zpp_nape.util.ZNPList_ZPP_Interactor"/></interactors>
		<wrap_groups public="1"><c path="nape.dynamics.InteractionGroupList"/></wrap_groups>
		<groups public="1"><c path="zpp_nape.util.ZNPList_ZPP_InteractionGroup"/></groups>
		<setGroup public="1" set="method" line="178"><f a="group">
	<c path="zpp_nape.dynamics.ZPP_InteractionGroup"/>
	<x path="Void"/>
</f></setGroup>
		<group public="1"><c path="zpp_nape.dynamics.ZPP_InteractionGroup"/></group>
		<ignore public="1"><x path="Bool"/></ignore>
		<outer public="1"><c path="nape.dynamics.InteractionGroup"/></outer>
		<new public="1" set="method" line="222"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.dynamics.ZPP_SpaceArbiterList" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/dynamics/SpaceArbiterList.hx" module="zpp_nape.dynamics.SpaceArbiterList">
		<extends path="nape.dynamics.ArbiterList"/>
		<at public="1" set="method" line="325" override="1"><f a="index">
	<x path="Int"/>
	<c path="nape.dynamics.Arbiter"/>
</f></at>
		<clear public="1" set="method" line="320" override="1"><f a=""><x path="Void"/></f></clear>
		<remove public="1" set="method" line="314" override="1"><f a="obj">
	<c path="nape.dynamics.Arbiter"/>
	<x path="Bool"/>
</f></remove>
		<shift public="1" set="method" line="308" override="1"><f a=""><c path="nape.dynamics.Arbiter"/></f></shift>
		<unshift public="1" set="method" line="302" override="1"><f a="obj">
	<c path="nape.dynamics.Arbiter"/>
	<x path="Bool"/>
</f></unshift>
		<pop public="1" set="method" line="296" override="1"><f a=""><c path="nape.dynamics.Arbiter"/></f></pop>
		<push public="1" set="method" line="290" override="1"><f a="obj">
	<c path="nape.dynamics.Arbiter"/>
	<x path="Bool"/>
</f></push>
		<zpp_vm public="1" set="method" line="261" override="1"><f a=""><x path="Void"/></f></zpp_vm>
		<at_index_3 public="1"><x path="Int"/></at_index_3>
		<at_index_2 public="1"><x path="Int"/></at_index_2>
		<at_index_1 public="1"><x path="Int"/></at_index_1>
		<at_index_0 public="1"><x path="Int"/></at_index_0>
		<ite_3 public="1"><c path="zpp_nape.util.ZNPNode_ZPP_SensorArbiter"/></ite_3>
		<ite_2 public="1"><c path="zpp_nape.util.ZNPNode_ZPP_FluidArbiter"/></ite_2>
		<ite_1 public="1"><c path="zpp_nape.util.ZNPNode_ZPP_ColArbiter"/></ite_1>
		<ite_0 public="1"><c path="zpp_nape.util.ZNPNode_ZPP_ColArbiter"/></ite_0>
		<lengths public="1"><c path="Array"><x path="Int"/></c></lengths>
		<zpp_gl public="1" set="method" line="189" override="1"><f a=""><x path="Int"/></f></zpp_gl>
		<zip_length public="1"><x path="Bool"/></zip_length>
		<_length public="1"><x path="Int"/></_length>
		<space public="1"><c path="zpp_nape.space.ZPP_Space"/></space>
		<new public="1" set="method" line="178"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_AABB" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/geom/AABB.hx" module="zpp_nape.geom.AABB">
		<zpp_pool public="1" line="218" static="1"><c path="zpp_nape.geom.ZPP_AABB"/></zpp_pool>
		<get public="1" get="inline" set="null" line="258" static="1"><f a="minx:miny:maxx:maxy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="zpp_nape.geom.ZPP_AABB"/>
</f></get>
		<toString public="1" set="method" line="526"><f a=""><c path="String"/></f></toString>
		<setExpandPoint public="1" get="inline" set="null" line="520"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setExpandPoint>
		<setExpand public="1" get="inline" set="null" line="512"><f a="a:fatten">
	<c path="zpp_nape.geom.ZPP_AABB"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setExpand>
		<setCombine public="1" get="inline" set="null" line="504"><f a="a:b">
	<c path="zpp_nape.geom.ZPP_AABB"/>
	<c path="zpp_nape.geom.ZPP_AABB"/>
	<x path="Void"/>
</f></setCombine>
		<containsPoint public="1" get="inline" set="null" line="499"><f a="v">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Bool"/>
</f></containsPoint>
		<contains public="1" get="inline" set="null" line="494"><f a="x">
	<c path="zpp_nape.geom.ZPP_AABB"/>
	<x path="Bool"/>
</f></contains>
		<combine public="1" get="inline" set="null" line="486"><f a="x">
	<c path="zpp_nape.geom.ZPP_AABB"/>
	<x path="Void"/>
</f></combine>
		<intersect public="1" get="inline" set="null" line="481"><f a="x">
	<c path="zpp_nape.geom.ZPP_AABB"/>
	<x path="Bool"/>
</f></intersect>
		<intersectY public="1" get="inline" set="null" line="476"><f a="x">
	<c path="zpp_nape.geom.ZPP_AABB"/>
	<x path="Bool"/>
</f></intersectY>
		<intersectX public="1" get="inline" set="null" line="471"><f a="x">
	<c path="zpp_nape.geom.ZPP_AABB"/>
	<x path="Bool"/>
</f></intersectX>
		<mod_max public="1" set="method" line="444"><f a="max">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></mod_max>
		<dom_max public="1" set="method" line="421"><f a=""><x path="Void"/></f></dom_max>
		<getmax public="1" set="method" line="407"><f a=""><c path="nape.geom.Vec2"/></f></getmax>
		<wrap_max public="1"><t path="Null"><c path="nape.geom.Vec2"/></t></wrap_max>
		<maxy public="1"><x path="Float"/></maxy>
		<maxx public="1"><x path="Float"/></maxx>
		<mod_min public="1" set="method" line="379"><f a="min">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></mod_min>
		<dom_min public="1" set="method" line="356"><f a=""><x path="Void"/></f></dom_min>
		<getmin public="1" set="method" line="342"><f a=""><c path="nape.geom.Vec2"/></f></getmin>
		<wrap_min public="1"><t path="Null"><c path="nape.geom.Vec2"/></t></wrap_min>
		<miny public="1"><x path="Float"/></miny>
		<minx public="1"><x path="Float"/></minx>
		<perimeter public="1" get="inline" set="null" line="336"><f a=""><x path="Float"/></f></perimeter>
		<height public="1" get="inline" set="null" line="331"><f a=""><x path="Float"/></f></height>
		<width public="1" get="inline" set="null" line="326"><f a=""><x path="Float"/></f></width>
		<copy public="1" get="inline" set="null" line="321"><f a=""><c path="zpp_nape.geom.ZPP_AABB"/></f></copy>
		<free public="1" get="inline" set="null" line="247"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="244"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.geom.ZPP_AABB"/></next>
		<wrapper public="1" set="method" line="193"><f a=""><c path="nape.geom.AABB"/></f></wrapper>
		<outer public="1"><t path="Null"><c path="nape.geom.AABB"/></t></outer>
		<invalidate public="1" get="inline" set="null" line="187"><f a=""><x path="Void"/></f></invalidate>
		<validate public="1" get="inline" set="null" line="180"><f a=""><x path="Void"/></f></validate>
		<_immutable public="1"><x path="Bool"/></_immutable>
		<_validate public="1"><t path="Null"><f a=""><x path="Void"/></f></t></_validate>
		<_invalidate public="1"><t path="Null"><f a="">
	<c path="zpp_nape.geom.ZPP_AABB"/>
	<x path="Void"/>
</f></t></_invalidate>
		<new public="1" set="method" line="256"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_Vec2" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="9335"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
</f></at>
		<iterator_at public="1" set="method" line="9322"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Vec2"/>
</f></iterator_at>
		<back public="1" set="method" line="9313"><f a=""><c path="zpp_nape.geom.ZPP_Vec2"/></f></back>
		<front public="1" get="inline" set="null" line="9310"><f a=""><c path="zpp_nape.geom.ZPP_Vec2"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="9280"><f a="obj">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="9275"><f a="obj">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="9272"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="9267"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="9252"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="9246"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="9241"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="9237"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_Vec2"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Vec2"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="9191"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_Vec2"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Vec2"/>
</f></inlined_erase>
		<erase public="1" set="method" line="9186"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_Vec2"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Vec2"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="9163"><f a="obj">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="9150"><f a="obj">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="9125"><f a="obj">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="9114"><f a="obj">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="9101"><f a=""><c path="zpp_nape.geom.ZPP_Vec2"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="9096"><f a=""><c path="zpp_nape.geom.ZPP_Vec2"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="9063"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="9058"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="9015"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_Vec2"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Vec2"/>
</f></inlined_insert>
		<insert public="1" set="method" line="9010"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_Vec2"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Vec2"/>
</f></insert>
		<addAll public="1" set="method" line="8992"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_Vec2"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="8955"><f a="o">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
</f></inlined_add>
		<add public="1" set="method" line="8950"><f a="o">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="8945"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_Vec2"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="8937"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_Vec2"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Vec2"/></head>
		<new public="1" set="method" line="8934"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_Collide" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/geom/Collide.hx" module="zpp_nape.geom.Collide">
		<circleContains public="1" set="method" line="175" static="1"><f a="c:p">
	<c path="zpp_nape.shape.ZPP_Circle"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Bool"/>
</f></circleContains>
		<polyContains public="1" set="method" line="184" static="1"><f a="s:p">
	<c path="zpp_nape.shape.ZPP_Polygon"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Bool"/>
</f></polyContains>
		<shapeContains public="1" set="method" line="210" static="1"><f a="s:p">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Bool"/>
</f></shapeContains>
		<bodyContains public="1" set="method" line="214" static="1"><f a="b:p">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Bool"/>
</f></bodyContains>
		<containTest public="1" set="method" line="234" static="1"><f a="s1:s2">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
</f></containTest>
		<contactCollide public="1" set="method" line="356" static="1"><f a="s1:s2:arb:rev">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.dynamics.ZPP_ColArbiter"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></contactCollide>
		<testCollide_safe public="1" set="method" line="1034" static="1"><f a="s1:s2">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
</f></testCollide_safe>
		<testCollide public="1" set="method" line="1042" static="1"><f a="s1:s2">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
</f></testCollide>
		<flowCollide public="1" set="method" line="1171" static="1"><f a="s1:s2:arb">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.dynamics.ZPP_FluidArbiter"/>
	<x path="Bool"/>
</f></flowCollide>
		<flowpoly public="1" line="2910" static="1"><c path="zpp_nape.util.ZNPList_ZPP_Vec2"/></flowpoly>
		<flowsegs public="1" line="2911" static="1"><c path="zpp_nape.util.ZNPList_ZPP_Vec2"/></flowsegs>
	</class>
	<class path="zpp_nape.geom.ZPP_Convex" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/geom/Convex.hx" module="zpp_nape.geom.Convex">
		<isinner set="method" line="175" static="1"><f a="a:b:c">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Bool"/>
</f></isinner>
		<optimise public="1" set="method" line="190" static="1"><f a="P">
	<c path="zpp_nape.geom.ZPP_PartitionedPoly"/>
	<x path="Void"/>
</f></optimise>
	</class>
	<class path="zpp_nape.geom.ZPP_ConvexRayResult" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/geom/ConvexRayResult.hx" module="zpp_nape.geom.ConvexRayResult">
		<convexPool line="177" static="1"><c path="zpp_nape.geom.ZPP_ConvexRayResult"/></convexPool>
		<rayPool line="180" static="1"><c path="zpp_nape.geom.ZPP_ConvexRayResult"/></rayPool>
		<internal public="1" line="186" static="1"><x path="Bool"/></internal>
		<getRay public="1" set="method" line="187" static="1"><f a="normal:time:inner:shape">
	<c path="nape.geom.Vec2"/>
	<x path="Float"/>
	<x path="Bool"/>
	<c path="nape.shape.Shape"/>
	<c path="nape.geom.RayResult"/>
</f></getRay>
		<getConvex public="1" set="method" line="209" static="1"><f a="normal:position:toiDistance:shape">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
	<x path="Float"/>
	<c path="nape.shape.Shape"/>
	<c path="nape.geom.ConvexResult"/>
</f></getConvex>
		<free public="1" set="method" line="239"><f a=""><x path="Void"/></f></free>
		<disposed public="1" get="inline" set="null" line="234"><f a=""><x path="Void"/></f></disposed>
		<toiDistance public="1"><x path="Float"/></toiDistance>
		<next public="1"><c path="zpp_nape.geom.ZPP_ConvexRayResult"/></next>
		<inner public="1"><x path="Bool"/></inner>
		<ray public="1"><c path="nape.geom.RayResult"/></ray>
		<position public="1"><c path="nape.geom.Vec2"/></position>
		<convex public="1"><c path="nape.geom.ConvexResult"/></convex>
		<shape public="1"><c path="nape.shape.Shape"/></shape>
		<normal public="1"><c path="nape.geom.Vec2"/></normal>
		<new public="1" set="method" line="185"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_CutVert" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/geom/Cutter.hx" module="zpp_nape.geom.Cutter">
		<zpp_pool public="1" line="175" static="1"><c path="zpp_nape.geom.ZPP_CutVert"/></zpp_pool>
		<path public="1" get="inline" set="null" line="220" static="1"><f a="poly">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<c path="zpp_nape.geom.ZPP_CutVert"/>
</f></path>
		<free public="1" get="inline" set="null" line="215"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="212"><f a=""><x path="Void"/></f></alloc>
		<used public="1"><x path="Bool"/></used>
		<rank public="1"><x path="Int"/></rank>
		<parent public="1"><c path="zpp_nape.geom.ZPP_CutVert"/></parent>
		<positive public="1"><x path="Bool"/></positive>
		<value public="1"><x path="Float"/></value>
		<vert public="1"><c path="zpp_nape.geom.ZPP_GeomVert"/></vert>
		<posy public="1"><x path="Float"/></posy>
		<posx public="1"><x path="Float"/></posx>
		<next public="1"><c path="zpp_nape.geom.ZPP_CutVert"/></next>
		<prev public="1"><c path="zpp_nape.geom.ZPP_CutVert"/></prev>
		<new public="1" set="method" line="209"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_CutInt" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/geom/Cutter.hx" module="zpp_nape.geom.Cutter">
		<zpp_pool public="1" line="249" static="1"><c path="zpp_nape.geom.ZPP_CutInt"/></zpp_pool>
		<get public="1" get="inline" set="null" line="291" static="1"><f a="time:?end:?start:?path0:?path1:?virtualint:?vertex">
	<x path="Float"/>
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<c path="zpp_nape.geom.ZPP_CutVert"/>
	<c path="zpp_nape.geom.ZPP_CutVert"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="zpp_nape.geom.ZPP_CutInt"/>
</f></get>
		<free public="1" get="inline" set="null" line="286"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="283"><f a=""><x path="Void"/></f></alloc>
		<path1 public="1"><c path="zpp_nape.geom.ZPP_CutVert"/></path1>
		<start public="1"><c path="zpp_nape.geom.ZPP_GeomVert"/></start>
		<end public="1"><c path="zpp_nape.geom.ZPP_GeomVert"/></end>
		<path0 public="1"><c path="zpp_nape.geom.ZPP_CutVert"/></path0>
		<vertex public="1"><x path="Bool"/></vertex>
		<virtualint public="1"><x path="Bool"/></virtualint>
		<time public="1"><x path="Float"/></time>
		<next public="1"><c path="zpp_nape.geom.ZPP_CutInt"/></next>
		<new public="1" set="method" line="280"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_Cutter" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/geom/Cutter.hx" module="zpp_nape.geom.Cutter">
		<ints line="322" static="1"><c path="zpp_nape.util.ZNPList_ZPP_CutInt"/></ints>
		<paths line="323" static="1"><c path="zpp_nape.util.ZNPList_ZPP_CutVert"/></paths>
		<run public="1" set="method" line="324" static="1"><f a="P:_start:_end:bstart:bend:output">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="nape.geom.GeomPolyList"/>
	<c path="nape.geom.GeomPolyList"/>
</f></run>
	</class>
	<class path="zpp_nape.geom.ZPP_Geom" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/geom/Geom.hx" module="zpp_nape.geom.Geom"><validateShape public="1" set="method" line="175" static="1"><f a="s">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></validateShape></class>
	<class path="zpp_nape.geom.ZPP_GeomVert" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/geom/GeomPoly.hx" module="zpp_nape.geom.GeomPoly">
		<zpp_pool public="1" line="181" static="1"><c path="zpp_nape.geom.ZPP_GeomVert"/></zpp_pool>
		<get public="1" get="inline" set="null" line="275" static="1"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
</f></get>
		<getwrap public="1" get="inline" set="null" line="252"><f a=""><x path="Void"/></f></getwrap>
		<modwrap public="1" get="inline" set="null" line="229"><f a="n">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></modwrap>
		<wrapper public="1" get="inline" set="null" line="219"><f a=""><c path="nape.geom.Vec2"/></f></wrapper>
		<alloc public="1" get="inline" set="null" line="215"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="206"><f a=""><x path="Void"/></f></free>
		<forced public="1"><x path="Bool"/></forced>
		<wrap public="1"><t path="Null"><c path="nape.geom.Vec2"/></t></wrap>
		<next public="1"><c path="zpp_nape.geom.ZPP_GeomVert"/></next>
		<prev public="1"><c path="zpp_nape.geom.ZPP_GeomVert"/></prev>
		<y public="1"><x path="Float"/></y>
		<x public="1"><x path="Float"/></x>
		<new public="1" set="method" line="316"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_GeomPoly" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/geom/GeomPoly.hx" module="zpp_nape.geom.GeomPoly">
		<vertices public="1"><t path="Null"><c path="zpp_nape.geom.ZPP_GeomVert"/></t></vertices>
		<outer public="1"><c path="nape.geom.GeomPoly"/></outer>
		<new public="1" set="method" line="322"><f a="outer">
	<c path="nape.geom.GeomPoly"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_GeomVertexIterator" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/geom/GeomPoly.hx" module="zpp_nape.geom.GeomPoly">
		<zpp_pool public="1" line="334" static="1"><c path="zpp_nape.geom.ZPP_GeomVertexIterator"/></zpp_pool>
		<internal public="1" line="368" static="1"><x path="Bool"/></internal>
		<get public="1" set="method" line="379" static="1"><f a="poly:forward">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<x path="Bool"/>
	<c path="nape.geom.GeomVertexIterator"/>
</f></get>
		<alloc public="1" get="inline" set="null" line="366"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="360"><f a=""><x path="Void"/></f></free>
		<next public="1"><c path="zpp_nape.geom.ZPP_GeomVertexIterator"/></next>
		<outer public="1"><c path="nape.geom.GeomVertexIterator"/></outer>
		<forward public="1"><x path="Bool"/></forward>
		<first public="1"><x path="Bool"/></first>
		<start public="1"><c path="zpp_nape.geom.ZPP_GeomVert"/></start>
		<ptr public="1"><c path="zpp_nape.geom.ZPP_GeomVert"/></ptr>
		<new set="method" line="370"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_MarchSpan" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/geom/MarchingSquares.hx" module="zpp_nape.geom.MarchingSquares">
		<zpp_pool public="1" line="179" static="1"><c path="zpp_nape.geom.ZPP_MarchSpan"/></zpp_pool>
		<alloc public="1" get="inline" set="null" line="210"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="205"><f a=""><x path="Void"/></f></free>
		<next public="1"><c path="zpp_nape.geom.ZPP_MarchSpan"/></next>
		<out public="1"><x path="Bool"/></out>
		<rank public="1"><x path="Int"/></rank>
		<parent public="1"><c path="zpp_nape.geom.ZPP_MarchSpan"/></parent>
		<new public="1" set="method" line="214"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_MarchPair" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/geom/MarchingSquares.hx" module="zpp_nape.geom.MarchingSquares">
		<zpp_pool public="1" line="234" static="1"><c path="zpp_nape.geom.ZPP_MarchPair"/></zpp_pool>
		<alloc public="1" get="inline" set="null" line="266"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="260"><f a=""><x path="Void"/></f></free>
		<next public="1"><c path="zpp_nape.geom.ZPP_MarchPair"/></next>
		<spanr public="1"><c path="zpp_nape.geom.ZPP_MarchSpan"/></spanr>
		<span2 public="1"><c path="zpp_nape.geom.ZPP_MarchSpan"/></span2>
		<span1 public="1"><c path="zpp_nape.geom.ZPP_MarchSpan"/></span1>
		<pd public="1"><c path="zpp_nape.geom.ZPP_GeomVert"/></pd>
		<okeyr public="1"><x path="Int"/></okeyr>
		<keyr public="1"><x path="Int"/></keyr>
		<pr public="1"><c path="zpp_nape.geom.ZPP_GeomVert"/></pr>
		<okey2 public="1"><x path="Int"/></okey2>
		<key2 public="1"><x path="Int"/></key2>
		<p2 public="1"><c path="zpp_nape.geom.ZPP_GeomVert"/></p2>
		<okey1 public="1"><x path="Int"/></okey1>
		<key1 public="1"><x path="Int"/></key1>
		<p1 public="1"><c path="zpp_nape.geom.ZPP_GeomVert"/></p1>
		<new public="1" set="method" line="267"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_MarchingSquares" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/geom/MarchingSquares.hx" module="zpp_nape.geom.MarchingSquares">
		<me line="271" static="1"><c path="zpp_nape.geom.ZPP_MarchingSquares"/></me>
		<isos static="1"><c path="zpp_nape.util.ZNPArray2_Float"/></isos>
		<ints static="1"><c path="zpp_nape.util.ZNPArray2_ZPP_GeomVert"/></ints>
		<map static="1"><c path="zpp_nape.util.ZNPArray2_ZPP_MarchPair"/></map>
		<run public="1" set="method" line="276" static="1"><f a="iso:bx0:by0:bx1:by1:cell:quality:combine:ret">
	<t path="nape.geom.IsoFunctionDef"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="nape.geom.Vec2"/>
	<x path="Int"/>
	<x path="Bool"/>
	<c path="nape.geom.GeomPolyList"/>
	<x path="Void"/>
</f></run>
		<look_march public="1" line="953" static="1"><c path="Array"><x path="Int"/></c></look_march>
		<ISO get="inline" set="null" line="1928" static="1"><f a="iso:x:y">
	<t path="nape.geom.IsoFunctionDef"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></ISO>
		<ylerp set="method" line="1910"><f a="y0:y1:x:v0:v1:iso:quality">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<t path="nape.geom.IsoFunctionDef"/>
	<x path="Int"/>
	<x path="Float"/>
</f></ylerp>
		<xlerp set="method" line="1893"><f a="x0:x1:y:v0:v1:iso:quality">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<t path="nape.geom.IsoFunctionDef"/>
	<x path="Int"/>
	<x path="Float"/>
</f></xlerp>
		<lerp get="inline" set="null" line="1882"><f a="x0:x1:v0:v1">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></lerp>
		<marchSquare set="method" line="954"><f a="iso:isos:ints:x0:y0:x1:y1:xn:yn:fstx:fsty:sndx:sndy:quality">
	<t path="nape.geom.IsoFunctionDef"/>
	<c path="zpp_nape.util.ZNPArray2_Float"/>
	<c path="zpp_nape.util.ZNPArray2_ZPP_GeomVert"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_MarchPair"/>
</f></marchSquare>
		<comb get="inline" set="null" line="946"><f a="flag">
	<x path="Int"/>
	<x path="Bool"/>
</f></comb>
		<combDown get="inline" set="null" line="940"><f a="key">
	<x path="Int"/>
	<x path="Bool"/>
</f></combDown>
		<combUp get="inline" set="null" line="934"><f a="key">
	<x path="Int"/>
	<x path="Bool"/>
</f></combUp>
		<combRight get="inline" set="null" line="928"><f a="key">
	<x path="Int"/>
	<x path="Bool"/>
</f></combRight>
		<combLeft get="inline" set="null" line="922"><f a="key">
	<x path="Int"/>
	<x path="Bool"/>
</f></combLeft>
		<combUD_virtual set="method" line="911"><f a="a:b">
	<c path="zpp_nape.geom.ZPP_MarchPair"/>
	<c path="zpp_nape.geom.ZPP_MarchPair"/>
	<x path="Void"/>
</f></combUD_virtual>
		<combUD set="method" line="864"><f a="a:b">
	<c path="zpp_nape.geom.ZPP_MarchPair"/>
	<c path="zpp_nape.geom.ZPP_MarchPair"/>
	<x path="Void"/>
</f></combUD>
		<combLR set="method" line="771"><f a="a:b">
	<c path="zpp_nape.geom.ZPP_MarchPair"/>
	<c path="zpp_nape.geom.ZPP_MarchPair"/>
	<x path="Void"/>
</f></combLR>
		<linkup get="inline" set="null" line="768"><f a="poly:key">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
</f></linkup>
		<linkdown get="inline" set="null" line="763"><f a="poly:key">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
</f></linkdown>
		<linkleft get="inline" set="null" line="758"><f a="poly:key">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
</f></linkleft>
		<linkright get="inline" set="null" line="750"><f a="poly:key">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
</f></linkright>
		<output set="method" line="662"><f a="ret:poly">
	<c path="nape.geom.GeomPolyList"/>
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<x path="Void"/>
</f></output>
		<new set="method" line="272"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_Mat23" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/geom/Mat23.hx" module="zpp_nape.geom.Mat23">
		<zpp_pool public="1" line="248" static="1"><c path="zpp_nape.geom.ZPP_Mat23"/></zpp_pool>
		<get public="1" set="method" line="279" static="1"><f a=""><c path="zpp_nape.geom.ZPP_Mat23"/></f></get>
		<identity public="1" set="method" line="300" static="1"><f a=""><c path="zpp_nape.geom.ZPP_Mat23"/></f></identity>
		<alloc public="1" get="inline" set="null" line="277"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="274"><f a=""><x path="Void"/></f></free>
		<next public="1"><c path="zpp_nape.geom.ZPP_Mat23"/></next>
		<setas public="1" set="method" line="219"><f a="a:b:c:d:tx:ty">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setas>
		<set public="1" get="inline" set="null" line="216"><f a="m">
	<c path="zpp_nape.geom.ZPP_Mat23"/>
	<x path="Void"/>
</f></set>
		<invalidate public="1" get="inline" set="null" line="209"><f a=""><x path="Void"/></f></invalidate>
		<_invalidate public="1"><t path="Null"><f a=""><x path="Void"/></f></t></_invalidate>
		<ty public="1"><x path="Float"/></ty>
		<tx public="1"><x path="Float"/></tx>
		<d public="1"><x path="Float"/></d>
		<c public="1"><x path="Float"/></c>
		<b public="1"><x path="Float"/></b>
		<a public="1"><x path="Float"/></a>
		<wrapper public="1" set="method" line="176"><f a=""><c path="nape.geom.Mat23"/></f></wrapper>
		<outer public="1"><t path="Null"><c path="nape.geom.Mat23"/></t></outer>
		<new public="1" set="method" line="278"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_MatMN" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/geom/MatMN.hx" module="zpp_nape.geom.MatMN">
		<x public="1"><t path="nape.TArray"><x path="Float"/></t></x>
		<n public="1"><x path="Int"/></n>
		<m public="1"><x path="Int"/></m>
		<outer public="1"><c path="nape.geom.MatMN"/></outer>
		<new public="1" set="method" line="179"><f a="m:n">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_Monotone" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/geom/Monotone.hx" module="zpp_nape.geom.Monotone">
		<bisector set="method" line="175" static="1"><f a="b">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
</f></bisector>
		<below set="method" line="222" static="1"><f a="p:q">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Bool"/>
</f></below>
		<above set="method" line="296" static="1"><f a="p:q">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Bool"/>
</f></above>
		<left_vertex set="method" line="299" static="1"><f a="p">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Bool"/>
</f></left_vertex>
		<isMonotone public="1" set="method" line="303" static="1"><f a="P">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<x path="Bool"/>
</f></isMonotone>
		<sharedPPoly public="1" static="1"><c path="zpp_nape.geom.ZPP_PartitionedPoly"/></sharedPPoly>
		<getShared public="1" get="inline" set="null" line="378" static="1"><f a=""><c path="zpp_nape.geom.ZPP_PartitionedPoly"/></f></getShared>
		<queue line="382" static="1"><c path="zpp_nape.util.ZNPList_ZPP_PartitionVertex"/></queue>
		<edges line="383" static="1"><c path="zpp_nape.util.ZPP_Set_ZPP_PartitionVertex"/></edges>
		<decompose public="1" set="method" line="384" static="1"><f a="P:?poly">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<c path="zpp_nape.geom.ZPP_PartitionedPoly"/>
	<c path="zpp_nape.geom.ZPP_PartitionedPoly"/>
</f></decompose>
	</class>
	<class path="zpp_nape.geom.ZPP_PartitionVertex" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/geom/PartitionedPoly.hx" module="zpp_nape.geom.PartitionedPoly">
		<nextId line="176" static="1"><x path="Int"/></nextId>
		<zpp_pool public="1" line="185" static="1"><c path="zpp_nape.geom.ZPP_PartitionVertex"/></zpp_pool>
		<get public="1" get="inline" set="null" line="230" static="1"><f a="x">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
</f></get>
		<rightdistance set="method" line="493" static="1"><f a="edge:vert">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Float"/>
</f></rightdistance>
		<vert_lt public="1" set="method" line="509" static="1"><f a="edge:vert">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Bool"/>
</f></vert_lt>
		<edge_swap public="1" set="method" line="518" static="1"><f a="p:q">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Void"/>
</f></edge_swap>
		<edge_lt public="1" set="method" line="523" static="1"><f a="p:q">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Bool"/>
</f></edge_lt>
		<node public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_PartitionVertex"/></node>
		<sort public="1" set="method" line="314"><f a=""><x path="Void"/></f></sort>
		<copy public="1" get="inline" set="null" line="272"><f a=""><c path="zpp_nape.geom.ZPP_PartitionVertex"/></f></copy>
		<free public="1" get="inline" set="null" line="218"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="216"><f a=""><x path="Void"/></f></alloc>
		<prev public="1"><c path="zpp_nape.geom.ZPP_PartitionVertex"/></prev>
		<next public="1"><c path="zpp_nape.geom.ZPP_PartitionVertex"/></next>
		<rightchain public="1"><x path="Bool"/></rightchain>
		<helper public="1"><c path="zpp_nape.geom.ZPP_PartitionVertex"/></helper>
		<type public="1"><x path="Int"/></type>
		<diagonals public="1"><c path="zpp_nape.util.ZNPList_ZPP_PartitionVertex"/></diagonals>
		<forced public="1"><x path="Bool"/></forced>
		<y public="1"><x path="Float"/></y>
		<x public="1"><x path="Float"/></x>
		<mag public="1"><x path="Float"/></mag>
		<id public="1"><x path="Int"/></id>
		<new public="1" set="method" line="211"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_PartitionedPoly" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/geom/PartitionedPoly.hx" module="zpp_nape.geom.PartitionedPoly">
		<zpp_pool public="1" line="596" static="1"><c path="zpp_nape.geom.ZPP_PartitionedPoly"/></zpp_pool>
		<sharedPPList public="1" static="1"><c path="zpp_nape.util.ZNPList_ZPP_PartitionedPoly"/></sharedPPList>
		<getSharedPP public="1" get="inline" set="null" line="891" static="1"><f a=""><c path="zpp_nape.util.ZNPList_ZPP_PartitionedPoly"/></f></getSharedPP>
		<sharedGVList public="1" static="1"><c path="zpp_nape.util.ZNPList_ZPP_GeomVert"/></sharedGVList>
		<getShared public="1" get="inline" set="null" line="1134" static="1"><f a=""><c path="zpp_nape.util.ZNPList_ZPP_GeomVert"/></f></getShared>
		<pull set="method" line="1218"><f a="start:ret">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.util.ZNPList_ZPP_GeomVert"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
</f></pull>
		<extract public="1" set="method" line="1138"><f a="?ret">
	<c path="zpp_nape.util.ZNPList_ZPP_GeomVert"/>
	<c path="zpp_nape.util.ZNPList_ZPP_GeomVert"/>
</f></extract>
		<pull_partitions set="method" line="990"><f a="start:ret">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.util.ZNPList_ZPP_PartitionedPoly"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
</f></pull_partitions>
		<extract_partitions public="1" set="method" line="895"><f a="?ret">
	<c path="zpp_nape.util.ZNPList_ZPP_PartitionedPoly"/>
	<c path="zpp_nape.util.ZNPList_ZPP_PartitionedPoly"/>
</f></extract_partitions>
		<add_diagonal public="1" set="method" line="884"><f a="p:q">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Void"/>
</f></add_diagonal>
		<remove_collinear_vertices public="1" set="method" line="712"><f a=""><x path="Bool"/></f></remove_collinear_vertices>
		<init public="1" set="method" line="633"><f a="?P">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<x path="Void"/>
</f></init>
		<free public="1" get="inline" set="null" line="623"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="621"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.geom.ZPP_PartitionedPoly"/></next>
		<eq set="method" line="589"><f a="a:b">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Bool"/>
</f></eq>
		<vertices public="1"><c path="zpp_nape.geom.ZPP_PartitionVertex"/></vertices>
		<new public="1" set="method" line="592"><f a="?P">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_Ray" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/geom/Ray.hx" module="zpp_nape.geom.Ray">
		<internal public="1" line="176" static="1"><x path="Bool"/></internal>
		<polysect2 public="1" set="method" line="1185"><f a="p:inner:list">
	<c path="zpp_nape.shape.ZPP_Polygon"/>
	<x path="Bool"/>
	<c path="nape.geom.RayResultList"/>
	<x path="Void"/>
</f></polysect2>
		<polysect public="1" set="method" line="1068"><f a="p:inner:mint">
	<c path="zpp_nape.shape.ZPP_Polygon"/>
	<x path="Bool"/>
	<x path="Float"/>
	<t path="Null"><c path="nape.geom.RayResult"/></t>
</f></polysect>
		<circlesect2 public="1" set="method" line="761"><f a="c:inner:list">
	<c path="zpp_nape.shape.ZPP_Circle"/>
	<x path="Bool"/>
	<c path="nape.geom.RayResultList"/>
	<x path="Void"/>
</f></circlesect2>
		<circlesect public="1" set="method" line="491"><f a="c:inner:mint">
	<c path="zpp_nape.shape.ZPP_Circle"/>
	<x path="Bool"/>
	<x path="Float"/>
	<t path="Null"><c path="nape.geom.RayResult"/></t>
</f></circlesect>
		<aabbsect public="1" set="method" line="435"><f a="a">
	<c path="zpp_nape.geom.ZPP_AABB"/>
	<x path="Float"/>
</f></aabbsect>
		<aabbtest public="1" set="method" line="427"><f a="a">
	<c path="zpp_nape.geom.ZPP_AABB"/>
	<x path="Bool"/>
</f></aabbtest>
		<rayAABB public="1" set="method" line="391"><f a=""><c path="zpp_nape.geom.ZPP_AABB"/></f></rayAABB>
		<validate_dir public="1" set="method" line="290"><f a=""><x path="Void"/></f></validate_dir>
		<invalidate_dir public="1" get="inline" set="null" line="287"><f a=""><x path="Void"/></f></invalidate_dir>
		<zip_dir public="1"><x path="Bool"/></zip_dir>
		<direction_invalidate set="method" line="214"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></direction_invalidate>
		<origin_invalidate set="method" line="192"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></origin_invalidate>
		<absnormaly public="1"><x path="Float"/></absnormaly>
		<absnormalx public="1"><x path="Float"/></absnormalx>
		<normaly public="1"><x path="Float"/></normaly>
		<normalx public="1"><x path="Float"/></normalx>
		<idiry public="1"><x path="Float"/></idiry>
		<idirx public="1"><x path="Float"/></idirx>
		<diry public="1"><x path="Float"/></diry>
		<dirx public="1"><x path="Float"/></dirx>
		<originy public="1"><x path="Float"/></originy>
		<originx public="1"><x path="Float"/></originx>
		<userData public="1"><d><d/></d></userData>
		<maxdist public="1"><x path="Float"/></maxdist>
		<direction public="1"><c path="nape.geom.Vec2"/></direction>
		<origin public="1"><c path="nape.geom.Vec2"/></origin>
		<new public="1" set="method" line="237"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_SimpleVert" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/geom/Simple.hx" module="zpp_nape.geom.Simple">
		<zpp_pool public="1" line="181" static="1"><c path="zpp_nape.geom.ZPP_SimpleVert"/></zpp_pool>
		<less_xy public="1" set="method" line="237" static="1"><f a="p:q">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<x path="Bool"/>
</f></less_xy>
		<swap_nodes public="1" set="method" line="240" static="1"><f a="p:q">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<x path="Void"/>
</f></swap_nodes>
		<get public="1" get="inline" set="null" line="246" static="1"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
</f></get>
		<alloc public="1" get="inline" set="null" line="215"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="208"><f a=""><x path="Void"/></f></free>
		<node public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/></node>
		<next public="1"><c path="zpp_nape.geom.ZPP_SimpleVert"/></next>
		<id public="1"><x path="Int"/></id>
		<links public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/></links>
		<y public="1"><x path="Float"/></y>
		<x public="1"><x path="Float"/></x>
		<forced public="1"><x path="Bool"/></forced>
		<new set="method" line="216"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_SimpleSeg" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/geom/Simple.hx" module="zpp_nape.geom.Simple">
		<zpp_pool public="1" line="295" static="1"><c path="zpp_nape.geom.ZPP_SimpleSeg"/></zpp_pool>
		<get public="1" set="method" line="356" static="1"><f a="left:right">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
</f></get>
		<less_xy public="1" set="method" line="332"><f a="a:b">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<x path="Bool"/>
</f></less_xy>
		<node public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleSeg"/></node>
		<prev public="1"><c path="zpp_nape.geom.ZPP_SimpleSeg"/></prev>
		<alloc public="1" get="inline" set="null" line="329"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="321"><f a=""><x path="Void"/></f></free>
		<next public="1"><c path="zpp_nape.geom.ZPP_SimpleSeg"/></next>
		<id public="1"><x path="Int"/></id>
		<vertices public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/></vertices>
		<right public="1"><c path="zpp_nape.geom.ZPP_SimpleVert"/></right>
		<left public="1"><c path="zpp_nape.geom.ZPP_SimpleVert"/></left>
		<new set="method" line="335"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_SimpleEvent" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/geom/Simple.hx" module="zpp_nape.geom.Simple">
		<swap_nodes public="1" set="method" line="389" static="1"><f a="a:b">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<x path="Void"/>
</f></swap_nodes>
		<less_xy public="1" set="method" line="394" static="1"><f a="a:b">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<x path="Bool"/>
</f></less_xy>
		<zpp_pool public="1" line="404" static="1"><c path="zpp_nape.geom.ZPP_SimpleEvent"/></zpp_pool>
		<get public="1" get="inline" set="null" line="440" static="1"><f a="v">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
</f></get>
		<alloc public="1" get="inline" set="null" line="437"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="430"><f a=""><x path="Void"/></f></free>
		<next public="1"><c path="zpp_nape.geom.ZPP_SimpleEvent"/></next>
		<node public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"/></node>
		<segment2 public="1"><c path="zpp_nape.geom.ZPP_SimpleSeg"/></segment2>
		<segment public="1"><c path="zpp_nape.geom.ZPP_SimpleSeg"/></segment>
		<vertex public="1"><c path="zpp_nape.geom.ZPP_SimpleVert"/></vertex>
		<type public="1"><x path="Int"/></type>
		<new set="method" line="438"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_SimpleSweep" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/geom/Simple.hx" module="zpp_nape.geom.Simple">
		<intersection public="1" set="method" line="736"><f a="p:q">
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
</f></intersection>
		<intersect public="1" set="method" line="718"><f a="p:q">
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<x path="Bool"/>
</f></intersect>
		<remove public="1" set="method" line="710"><f a="e">
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<x path="Void"/>
</f></remove>
		<add public="1" set="method" line="696"><f a="e">
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
</f></add>
		<clear public="1" set="method" line="693"><f a=""><x path="Void"/></f></clear>
		<edge_lt public="1" set="method" line="493"><f a="p:q">
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<x path="Bool"/>
</f></edge_lt>
		<swap_nodes public="1" set="method" line="488"><f a="p:q">
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<x path="Void"/>
</f></swap_nodes>
		<tree public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleSeg"/></tree>
		<sweepx public="1"><x path="Float"/></sweepx>
		<new public="1" set="method" line="467"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_Simple" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/geom/Simple.hx" module="zpp_nape.geom.Simple">
		<sweep line="788" static="1"><c path="zpp_nape.geom.ZPP_SimpleSweep"/></sweep>
		<inthash line="789" static="1"><c path="zpp_nape.util.FastHash2_Hashable2_Boolfalse"/></inthash>
		<vertices line="790" static="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/></vertices>
		<queue line="791" static="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"/></queue>
		<ints line="792" static="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"/></ints>
		<decompose public="1" set="method" line="793" static="1"><f a="poly:?rets">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<c path="zpp_nape.util.ZNPList_ZPP_GeomVert"/>
	<c path="zpp_nape.util.ZNPList_ZPP_GeomVert"/>
</f></decompose>
		<clip_polygon public="1" set="method" line="1791" static="1"><f a="vertices:rets">
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/>
	<c path="zpp_nape.util.ZNPList_ZPP_GeomVert"/>
	<x path="Void"/>
</f></clip_polygon>
		<list_vertices line="2048" static="1"><c path="zpp_nape.util.ZNPList_ZPP_SimpleVert"/></list_vertices>
		<list_queue line="2049" static="1"><c path="zpp_nape.util.ZNPList_ZPP_SimpleEvent"/></list_queue>
		<isSimple public="1" set="method" line="2050" static="1"><f a="poly">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<x path="Bool"/>
</f></isSimple>
	</class>
	<class path="zpp_nape.geom.ZPP_SimplifyV" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/geom/Simplify.hx" module="zpp_nape.geom.Simplify">
		<zpp_pool public="1" line="178" static="1"><c path="zpp_nape.geom.ZPP_SimplifyV"/></zpp_pool>
		<get public="1" get="inline" set="null" line="213" static="1"><f a="v">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<c path="zpp_nape.geom.ZPP_SimplifyV"/>
</f></get>
		<alloc public="1" get="inline" set="null" line="210"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="207"><f a=""><x path="Void"/></f></free>
		<forced public="1"><x path="Bool"/></forced>
		<flag public="1"><x path="Bool"/></flag>
		<prev public="1"><c path="zpp_nape.geom.ZPP_SimplifyV"/></prev>
		<next public="1"><c path="zpp_nape.geom.ZPP_SimplifyV"/></next>
		<y public="1"><x path="Float"/></y>
		<x public="1"><x path="Float"/></x>
		<new public="1" set="method" line="211"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_SimplifyP" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/geom/Simplify.hx" module="zpp_nape.geom.Simplify">
		<zpp_pool public="1" line="259" static="1"><c path="zpp_nape.geom.ZPP_SimplifyP"/></zpp_pool>
		<get public="1" get="inline" set="null" line="295" static="1"><f a="min:max">
	<c path="zpp_nape.geom.ZPP_SimplifyV"/>
	<c path="zpp_nape.geom.ZPP_SimplifyV"/>
	<c path="zpp_nape.geom.ZPP_SimplifyP"/>
</f></get>
		<alloc public="1" get="inline" set="null" line="293"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="288"><f a=""><x path="Void"/></f></free>
		<max public="1"><c path="zpp_nape.geom.ZPP_SimplifyV"/></max>
		<min public="1"><c path="zpp_nape.geom.ZPP_SimplifyV"/></min>
		<next public="1"><c path="zpp_nape.geom.ZPP_SimplifyP"/></next>
		<new public="1" set="method" line="285"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_Simplify" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/geom/Simplify.hx" module="zpp_nape.geom.Simplify">
		<lessval public="1" get="inline" set="null" line="322" static="1"><f a="a:b">
	<c path="zpp_nape.geom.ZPP_SimplifyV"/>
	<c path="zpp_nape.geom.ZPP_SimplifyV"/>
	<x path="Float"/>
</f></lessval>
		<less public="1" get="inline" set="null" line="326" static="1"><f a="a:b">
	<c path="zpp_nape.geom.ZPP_SimplifyV"/>
	<c path="zpp_nape.geom.ZPP_SimplifyV"/>
	<x path="Bool"/>
</f></less>
		<distance public="1" set="method" line="329" static="1"><f a="v:a:b">
	<c path="zpp_nape.geom.ZPP_SimplifyV"/>
	<c path="zpp_nape.geom.ZPP_SimplifyV"/>
	<c path="zpp_nape.geom.ZPP_SimplifyV"/>
	<x path="Float"/>
</f></distance>
		<stack line="366" static="1"><c path="zpp_nape.util.ZNPList_ZPP_SimplifyP"/></stack>
		<simplify public="1" set="method" line="367" static="1"><f a="P:epsilon">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<x path="Float"/>
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
</f></simplify>
	</class>
	<class path="zpp_nape.geom.ZPP_ToiEvent" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/geom/SweepDistance.hx" module="zpp_nape.geom.SweepDistance">
		<zpp_pool public="1" line="176" static="1"><c path="zpp_nape.geom.ZPP_ToiEvent"/></zpp_pool>
		<kinematic public="1"><x path="Bool"/></kinematic>
		<failed public="1"><x path="Bool"/></failed>
		<slipped public="1"><x path="Bool"/></slipped>
		<axis public="1"><c path="zpp_nape.geom.ZPP_Vec2"/></axis>
		<c2 public="1"><c path="zpp_nape.geom.ZPP_Vec2"/></c2>
		<c1 public="1"><c path="zpp_nape.geom.ZPP_Vec2"/></c1>
		<frozen2 public="1"><x path="Bool"/></frozen2>
		<frozen1 public="1"><x path="Bool"/></frozen1>
		<arbiter public="1"><c path="zpp_nape.dynamics.ZPP_ColArbiter"/></arbiter>
		<s2 public="1"><c path="zpp_nape.shape.ZPP_Shape"/></s2>
		<s1 public="1"><c path="zpp_nape.shape.ZPP_Shape"/></s1>
		<toi public="1"><x path="Float"/></toi>
		<free public="1" get="inline" set="null" line="209"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="202"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.geom.ZPP_ToiEvent"/></next>
		<new public="1" set="method" line="222"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_SweepDistance" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/geom/SweepDistance.hx" module="zpp_nape.geom.SweepDistance">
		<dynamicSweep public="1" set="method" line="230" static="1"><f a="toi:timeStep:lowerBound:negRadius:?userAPI">
	<c path="zpp_nape.geom.ZPP_ToiEvent"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></dynamicSweep>
		<staticSweep public="1" set="method" line="339" static="1"><f a="toi:timeStep:lowerBound:negRadius">
	<c path="zpp_nape.geom.ZPP_ToiEvent"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></staticSweep>
		<distanceBody public="1" set="method" line="475" static="1"><f a="b1:b2:w1:w2">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Float"/>
</f></distanceBody>
		<distance public="1" get="inline" set="null" line="630" static="1"><f a="s1:s2:w1:w2:axis:?upperBound">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Float"/>
	<x path="Float"/>
</f></distance>
	</class>
	<class path="zpp_nape.geom.ZPP_PartitionPair" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/geom/Triangular.hx" module="zpp_nape.geom.Triangular">
		<zpp_pool public="1" line="175" static="1"><c path="zpp_nape.geom.ZPP_PartitionPair"/></zpp_pool>
		<get public="1" get="inline" set="null" line="569" static="1"><f a="a:b">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
</f></get>
		<edge_swap public="1" set="method" line="601" static="1"><f a="a:b">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<x path="Void"/>
</f></edge_swap>
		<edge_lt public="1" set="method" line="608" static="1"><f a="a:b">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<x path="Bool"/>
</f></edge_lt>
		<node public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_PartitionPair"/></node>
		<di public="1"><x path="Int"/></di>
		<id public="1"><x path="Int"/></id>
		<b public="1"><c path="zpp_nape.geom.ZPP_PartitionVertex"/></b>
		<a public="1"><c path="zpp_nape.geom.ZPP_PartitionVertex"/></a>
		<alloc public="1" get="inline" set="null" line="562"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="556"><f a=""><x path="Void"/></f></free>
		<at public="1" set="method" line="542"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
</f></at>
		<iterator_at public="1" set="method" line="529"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
</f></iterator_at>
		<back public="1" set="method" line="520"><f a=""><c path="zpp_nape.geom.ZPP_PartitionPair"/></f></back>
		<front public="1" get="inline" set="null" line="517"><f a=""><c path="zpp_nape.geom.ZPP_PartitionPair"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="487"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="482"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="479"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="474"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="459"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="453"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="448"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="444"><f a="pre:n">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="412"><f a="pre">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
</f></inlined_erase>
		<erase public="1" set="method" line="407"><f a="pre">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="384"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="371"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="346"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="335"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="322"><f a=""><c path="zpp_nape.geom.ZPP_PartitionPair"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="317"><f a=""><c path="zpp_nape.geom.ZPP_PartitionPair"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="298"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="293"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="268"><f a="cur:o">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
</f></inlined_insert>
		<insert public="1" set="method" line="263"><f a="cur:o">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
</f></insert>
		<addAll public="1" set="method" line="245"><f a="x">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="226"><f a="o">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
</f></inlined_add>
		<add public="1" set="method" line="221"><f a="o">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="216"><f a="i">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<_inuse public="1"><x path="Bool"/></_inuse>
		<begin public="1" get="inline" set="null" line="207"><f a=""><c path="zpp_nape.geom.ZPP_PartitionPair"/></f></begin>
		<elem public="1" get="inline" set="null" line="202"><f a=""><c path="zpp_nape.geom.ZPP_PartitionPair"/></f></elem>
		<next public="1"><c path="zpp_nape.geom.ZPP_PartitionPair"/></next>
		<new public="1" set="method" line="567"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_Triangular" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/geom/Triangular.hx" module="zpp_nape.geom.Triangular">
		<lt get="inline" set="null" line="615" static="1"><f a="p:q">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Bool"/>
</f></lt>
		<right_turn get="inline" set="null" line="619" static="1"><f a="a:b:c">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Float"/>
</f></right_turn>
		<queue line="634" static="1"><c path="zpp_nape.util.ZNPList_ZPP_PartitionVertex"/></queue>
		<stack line="635" static="1"><c path="zpp_nape.util.ZNPList_ZPP_PartitionVertex"/></stack>
		<delaunay public="1" set="method" line="636" static="1"><f a="A:B:C:D">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Bool"/>
</f></delaunay>
		<edgeSet line="687" static="1"><c path="zpp_nape.util.ZPP_Set_ZPP_PartitionPair"/></edgeSet>
		<optimise public="1" set="method" line="688" static="1"><f a="P">
	<c path="zpp_nape.geom.ZPP_PartitionedPoly"/>
	<x path="Void"/>
</f></optimise>
		<triangulate public="1" set="method" line="887" static="1"><f a="P">
	<c path="zpp_nape.geom.ZPP_PartitionedPoly"/>
	<c path="zpp_nape.geom.ZPP_PartitionedPoly"/>
</f></triangulate>
	</class>
	<class path="zpp_nape.geom.ZPP_Vec2" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/geom/Vec2.hx" module="zpp_nape.geom.Vec2">
		<zpp_pool public="1" line="233" static="1"><c path="zpp_nape.geom.ZPP_Vec2"/></zpp_pool>
		<get public="1" get="inline" set="null" line="632" static="1"><f a="x:y:?immutable">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
</f></get>
		<toString public="1" set="method" line="679"><f a=""><c path="String"/></f></toString>
		<copy public="1" get="inline" set="null" line="676"><f a=""><c path="zpp_nape.geom.ZPP_Vec2"/></f></copy>
		<y public="1"><x path="Float"/></y>
		<x public="1"><x path="Float"/></x>
		<at public="1" set="method" line="616"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
</f></at>
		<iterator_at public="1" set="method" line="603"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
</f></iterator_at>
		<back public="1" set="method" line="594"><f a=""><c path="zpp_nape.geom.ZPP_Vec2"/></f></back>
		<front public="1" get="inline" set="null" line="591"><f a=""><c path="zpp_nape.geom.ZPP_Vec2"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="561"><f a="obj">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="556"><f a="obj">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="553"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="548"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="533"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="527"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="522"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="518"><f a="pre:n">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="486"><f a="pre">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
</f></inlined_erase>
		<erase public="1" set="method" line="481"><f a="pre">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="458"><f a="obj">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="445"><f a="obj">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="420"><f a="obj">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="409"><f a="obj">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="396"><f a=""><c path="zpp_nape.geom.ZPP_Vec2"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="391"><f a=""><c path="zpp_nape.geom.ZPP_Vec2"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="372"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="367"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="342"><f a="cur:o">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
</f></inlined_insert>
		<insert public="1" set="method" line="337"><f a="cur:o">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
</f></insert>
		<addAll public="1" set="method" line="319"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="300"><f a="o">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
</f></inlined_add>
		<add public="1" set="method" line="295"><f a="o">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="290"><f a="i">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<_inuse public="1"><x path="Bool"/></_inuse>
		<begin public="1" get="inline" set="null" line="281"><f a=""><c path="zpp_nape.geom.ZPP_Vec2"/></f></begin>
		<elem public="1" get="inline" set="null" line="276"><f a=""><c path="zpp_nape.geom.ZPP_Vec2"/></f></elem>
		<next public="1"><c path="zpp_nape.geom.ZPP_Vec2"/></next>
		<alloc public="1" get="inline" set="null" line="270"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="259"><f a=""><x path="Void"/></f></free>
		<weak public="1"><x path="Bool"/></weak>
		<wrapper public="1" get="inline" set="null" line="208"><f a=""><c path="nape.geom.Vec2"/></f></wrapper>
		<outer public="1"><t path="Null"><c path="nape.geom.Vec2"/></t></outer>
		<immutable public="1" get="inline" set="null" line="195"><f a=""><x path="Void"/></f></immutable>
		<_isimmutable public="1"><t path="Null"><f a=""><x path="Void"/></f></t></_isimmutable>
		<_immutable public="1"><x path="Bool"/></_immutable>
		<invalidate public="1" get="inline" set="null" line="186"><f a=""><x path="Void"/></f></invalidate>
		<validate public="1" get="inline" set="null" line="179"><f a=""><x path="Void"/></f></validate>
		<_validate public="1"><t path="Null"><f a=""><x path="Void"/></f></t></_validate>
		<_invalidate public="1"><t path="Null"><f a="">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></t></_invalidate>
		<new public="1" set="method" line="630"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_Vec3" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/geom/Vec3.hx" module="zpp_nape.geom.Vec3">
		<validate public="1" get="inline" set="null" line="183"><f a=""><x path="Void"/></f></validate>
		<_validate public="1"><t path="Null"><f a=""><x path="Void"/></f></t></_validate>
		<immutable public="1"><x path="Bool"/></immutable>
		<z public="1"><x path="Float"/></z>
		<y public="1"><x path="Float"/></y>
		<x public="1"><x path="Float"/></x>
		<outer public="1"><c path="nape.geom.Vec3"/></outer>
		<new public="1" set="method" line="188"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_VecMath" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/geom/VecMath.hx" module="zpp_nape.geom.VecMath">
		<vec_dsq public="1" get="inline" set="null" line="176" static="1"><f a="ax:ay:bx:by">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></vec_dsq>
		<vec_distance public="1" get="inline" set="null" line="186" static="1"><f a="ax:ay:bx:by">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></vec_distance>
	</class>
	<class path="zpp_nape.phys.ZPP_Interactor" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/phys/Interactor.hx" module="zpp_nape.phys.Interactor">
		<get public="1" set="method" line="235" static="1"><f a="i1:i2">
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
</f></get>
		<int_callback public="1" get="inline" set="null" line="426" static="1"><f a="set:x:cb">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
	<c path="zpp_nape.callbacks.ZPP_Callback"/>
	<x path="Void"/>
</f></int_callback>
		<copyto public="1" set="method" line="449"><f a="ret">
	<c path="nape.phys.Interactor"/>
	<x path="Void"/>
</f></copyto>
		<lookup_group public="1" get="inline" set="null" line="440"><f a=""><c path="zpp_nape.dynamics.ZPP_InteractionGroup"/></f></lookup_group>
		<immutable_midstep public="1" set="method" line="415"><f a="n">
	<c path="String"/>
	<x path="Void"/>
</f></immutable_midstep>
		<setGroup public="1" set="method" line="402"><f a="group">
	<c path="zpp_nape.dynamics.ZPP_InteractionGroup"/>
	<x path="Void"/>
</f></setGroup>
		<dealloc_cbSet public="1" set="method" line="366"><f a=""><x path="Void"/></f></dealloc_cbSet>
		<alloc_cbSet public="1" set="method" line="349"><f a=""><x path="Void"/></f></alloc_cbSet>
		<insert_cbtype public="1" set="method" line="321"><f a="cb">
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<x path="Void"/>
</f></insert_cbtype>
		<wrap_cbTypes_adder set="method" line="317"><f a="cb">
	<c path="nape.callbacks.CbType"/>
	<x path="Bool"/>
</f></wrap_cbTypes_adder>
		<wrap_cbTypes_subber set="method" line="302"><f a="pcb">
	<c path="nape.callbacks.CbType"/>
	<x path="Void"/>
</f></wrap_cbTypes_subber>
		<immutable_cbTypes set="method" line="298"><f a=""><x path="Void"/></f></immutable_cbTypes>
		<setupcbTypes public="1" set="method" line="288"><f a=""><x path="Void"/></f></setupcbTypes>
		<wrap_cbTypes public="1"><c path="nape.callbacks.CbTypeList"/></wrap_cbTypes>
		<cbSet public="1"><c path="zpp_nape.callbacks.ZPP_CbSet"/></cbSet>
		<cbTypes public="1"><c path="zpp_nape.util.ZNPList_ZPP_CbType"/></cbTypes>
		<group public="1"><c path="zpp_nape.dynamics.ZPP_InteractionGroup"/></group>
		<getSpace public="1" get="inline" set="null" line="281"><f a=""><c path="zpp_nape.space.ZPP_Space"/></f></getSpace>
		<cbsets public="1"><c path="zpp_nape.util.ZNPList_ZPP_CallbackSet"/></cbsets>
		<wake public="1" set="method" line="220"><f a=""><x path="Void"/></f></wake>
		<__iremovedFromSpace public="1" set="method" line="208"><f a=""><x path="Void"/></f></__iremovedFromSpace>
		<__iaddedToSpace public="1" set="method" line="196"><f a=""><x path="Void"/></f></__iaddedToSpace>
		<isCompound public="1" get="inline" set="null" line="193"><f a=""><x path="Bool"/></f></isCompound>
		<isBody public="1" get="inline" set="null" line="188"><f a=""><x path="Bool"/></f></isBody>
		<isShape public="1" get="inline" set="null" line="183"><f a=""><x path="Bool"/></f></isShape>
		<icompound public="1"><c path="zpp_nape.phys.ZPP_Compound"/></icompound>
		<ibody public="1"><c path="zpp_nape.phys.ZPP_Body"/></ibody>
		<ishape public="1"><c path="zpp_nape.shape.ZPP_Shape"/></ishape>
		<userData public="1"><d><d/></d></userData>
		<id public="1"><x path="Int"/></id>
		<outer_i public="1"><c path="nape.phys.Interactor"/></outer_i>
		<new public="1" set="method" line="420"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.phys.ZPP_Body" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/phys/Body.hx" module="zpp_nape.phys.Body">
		<extends path="zpp_nape.phys.ZPP_Interactor"/>
		<bodystack line="212" static="1"><c path="zpp_nape.util.ZNPList_ZPP_Body"/></bodystack>
		<bodyset line="213" static="1"><c path="zpp_nape.util.ZPP_Set_ZPP_Body"/></bodyset>
		<bodysetlt set="method" line="214" static="1"><f a="a:b">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Bool"/>
</f></bodysetlt>
		<cur_graph_depth line="242" static="1"><x path="Int"/></cur_graph_depth>
		<__static public="1" set="method" line="1375" static="1"><f a=""><c path="nape.phys.Body"/></f></__static>
		<copy public="1" set="method" line="1687"><f a=""><c path="nape.phys.Body"/></f></copy>
		<removedFromSpace public="1" set="method" line="1662"><f a=""><x path="Void"/></f></removedFromSpace>
		<addedToSpace public="1" set="method" line="1632"><f a=""><x path="Void"/></f></addedToSpace>
		<shapes_modifiable set="method" line="1414"><f a=""><x path="Void"/></f></shapes_modifiable>
		<shapes_invalidate set="method" line="1410"><f a="_">
	<c path="zpp_nape.util.ZPP_ShapeList"/>
	<x path="Void"/>
</f></shapes_invalidate>
		<shapes_subber set="method" line="1405"><f a="s">
	<c path="nape.shape.Shape"/>
	<x path="Void"/>
</f></shapes_subber>
		<shapes_adder set="method" line="1391"><f a="s">
	<c path="nape.shape.Shape"/>
	<x path="Bool"/>
</f></shapes_adder>
		<aabb_validate set="method" line="1385"><f a=""><x path="Void"/></f></aabb_validate>
		<clear public="1" set="method" line="1207"><f a=""><x path="Void"/></f></clear>
		<__immutable_midstep public="1" get="inline" set="null" line="1202"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></__immutable_midstep>
		<getworldCOM public="1" set="method" line="1194"><f a=""><x path="Void"/></f></getworldCOM>
		<getlocalCOM public="1" set="method" line="1188"><f a=""><x path="Void"/></f></getlocalCOM>
		<validate_worldCOM public="1" set="method" line="1157"><f a=""><x path="Void"/></f></validate_worldCOM>
		<validate_localCOM public="1" set="method" line="1061"><f a=""><x path="Void"/></f></validate_localCOM>
		<invalidate_worldCOM public="1" get="inline" set="null" line="1058"><f a=""><x path="Void"/></f></invalidate_worldCOM>
		<invalidate_localCOM public="1" get="inline" set="null" line="1052"><f a=""><x path="Void"/></f></invalidate_localCOM>
		<wrap_worldCOM public="1"><c path="nape.geom.Vec2"/></wrap_worldCOM>
		<wrap_localCOM public="1"><c path="nape.geom.Vec2"/></wrap_localCOM>
		<zip_worldCOM public="1"><x path="Bool"/></zip_worldCOM>
		<worldCOMy public="1"><x path="Float"/></worldCOMy>
		<worldCOMx public="1"><x path="Float"/></worldCOMx>
		<zip_localCOM public="1"><x path="Bool"/></zip_localCOM>
		<localCOMy public="1"><x path="Float"/></localCOMy>
		<localCOMx public="1"><x path="Float"/></localCOMx>
		<invalidate_aabb public="1" get="inline" set="null" line="1039"><f a=""><x path="Void"/></f></invalidate_aabb>
		<validate_aabb public="1" get="inline" set="null" line="978"><f a=""><x path="Void"/></f></validate_aabb>
		<zip_aabb public="1"><x path="Bool"/></zip_aabb>
		<aabb public="1"><c path="zpp_nape.geom.ZPP_AABB"/></aabb>
		<invalidate_wake public="1" get="inline" set="null" line="972"><f a=""><x path="Void"/></f></invalidate_wake>
		<validate_inertia public="1" set="method" line="940"><f a=""><x path="Void"/></f></validate_inertia>
		<invalidate_inertia public="1" set="method" line="936"><f a=""><x path="Void"/></f></invalidate_inertia>
		<norotate public="1"><x path="Bool"/></norotate>
		<sinertia public="1"><x path="Float"/></sinertia>
		<iinertia public="1"><x path="Float"/></iinertia>
		<cinertia public="1"><x path="Float"/></cinertia>
		<zip_inertia public="1"><x path="Bool"/></zip_inertia>
		<inertia public="1"><x path="Float"/></inertia>
		<inertiaMode public="1"><x path="Int"/></inertiaMode>
		<validate_gravMassScale public="1" set="method" line="919"><f a=""><x path="Void"/></f></validate_gravMassScale>
		<invalidate_gravMassScale public="1" set="method" line="915"><f a=""><x path="Void"/></f></invalidate_gravMassScale>
		<validate_gravMass public="1" set="method" line="901"><f a=""><x path="Void"/></f></validate_gravMass>
		<invalidate_gravMass public="1" set="method" line="896"><f a=""><x path="Void"/></f></invalidate_gravMass>
		<zip_gravMassScale public="1"><x path="Bool"/></zip_gravMassScale>
		<gravMassScale public="1"><x path="Float"/></gravMassScale>
		<gravMassMode public="1"><x path="Int"/></gravMassMode>
		<zip_gravMass public="1"><x path="Bool"/></zip_gravMass>
		<gravMass public="1"><x path="Float"/></gravMass>
		<validate_mass public="1" set="method" line="861"><f a=""><x path="Void"/></f></validate_mass>
		<invalidate_mass public="1" set="method" line="857"><f a=""><x path="Void"/></f></invalidate_mass>
		<nomove public="1"><x path="Bool"/></nomove>
		<cmass public="1"><x path="Float"/></cmass>
		<smass public="1"><x path="Float"/></smass>
		<imass public="1"><x path="Float"/></imass>
		<massMode public="1"><x path="Int"/></massMode>
		<zip_mass public="1"><x path="Bool"/></zip_mass>
		<mass public="1"><x path="Float"/></mass>
		<kinematicDelaySleep public="1"><x path="Bool"/></kinematicDelaySleep>
		<delta_rot public="1" get="inline" set="null" line="837"><f a="dr">
	<x path="Float"/>
	<x path="Void"/>
</f></delta_rot>
		<quick_validate_axis public="1" get="inline" set="null" line="813"><f a=""><x path="Void"/></f></quick_validate_axis>
		<validate_axis public="1" get="inline" set="null" line="805"><f a=""><x path="Void"/></f></validate_axis>
		<zip_axis public="1"><x path="Bool"/></zip_axis>
		<axisy public="1"><x path="Float"/></axisy>
		<axisx public="1"><x path="Float"/></axisx>
		<invalidate_rot public="1" get="inline" set="null" line="783"><f a=""><x path="Void"/></f></invalidate_rot>
		<rot public="1"><x path="Float"/></rot>
		<pre_rot public="1"><x path="Float"/></pre_rot>
		<kinangvel public="1"><x path="Float"/></kinangvel>
		<torque public="1"><x path="Float"/></torque>
		<angvel public="1"><x path="Float"/></angvel>
		<setup_cvel public="1" set="method" line="770"><f a=""><x path="Void"/></f></setup_cvel>
		<wrapcvel public="1"><c path="nape.geom.Vec3"/></wrapcvel>
		<cvel_validate set="method" line="764"><f a=""><x path="Void"/></f></cvel_validate>
		<setupForce public="1" set="method" line="755"><f a=""><x path="Void"/></f></setupForce>
		<setupsvel public="1" set="method" line="746"><f a=""><x path="Void"/></f></setupsvel>
		<setupkinvel public="1" set="method" line="737"><f a=""><x path="Void"/></f></setupkinvel>
		<setupVelocity public="1" set="method" line="728"><f a=""><x path="Void"/></f></setupVelocity>
		<setupPosition public="1" set="method" line="719"><f a=""><x path="Void"/></f></setupPosition>
		<force_validate set="method" line="699"><f a=""><x path="Void"/></f></force_validate>
		<force_invalidate set="method" line="673"><f a="force">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></force_invalidate>
		<svel_validate set="method" line="651"><f a=""><x path="Void"/></f></svel_validate>
		<svel_invalidate set="method" line="628"><f a="vel">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></svel_invalidate>
		<kinvel_validate set="method" line="606"><f a=""><x path="Void"/></f></kinvel_validate>
		<kinvel_invalidate set="method" line="583"><f a="vel">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></kinvel_invalidate>
		<vel_validate set="method" line="561"><f a=""><x path="Void"/></f></vel_validate>
		<vel_invalidate set="method" line="535"><f a="vel">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></vel_invalidate>
		<pos_validate set="method" line="513"><f a=""><x path="Void"/></f></pos_validate>
		<pos_invalidate set="method" line="483"><f a="pos">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></pos_invalidate>
		<invalidate_pos public="1" get="inline" set="null" line="466"><f a=""><x path="Void"/></f></invalidate_pos>
		<wrap_svel public="1"><c path="nape.geom.Vec2"/></wrap_svel>
		<svely public="1"><x path="Float"/></svely>
		<svelx public="1"><x path="Float"/></svelx>
		<wrap_kinvel public="1"><c path="nape.geom.Vec2"/></wrap_kinvel>
		<kinvely public="1"><x path="Float"/></kinvely>
		<kinvelx public="1"><x path="Float"/></kinvelx>
		<wrap_force public="1"><c path="nape.geom.Vec2"/></wrap_force>
		<forcey public="1"><x path="Float"/></forcey>
		<forcex public="1"><x path="Float"/></forcex>
		<wrap_vel public="1"><c path="nape.geom.Vec2"/></wrap_vel>
		<vely public="1"><x path="Float"/></vely>
		<velx public="1"><x path="Float"/></velx>
		<wrap_pos public="1"><c path="nape.geom.Vec2"/></wrap_pos>
		<posy public="1"><x path="Float"/></posy>
		<posx public="1"><x path="Float"/></posx>
		<pre_posy public="1"><x path="Float"/></pre_posy>
		<pre_posx public="1"><x path="Float"/></pre_posx>
		<sweepValidate public="1" get="inline" set="null" line="378"><f a="s">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></sweepValidate>
		<sweepIntegrate public="1" get="inline" set="null" line="348"><f a="dt">
	<x path="Float"/>
	<x path="Void"/>
</f></sweepIntegrate>
		<disableCCD public="1"><x path="Bool"/></disableCCD>
		<bulletEnabled public="1"><x path="Bool"/></bulletEnabled>
		<bullet public="1"><x path="Bool"/></bullet>
		<sweepRadius public="1"><x path="Float"/></sweepRadius>
		<sweepFrozen public="1"><x path="Bool"/></sweepFrozen>
		<sweep_angvel public="1"><x path="Float"/></sweep_angvel>
		<sweepTime public="1"><x path="Float"/></sweepTime>
		<refreshArbiters public="1" set="method" line="329"><f a=""><x path="Void"/></f></refreshArbiters>
		<atRest public="1" set="method" line="304"><f a="dt">
	<x path="Float"/>
	<x path="Bool"/>
</f></atRest>
		<interactingBodies public="1" set="method" line="273"><f a="arbiter_type:depth:output">
	<x path="Int"/>
	<x path="Int"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></interactingBodies>
		<connectedBodies public="1" set="method" line="249"><f a="depth:output">
	<x path="Int"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></connectedBodies>
		<connectedBodies_cont set="method" line="243"><f a="b">
	<c path="nape.phys.Body"/>
	<x path="Void"/>
</f></connectedBodies_cont>
		<init_bodysetlist get="inline" set="null" line="219"><f a=""><x path="Void"/></f></init_bodysetlist>
		<graph_depth public="1"><x path="Int"/></graph_depth>
		<component public="1"><c path="zpp_nape.space.ZPP_Component"/></component>
		<wrap_constraints public="1"><c path="nape.constraint.ConstraintList"/></wrap_constraints>
		<constraints public="1"><c path="zpp_nape.util.ZNPList_ZPP_Constraint"/></constraints>
		<wrap_arbiters public="1"><c path="nape.dynamics.ArbiterList"/></wrap_arbiters>
		<arbiters public="1"><c path="zpp_nape.util.ZNPList_ZPP_Arbiter"/></arbiters>
		<space public="1"><c path="zpp_nape.space.ZPP_Space"/></space>
		<invalidate_shapes public="1" set="method" line="200"><f a=""><x path="Void"/></f></invalidate_shapes>
		<wrap_shapes public="1"><c path="nape.shape.ShapeList"/></wrap_shapes>
		<shapes public="1"><c path="zpp_nape.util.ZNPList_ZPP_Shape"/></shapes>
		<compound public="1"><c path="zpp_nape.phys.ZPP_Compound"/></compound>
		<invalidate_type public="1" set="method" line="193"><f a=""><x path="Void"/></f></invalidate_type>
		<isKinematic public="1" get="inline" set="null" line="190"><f a=""><x path="Bool"/></f></isKinematic>
		<isDynamic public="1" get="inline" set="null" line="185"><f a=""><x path="Bool"/></f></isDynamic>
		<isStatic public="1" get="inline" set="null" line="180"><f a=""><x path="Bool"/></f></isStatic>
		<type public="1"><x path="Int"/></type>
		<world public="1"><x path="Bool"/></world>
		<outer public="1"><c path="nape.phys.Body"/></outer>
		<new public="1" set="method" line="1419"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.phys.ZPP_Compound" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/phys/Compound.hx" module="zpp_nape.phys.Compound">
		<extends path="zpp_nape.phys.ZPP_Interactor"/>
		<copy public="1" set="method" line="336"><f a="?dict:?todo">
	<c path="Array"><c path="zpp_nape.constraint.ZPP_CopyHelper"/></c>
	<c path="Array"><c path="zpp_nape.constraint.ZPP_CopyHelper"/></c>
	<c path="nape.phys.Compound"/>
</f></copy>
		<compounds_modifiable set="method" line="305"><f a=""><x path="Void"/></f></compounds_modifiable>
		<compounds_subber set="method" line="299"><f a="x">
	<c path="nape.phys.Compound"/>
	<x path="Void"/>
</f></compounds_subber>
		<compounds_adder set="method" line="280"><f a="x">
	<c path="nape.phys.Compound"/>
	<x path="Bool"/>
</f></compounds_adder>
		<constraints_modifiable set="method" line="276"><f a=""><x path="Void"/></f></constraints_modifiable>
		<constraints_subber set="method" line="270"><f a="x">
	<c path="nape.constraint.Constraint"/>
	<x path="Void"/>
</f></constraints_subber>
		<constraints_adder set="method" line="258"><f a="x">
	<c path="nape.constraint.Constraint"/>
	<x path="Bool"/>
</f></constraints_adder>
		<bodies_modifiable set="method" line="254"><f a=""><x path="Void"/></f></bodies_modifiable>
		<bodies_subber set="method" line="248"><f a="x">
	<c path="nape.phys.Body"/>
	<x path="Void"/>
</f></bodies_subber>
		<bodies_adder set="method" line="236"><f a="x">
	<c path="nape.phys.Body"/>
	<x path="Bool"/>
</f></bodies_adder>
		<breakApart public="1" set="method" line="196"><f a=""><x path="Void"/></f></breakApart>
		<removedFromSpace public="1" set="method" line="193"><f a=""><x path="Void"/></f></removedFromSpace>
		<addedToSpace public="1" set="method" line="190"><f a=""><x path="Void"/></f></addedToSpace>
		<__imutable_midstep public="1" set="method" line="185"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></__imutable_midstep>
		<space public="1"><c path="zpp_nape.space.ZPP_Space"/></space>
		<compound public="1"><c path="zpp_nape.phys.ZPP_Compound"/></compound>
		<depth public="1"><x path="Int"/></depth>
		<wrap_compounds public="1"><c path="nape.phys.CompoundList"/></wrap_compounds>
		<wrap_constraints public="1"><c path="nape.constraint.ConstraintList"/></wrap_constraints>
		<wrap_bodies public="1"><c path="nape.phys.BodyList"/></wrap_bodies>
		<compounds public="1"><c path="zpp_nape.util.ZNPList_ZPP_Compound"/></compounds>
		<constraints public="1"><c path="zpp_nape.util.ZNPList_ZPP_Constraint"/></constraints>
		<bodies public="1"><c path="zpp_nape.util.ZNPList_ZPP_Body"/></bodies>
		<outer public="1"><c path="nape.phys.Compound"/></outer>
		<new public="1" set="method" line="309"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.phys.ZPP_FluidProperties" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/phys/FluidProperties.hx" module="zpp_nape.phys.FluidProperties">
		<zpp_pool public="1" line="176" static="1"><c path="zpp_nape.phys.ZPP_FluidProperties"/></zpp_pool>
		<invalidate public="1" set="method" line="355"><f a=""><x path="Void"/></f></invalidate>
		<getgravity public="1" set="method" line="349"><f a=""><x path="Void"/></f></getgravity>
		<gravity_validate set="method" line="327"><f a=""><x path="Void"/></f></gravity_validate>
		<gravity_invalidate set="method" line="304"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></gravity_invalidate>
		<wrap_gravity public="1"><c path="nape.geom.Vec2"/></wrap_gravity>
		<gravityy public="1"><x path="Float"/></gravityy>
		<gravityx public="1"><x path="Float"/></gravityx>
		<density public="1"><x path="Float"/></density>
		<viscosity public="1"><x path="Float"/></viscosity>
		<copy public="1" set="method" line="251"><f a=""><c path="zpp_nape.phys.ZPP_FluidProperties"/></f></copy>
		<remShape public="1" get="inline" set="null" line="248"><f a="shape">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></remShape>
		<addShape public="1" get="inline" set="null" line="243"><f a="shape">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></addShape>
		<feature_cons public="1" get="inline" set="null" line="238"><f a=""><x path="Void"/></f></feature_cons>
		<wrap_shapes public="1"><c path="nape.shape.ShapeList"/></wrap_shapes>
		<shapes public="1"><c path="zpp_nape.util.ZNPList_ZPP_Shape"/></shapes>
		<alloc public="1" get="inline" set="null" line="233"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="228"><f a=""><x path="Void"/></f></free>
		<wrapper public="1" set="method" line="202"><f a=""><c path="nape.phys.FluidProperties"/></f></wrapper>
		<outer public="1"><c path="nape.phys.FluidProperties"/></outer>
		<userData public="1"><d><d/></d></userData>
		<next public="1"><c path="zpp_nape.phys.ZPP_FluidProperties"/></next>
		<new public="1" set="method" line="274"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.phys.ZPP_Material" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/phys/Material.hx" module="zpp_nape.phys.Material">
		<zpp_pool public="1" line="176" static="1"><c path="zpp_nape.phys.ZPP_Material"/></zpp_pool>
		<WAKE public="1" line="280" static="1"><x path="Int"/></WAKE>
		<PROPS public="1" line="281" static="1"><x path="Int"/></PROPS>
		<ANGDRAG public="1" line="282" static="1"><x path="Int"/></ANGDRAG>
		<ARBITERS public="1" line="283" static="1"><x path="Int"/></ARBITERS>
		<invalidate public="1" set="method" line="284"><f a="x">
	<x path="Int"/>
	<x path="Void"/>
</f></invalidate>
		<set public="1" set="method" line="273"><f a="x">
	<c path="zpp_nape.phys.ZPP_Material"/>
	<x path="Void"/>
</f></set>
		<copy public="1" set="method" line="264"><f a=""><c path="zpp_nape.phys.ZPP_Material"/></f></copy>
		<rollingFriction public="1"><x path="Float"/></rollingFriction>
		<elasticity public="1"><x path="Float"/></elasticity>
		<density public="1"><x path="Float"/></density>
		<staticFriction public="1"><x path="Float"/></staticFriction>
		<dynamicFriction public="1"><x path="Float"/></dynamicFriction>
		<remShape public="1" get="inline" set="null" line="248"><f a="shape">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></remShape>
		<addShape public="1" get="inline" set="null" line="243"><f a="shape">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></addShape>
		<feature_cons public="1" get="inline" set="null" line="238"><f a=""><x path="Void"/></f></feature_cons>
		<wrap_shapes public="1"><c path="nape.shape.ShapeList"/></wrap_shapes>
		<shapes public="1"><c path="zpp_nape.util.ZNPList_ZPP_Shape"/></shapes>
		<alloc public="1" get="inline" set="null" line="233"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="228"><f a=""><x path="Void"/></f></free>
		<wrapper public="1" set="method" line="202"><f a=""><c path="nape.phys.Material"/></f></wrapper>
		<outer public="1"><c path="nape.phys.Material"/></outer>
		<userData public="1"><d><d/></d></userData>
		<next public="1"><c path="zpp_nape.phys.ZPP_Material"/></next>
		<new public="1" set="method" line="256"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.shape.ZPP_Shape" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/shape/Shape.hx" module="zpp_nape.shape.Shape">
		<extends path="zpp_nape.phys.ZPP_Interactor"/>
		<copy public="1" set="method" line="480"><f a=""><c path="nape.shape.Shape"/></f></copy>
		<removedFromSpace public="1" set="method" line="474"><f a=""><x path="Void"/></f></removedFromSpace>
		<addedToSpace public="1" set="method" line="468"><f a=""><x path="Void"/></f></addedToSpace>
		<removedFromBody public="1" set="method" line="467"><f a=""><x path="Void"/></f></removedFromBody>
		<addedToBody public="1" set="method" line="463"><f a=""><x path="Void"/></f></addedToBody>
		<__immutable_midstep public="1" set="method" line="458"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></__immutable_midstep>
		<setFluid public="1" set="method" line="448"><f a="fluid">
	<c path="zpp_nape.phys.ZPP_FluidProperties"/>
	<x path="Void"/>
</f></setFluid>
		<setFilter public="1" set="method" line="438"><f a="filter">
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<x path="Void"/>
</f></setFilter>
		<setMaterial public="1" set="method" line="427"><f a="material">
	<c path="zpp_nape.phys.ZPP_Material"/>
	<x path="Void"/>
</f></setMaterial>
		<aabb_validate set="method" line="364"><f a=""><x path="Void"/></f></aabb_validate>
		<invalidate_fluidprops public="1" set="method" line="361"><f a=""><x path="Void"/></f></invalidate_fluidprops>
		<invalidate_filter public="1" set="method" line="358"><f a=""><x path="Void"/></f></invalidate_filter>
		<invalidate_material public="1" set="method" line="341"><f a="flags">
	<x path="Int"/>
	<x path="Void"/>
</f></invalidate_material>
		<invalidate_worldCOM public="1" set="method" line="337"><f a=""><x path="Void"/></f></invalidate_worldCOM>
		<invalidate_localCOM public="1" set="method" line="329"><f a=""><x path="Void"/></f></invalidate_localCOM>
		<invalidate_angDrag public="1" set="method" line="326"><f a=""><x path="Void"/></f></invalidate_angDrag>
		<invalidate_area_inertia public="1" set="method" line="318"><f a=""><x path="Void"/></f></invalidate_area_inertia>
		<getworldCOM public="1" set="method" line="292"><f a=""><x path="Void"/></f></getworldCOM>
		<validate_worldCOM public="1" get="inline" set="null" line="279"><f a=""><x path="Void"/></f></validate_worldCOM>
		<validate_localCOM public="1" get="inline" set="null" line="271"><f a=""><x path="Void"/></f></validate_localCOM>
		<validate_angDrag public="1" set="method" line="261"><f a=""><x path="Void"/></f></validate_angDrag>
		<validate_area_inertia public="1" set="method" line="254"><f a=""><x path="Void"/></f></validate_area_inertia>
		<invalidate_aabb public="1" get="inline" set="null" line="250"><f a=""><x path="Void"/></f></invalidate_aabb>
		<force_validate_aabb public="1" get="inline" set="null" line="244"><f a=""><x path="Void"/></f></force_validate_aabb>
		<validate_aabb public="1" get="inline" set="null" line="233"><f a=""><x path="Void"/></f></validate_aabb>
		<zip_aabb public="1"><x path="Bool"/></zip_aabb>
		<aabb public="1"><c path="zpp_nape.geom.ZPP_AABB"/></aabb>
		<clear public="1" set="method" line="225"><f a=""><x path="Void"/></f></clear>
		<pairs public="1"><c path="zpp_nape.util.ZNPList_ZPP_AABBPair"/></pairs>
		<node public="1"><c path="zpp_nape.space.ZPP_AABBNode"/></node>
		<sweep public="1"><c path="zpp_nape.space.ZPP_SweepData"/></sweep>
		<sensorEnabled public="1"><x path="Bool"/></sensorEnabled>
		<fluidEnabled public="1"><x path="Bool"/></fluidEnabled>
		<fluidProperties public="1"><c path="zpp_nape.phys.ZPP_FluidProperties"/></fluidProperties>
		<filter public="1"><c path="zpp_nape.dynamics.ZPP_InteractionFilter"/></filter>
		<material public="1"><c path="zpp_nape.phys.ZPP_Material"/></material>
		<refmaterial public="1"><c path="zpp_nape.phys.ZPP_Material"/></refmaterial>
		<polygon public="1"><c path="zpp_nape.shape.ZPP_Polygon"/></polygon>
		<circle public="1"><c path="zpp_nape.shape.ZPP_Circle"/></circle>
		<validate_sweepRadius public="1" set="method" line="207"><f a=""><x path="Void"/></f></validate_sweepRadius>
		<invalidate_sweepRadius public="1" get="inline" set="null" line="204"><f a=""><x path="Void"/></f></invalidate_sweepRadius>
		<sweepCoef public="1"><x path="Float"/></sweepCoef>
		<zip_sweepRadius public="1"><x path="Bool"/></zip_sweepRadius>
		<sweepRadius public="1"><x path="Float"/></sweepRadius>
		<wrap_worldCOM public="1"><c path="nape.geom.Vec2"/></wrap_worldCOM>
		<wrap_localCOM public="1"><c path="nape.geom.Vec2"/></wrap_localCOM>
		<zip_worldCOM public="1"><x path="Bool"/></zip_worldCOM>
		<worldCOMy public="1"><x path="Float"/></worldCOMy>
		<worldCOMx public="1"><x path="Float"/></worldCOMx>
		<zip_localCOM public="1"><x path="Bool"/></zip_localCOM>
		<localCOMy public="1"><x path="Float"/></localCOMy>
		<localCOMx public="1"><x path="Float"/></localCOMx>
		<zip_angDrag public="1"><x path="Bool"/></zip_angDrag>
		<angDrag public="1"><x path="Float"/></angDrag>
		<inertia public="1"><x path="Float"/></inertia>
		<zip_area_inertia public="1"><x path="Bool"/></zip_area_inertia>
		<area public="1"><x path="Float"/></area>
		<isPolygon public="1" get="inline" set="null" line="183"><f a=""><x path="Bool"/></f></isPolygon>
		<isCircle public="1" get="inline" set="null" line="179"><f a=""><x path="Bool"/></f></isCircle>
		<type public="1"><x path="Int"/></type>
		<body public="1"><c path="zpp_nape.phys.ZPP_Body"/></body>
		<outer public="1"><c path="nape.shape.Shape"/></outer>
		<new set="method" line="370"><f a="type">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="zpp_nape.shape.ZPP_Circle" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/shape/Circle.hx" module="zpp_nape.shape.Circle">
		<extends path="zpp_nape.shape.ZPP_Shape"/>
		<__copy public="1" set="method" line="376"><f a=""><c path="zpp_nape.shape.ZPP_Circle"/></f></__copy>
		<__transform public="1" set="method" line="364"><f a="m">
	<c path="nape.geom.Mat23"/>
	<x path="Void"/>
</f></__transform>
		<__rotate public="1" set="method" line="333"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></__rotate>
		<__translate public="1" set="method" line="317"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></__translate>
		<__scale public="1" set="method" line="307"><f a="sx:sy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></__scale>
		<__validate_angDrag public="1" set="method" line="300"><f a=""><x path="Void"/></f></__validate_angDrag>
		<__validate_area_inertia public="1" set="method" line="295"><f a=""><x path="Void"/></f></__validate_area_inertia>
		<__validate_sweepRadius public="1" set="method" line="291"><f a=""><x path="Void"/></f></__validate_sweepRadius>
		<_force_validate_aabb public="1" get="inline" set="null" line="281"><f a=""><x path="Void"/></f></_force_validate_aabb>
		<__validate_aabb public="1" get="inline" set="null" line="250"><f a=""><x path="Void"/></f></__validate_aabb>
		<setupLocalCOM public="1" set="method" line="238"><f a=""><x path="Void"/></f></setupLocalCOM>
		<localCOM_immutable set="method" line="234"><f a=""><x path="Void"/></f></localCOM_immutable>
		<localCOM_invalidate set="method" line="209"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></localCOM_invalidate>
		<localCOM_validate set="method" line="189"><f a=""><x path="Void"/></f></localCOM_validate>
		<invalidate_radius public="1" set="method" line="183"><f a=""><x path="Void"/></f></invalidate_radius>
		<__clear public="1" set="method" line="182"><f a=""><x path="Void"/></f></__clear>
		<radius public="1"><x path="Float"/></radius>
		<outer_zn public="1"><c path="nape.shape.Circle"/></outer_zn>
		<new public="1" set="method" line="177"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.shape.ZPP_Edge" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/shape/Edge.hx" module="zpp_nape.shape.Edge">
		<zpp_pool public="1" line="176" static="1"><c path="zpp_nape.shape.ZPP_Edge"/></zpp_pool>
		<internal public="1" line="209" static="1"><x path="Bool"/></internal>
		<getgnorm public="1" set="method" line="293"><f a=""><x path="Void"/></f></getgnorm>
		<getlnorm public="1" set="method" line="288"><f a=""><x path="Void"/></f></getlnorm>
		<gnorm_validate set="method" line="261"><f a=""><x path="Void"/></f></gnorm_validate>
		<lnorm_validate set="method" line="235"><f a=""><x path="Void"/></f></lnorm_validate>
		<tp1 public="1"><x path="Float"/></tp1>
		<tp0 public="1"><x path="Float"/></tp0>
		<gp1 public="1"><c path="zpp_nape.geom.ZPP_Vec2"/></gp1>
		<lp1 public="1"><c path="zpp_nape.geom.ZPP_Vec2"/></lp1>
		<gp0 public="1"><c path="zpp_nape.geom.ZPP_Vec2"/></gp0>
		<lp0 public="1"><c path="zpp_nape.geom.ZPP_Vec2"/></lp0>
		<gprojection public="1"><x path="Float"/></gprojection>
		<lprojection public="1"><x path="Float"/></lprojection>
		<length public="1"><x path="Float"/></length>
		<wrap_gnorm public="1"><c path="nape.geom.Vec2"/></wrap_gnorm>
		<gnormy public="1"><x path="Float"/></gnormy>
		<gnormx public="1"><x path="Float"/></gnormx>
		<wrap_lnorm public="1"><c path="nape.geom.Vec2"/></wrap_lnorm>
		<lnormy public="1"><x path="Float"/></lnormy>
		<lnormx public="1"><x path="Float"/></lnormx>
		<wrapper public="1" set="method" line="211"><f a=""><c path="nape.shape.Edge"/></f></wrapper>
		<outer public="1"><c path="nape.shape.Edge"/></outer>
		<polygon public="1"><c path="zpp_nape.shape.ZPP_Polygon"/></polygon>
		<alloc public="1" get="inline" set="null" line="207"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="202"><f a=""><x path="Void"/></f></free>
		<next public="1"><c path="zpp_nape.shape.ZPP_Edge"/></next>
		<new public="1" set="method" line="298"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.shape.ZPP_Polygon" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/shape/Polygon.hx" module="zpp_nape.shape.Polygon">
		<extends path="zpp_nape.shape.ZPP_Shape"/>
		<__copy public="1" set="method" line="1926"><f a=""><c path="zpp_nape.shape.ZPP_Polygon"/></f></__copy>
		<__transform public="1" set="method" line="1909"><f a="mat">
	<c path="nape.geom.Mat23"/>
	<x path="Void"/>
</f></__transform>
		<__rotate public="1" set="method" line="1871"><f a="ax:ay">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></__rotate>
		<__scale public="1" set="method" line="1857"><f a="sx:sy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></__scale>
		<__translate public="1" set="method" line="1834"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></__translate>
		<setupLocalCOM public="1" set="method" line="1820"><f a=""><x path="Void"/></f></setupLocalCOM>
		<localCOM_invalidate set="method" line="1774"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></localCOM_invalidate>
		<localCOM_validate set="method" line="1768"><f a=""><x path="Void"/></f></localCOM_validate>
		<__validate_localCOM public="1" get="inline" set="null" line="1621"><f a=""><x path="Void"/></f></__validate_localCOM>
		<__validate_angDrag public="1" set="method" line="1393"><f a=""><x path="Void"/></f></__validate_angDrag>
		<__validate_area_inertia public="1" set="method" line="1336"><f a=""><x path="Void"/></f></__validate_area_inertia>
		<__validate_sweepRadius public="1" set="method" line="1302"><f a=""><x path="Void"/></f></__validate_sweepRadius>
		<_force_validate_aabb public="1" get="inline" set="null" line="1233"><f a=""><x path="Void"/></f></_force_validate_aabb>
		<__validate_aabb public="1" get="inline" set="null" line="1171"><f a=""><x path="Void"/></f></__validate_aabb>
		<validate_gaxi public="1" get="inline" set="null" line="1081"><f a=""><x path="Void"/></f></validate_gaxi>
		<validate_gverts public="1" get="inline" set="null" line="1055"><f a=""><x path="Void"/></f></validate_gverts>
		<validate_laxi public="1" set="method" line="889"><f a=""><x path="Void"/></f></validate_laxi>
		<reverse_vertices public="1" set="method" line="877"><f a=""><x path="Void"/></f></reverse_vertices>
		<splice_collinear_real public="1" set="method" line="821"><f a=""><x path="Void"/></f></splice_collinear_real>
		<splice_collinear public="1" get="inline" set="null" line="815"><f a=""><x path="Void"/></f></splice_collinear>
		<zip_sanitation public="1"><x path="Bool"/></zip_sanitation>
		<cleanup_lvert public="1" set="method" line="714"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></cleanup_lvert>
		<validate_lverts public="1" set="method" line="702"><f a=""><x path="Void"/></f></validate_lverts>
		<valid public="1" set="method" line="369"><f a=""><c path="nape.shape.ValidationResult"/></f></valid>
		<validation public="1"><c path="nape.shape.ValidationResult"/></validation>
		<zip_valid public="1"><x path="Bool"/></zip_valid>
		<invalidate_gaxi public="1" set="method" line="364"><f a=""><x path="Void"/></f></invalidate_gaxi>
		<zip_gaxi public="1"><x path="Bool"/></zip_gaxi>
		<invalidate_gverts public="1" set="method" line="359"><f a=""><x path="Void"/></f></invalidate_gverts>
		<zip_gverts public="1"><x path="Bool"/></zip_gverts>
		<invalidate_laxi public="1" set="method" line="353"><f a=""><x path="Void"/></f></invalidate_laxi>
		<zip_laxi public="1"><x path="Bool"/></zip_laxi>
		<invalidate_lverts public="1" set="method" line="341"><f a=""><x path="Void"/></f></invalidate_lverts>
		<zip_lverts public="1"><x path="Bool"/></zip_lverts>
		<getedges public="1" set="method" line="334"><f a=""><x path="Void"/></f></getedges>
		<getgverts public="1" set="method" line="328"><f a=""><x path="Void"/></f></getgverts>
		<getlverts public="1" set="method" line="316"><f a=""><x path="Void"/></f></getlverts>
		<edges_validate set="method" line="312"><f a=""><x path="Void"/></f></edges_validate>
		<gverts_validate set="method" line="309"><f a=""><x path="Void"/></f></gverts_validate>
		<lverts_modifiable set="method" line="302"><f a=""><x path="Void"/></f></lverts_modifiable>
		<lverts_validate set="method" line="298"><f a=""><x path="Void"/></f></lverts_validate>
		<lverts_invalidate set="method" line="295"><f a="_">
	<c path="zpp_nape.util.ZPP_Vec2List"/>
	<x path="Void"/>
</f></lverts_invalidate>
		<lverts_subber set="method" line="292"><f a="x">
	<c path="nape.geom.Vec2"/>
	<x path="Void"/>
</f></lverts_subber>
		<lverts_post_adder set="method" line="199"><f a="x">
	<c path="nape.geom.Vec2"/>
	<x path="Void"/>
</f></lverts_post_adder>
		<gverts_pa_validate set="method" line="193"><f a=""><x path="Void"/></f></gverts_pa_validate>
		<lverts_pa_immutable set="method" line="189"><f a=""><x path="Void"/></f></lverts_pa_immutable>
		<lverts_pa_invalidate set="method" line="185"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></lverts_pa_invalidate>
		<__clear public="1" set="method" line="184"><f a=""><x path="Void"/></f></__clear>
		<reverse_flag public="1"><x path="Bool"/></reverse_flag>
		<edgeCnt public="1"><x path="Int"/></edgeCnt>
		<wrap_edges public="1"><c path="nape.shape.EdgeList"/></wrap_edges>
		<edges public="1"><c path="zpp_nape.util.ZNPList_ZPP_Edge"/></edges>
		<wrap_gverts public="1"><c path="nape.geom.Vec2List"/></wrap_gverts>
		<gverts public="1"><c path="zpp_nape.geom.ZPP_Vec2"/></gverts>
		<wrap_lverts public="1"><c path="nape.geom.Vec2List"/></wrap_lverts>
		<lverts public="1"><c path="zpp_nape.geom.ZPP_Vec2"/></lverts>
		<outer_zn public="1"><c path="nape.shape.Polygon"/></outer_zn>
		<new public="1" set="method" line="1826"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.space.ZPP_Broadphase" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/space/Broadphase.hx" module="zpp_nape.space.Broadphase">
		<rayMultiCast public="1" set="method" line="274"><f a="ray:inner:filter:output">
	<c path="zpp_nape.geom.ZPP_Ray"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.geom.RayResultList"/>
	<c path="nape.geom.RayResultList"/>
</f></rayMultiCast>
		<rayCast public="1" set="method" line="271"><f a="ray:inner:filter">
	<c path="zpp_nape.geom.ZPP_Ray"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.geom.RayResult"/>
</f></rayCast>
		<bodiesInShape public="1" set="method" line="268"><f a="shape:containment:filter:output">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></bodiesInShape>
		<shapesInShape public="1" set="method" line="265"><f a="shape:containment:filter:output">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.shape.ShapeList"/>
	<c path="nape.shape.ShapeList"/>
</f></shapesInShape>
		<validateShape public="1" set="method" line="260"><f a="s">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></validateShape>
		<bodiesInCircle public="1" set="method" line="257"><f a="x:y:r:containment:filter:output">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></bodiesInCircle>
		<shapesInCircle public="1" set="method" line="254"><f a="x:y:r:containment:filter:output">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.shape.ShapeList"/>
	<c path="nape.shape.ShapeList"/>
</f></shapesInCircle>
		<updateCircShape public="1" set="method" line="237"><f a="x:y:r">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></updateCircShape>
		<circShape public="1"><c path="nape.shape.Shape"/></circShape>
		<bodiesInAABB public="1" set="method" line="233"><f a="aabb:strict:containment:filter:output">
	<c path="zpp_nape.geom.ZPP_AABB"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></bodiesInAABB>
		<shapesInAABB public="1" set="method" line="230"><f a="aabb:strict:containment:filter:output">
	<c path="zpp_nape.geom.ZPP_AABB"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.shape.ShapeList"/>
	<c path="nape.shape.ShapeList"/>
</f></shapesInAABB>
		<updateAABBShape public="1" set="method" line="210"><f a="aabb">
	<c path="zpp_nape.geom.ZPP_AABB"/>
	<x path="Void"/>
</f></updateAABBShape>
		<matrix public="1"><c path="nape.geom.Mat23"/></matrix>
		<aabbShape public="1"><c path="nape.shape.Shape"/></aabbShape>
		<bodiesUnderPoint public="1" set="method" line="205"><f a="x:y:filter:output">
	<x path="Float"/>
	<x path="Float"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></bodiesUnderPoint>
		<shapesUnderPoint public="1" set="method" line="202"><f a="x:y:filter:output">
	<x path="Float"/>
	<x path="Float"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.shape.ShapeList"/>
	<c path="nape.shape.ShapeList"/>
</f></shapesUnderPoint>
		<clear public="1" set="method" line="201"><f a=""><x path="Void"/></f></clear>
		<broadphase public="1" set="method" line="191"><f a="space:discrete">
	<c path="zpp_nape.space.ZPP_Space"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></broadphase>
		<sync public="1" set="method" line="187"><f a="shape">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></sync>
		<remove public="1" set="method" line="183"><f a="shape">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></remove>
		<insert public="1" set="method" line="179"><f a="shape">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></insert>
		<dynab public="1"><c path="zpp_nape.space.ZPP_DynAABBPhase"/></dynab>
		<sweep public="1"><c path="zpp_nape.space.ZPP_SweepPhase"/></sweep>
		<is_sweep public="1"><x path="Bool"/></is_sweep>
		<space public="1"><c path="zpp_nape.space.ZPP_Space"/></space>
		<new public="1" set="method" line="174"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.space.ZPP_AABBNode" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/space/DynAABBPhase.hx" module="zpp_nape.space.DynAABBPhase">
		<zpp_pool public="1" line="187" static="1"><c path="zpp_nape.space.ZPP_AABBNode"/></zpp_pool>
		<isLeaf public="1" get="inline" set="null" line="268"><f a=""><x path="Bool"/></f></isLeaf>
		<first_sync public="1"><x path="Bool"/></first_sync>
		<synced public="1"><x path="Bool"/></synced>
		<snext public="1"><c path="zpp_nape.space.ZPP_AABBNode"/></snext>
		<moved public="1"><x path="Bool"/></moved>
		<mnext public="1"><c path="zpp_nape.space.ZPP_AABBNode"/></mnext>
		<free public="1" get="inline" set="null" line="237"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="213"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.space.ZPP_AABBNode"/></next>
		<rayt public="1"><x path="Float"/></rayt>
		<height public="1"><x path="Int"/></height>
		<child2 public="1"><c path="zpp_nape.space.ZPP_AABBNode"/></child2>
		<child1 public="1"><c path="zpp_nape.space.ZPP_AABBNode"/></child1>
		<parent public="1"><c path="zpp_nape.space.ZPP_AABBNode"/></parent>
		<dyn public="1"><x path="Bool"/></dyn>
		<shape public="1"><c path="zpp_nape.shape.ZPP_Shape"/></shape>
		<aabb public="1"><c path="zpp_nape.geom.ZPP_AABB"/></aabb>
		<new public="1" set="method" line="183"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.space.ZPP_AABBPair" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/space/DynAABBPhase.hx" module="zpp_nape.space.DynAABBPhase">
		<zpp_pool public="1" line="282" static="1"><c path="zpp_nape.space.ZPP_AABBPair"/></zpp_pool>
		<free public="1" get="inline" set="null" line="321"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="309"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.space.ZPP_AABBPair"/></next>
		<arb public="1"><c path="zpp_nape.dynamics.ZPP_Arbiter"/></arb>
		<di public="1"><x path="Int"/></di>
		<id public="1"><x path="Int"/></id>
		<sleeping public="1"><x path="Bool"/></sleeping>
		<first public="1"><x path="Bool"/></first>
		<n2 public="1"><c path="zpp_nape.space.ZPP_AABBNode"/></n2>
		<n1 public="1"><c path="zpp_nape.space.ZPP_AABBNode"/></n1>
		<new public="1" set="method" line="306"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.space.ZPP_AABBTree" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/space/DynAABBPhase.hx" module="zpp_nape.space.DynAABBPhase">
		<tmpaabb public="1" line="419" static="1"><c path="zpp_nape.geom.ZPP_AABB"/></tmpaabb>
		<balance public="1" get="inline" set="null" line="589"><f a="a">
	<c path="zpp_nape.space.ZPP_AABBNode"/>
	<c path="zpp_nape.space.ZPP_AABBNode"/>
</f></balance>
		<inlined_removeLeaf public="1" get="inline" set="null" line="520"><f a="leaf">
	<c path="zpp_nape.space.ZPP_AABBNode"/>
	<x path="Void"/>
</f></inlined_removeLeaf>
		<removeLeaf public="1" set="method" line="515"><f a="leaf">
	<c path="zpp_nape.space.ZPP_AABBNode"/>
	<x path="Void"/>
</f></removeLeaf>
		<inlined_insertLeaf public="1" get="inline" set="null" line="425"><f a="leaf">
	<c path="zpp_nape.space.ZPP_AABBNode"/>
	<x path="Void"/>
</f></inlined_insertLeaf>
		<insertLeaf set="method" line="420"><f a="leaf">
	<c path="zpp_nape.space.ZPP_AABBNode"/>
	<x path="Void"/>
</f></insertLeaf>
		<clear public="1" set="method" line="338"><f a=""><x path="Void"/></f></clear>
		<root public="1"><c path="zpp_nape.space.ZPP_AABBNode"/></root>
		<new public="1" set="method" line="337"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.space.ZPP_DynAABBPhase" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/space/DynAABBPhase.hx" module="zpp_nape.space.DynAABBPhase">
		<extends path="zpp_nape.space.ZPP_Broadphase"/>
		<FATTEN get="inline" set="null" line="696" static="1"><x path="Float"/></FATTEN>
		<VEL_STEPS get="inline" set="null" line="698" static="1"><x path="Float"/></VEL_STEPS>
		<rayMultiCast public="1" set="method" line="2950" override="1"><f a="ray:inner:filter:output">
	<c path="zpp_nape.geom.ZPP_Ray"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.geom.RayResultList"/>
	<c path="nape.geom.RayResultList"/>
</f></rayMultiCast>
		<rayCast public="1" set="method" line="2821" override="1"><f a="ray:inner:filter">
	<c path="zpp_nape.geom.ZPP_Ray"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.geom.RayResult"/>
</f></rayCast>
		<openlist public="1"><c path="zpp_nape.util.ZNPList_ZPP_AABBNode"/></openlist>
		<bodiesInShape public="1" set="method" line="2721" override="1"><f a="shp:containment:filter:output">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></bodiesInShape>
		<shapesInShape public="1" set="method" line="2644" override="1"><f a="shp:containment:filter:output">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.shape.ShapeList"/>
	<c path="nape.shape.ShapeList"/>
</f></shapesInShape>
		<bodiesInCircle public="1" set="method" line="2545" override="1"><f a="x:y:r:containment:filter:output">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></bodiesInCircle>
		<shapesInCircle public="1" set="method" line="2468" override="1"><f a="x:y:r:containment:filter:output">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.shape.ShapeList"/>
	<c path="nape.shape.ShapeList"/>
</f></shapesInCircle>
		<bodiesInAABB public="1" set="method" line="2277" override="1"><f a="aabb:strict:containment:filter:output">
	<c path="zpp_nape.geom.ZPP_AABB"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></bodiesInAABB>
		<failed public="1"><c path="nape.phys.BodyList"/></failed>
		<shapesInAABB public="1" set="method" line="2133" override="1"><f a="aabb:strict:containment:filter:output">
	<c path="zpp_nape.geom.ZPP_AABB"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.shape.ShapeList"/>
	<c path="nape.shape.ShapeList"/>
</f></shapesInAABB>
		<treeStack2 public="1"><c path="zpp_nape.util.ZNPList_ZPP_AABBNode"/></treeStack2>
		<bodiesUnderPoint public="1" set="method" line="2029" override="1"><f a="x:y:filter:output">
	<x path="Float"/>
	<x path="Float"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></bodiesUnderPoint>
		<shapesUnderPoint public="1" set="method" line="1932" override="1"><f a="x:y:filter:output">
	<x path="Float"/>
	<x path="Float"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.shape.ShapeList"/>
	<c path="nape.shape.ShapeList"/>
</f></shapesUnderPoint>
		<treeStack><c path="zpp_nape.util.ZNPList_ZPP_AABBNode"/></treeStack>
		<clear public="1" set="method" line="1882" override="1"><f a=""><x path="Void"/></f></clear>
		<broadphase public="1" set="method" line="1106" override="1"><f a="space:discrete">
	<c path="zpp_nape.space.ZPP_Space"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></broadphase>
		<sync_broadphase public="1" set="method" line="986"><f a=""><x path="Void"/></f></sync_broadphase>
		<__sync public="1" get="inline" set="null" line="944"><f a="shape">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></__sync>
		<__remove public="1" set="method" line="777"><f a="shape">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></__remove>
		<__insert public="1" set="method" line="717"><f a="shape">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></__insert>
		<dyn public="1" get="inline" set="null" line="713"><f a="shape">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
</f></dyn>
		<moves public="1"><c path="zpp_nape.space.ZPP_AABBNode"/></moves>
		<syncs public="1"><c path="zpp_nape.space.ZPP_AABBNode"/></syncs>
		<pairs public="1"><c path="zpp_nape.space.ZPP_AABBPair"/></pairs>
		<dtree public="1"><c path="zpp_nape.space.ZPP_AABBTree"/></dtree>
		<stree public="1"><c path="zpp_nape.space.ZPP_AABBTree"/></stree>
		<new public="1" set="method" line="704"><f a="space">
	<c path="zpp_nape.space.ZPP_Space"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="zpp_nape.space.ZPP_Island" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/space/Space.hx" module="zpp_nape.space.Space">
		<zpp_pool public="1" line="533" static="1"><c path="zpp_nape.space.ZPP_Island"/></zpp_pool>
		<alloc public="1" get="inline" set="null" line="571"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="559"><f a=""><x path="Void"/></f></free>
		<waket public="1"><x path="Int"/></waket>
		<sleep public="1"><x path="Bool"/></sleep>
		<comps public="1"><c path="zpp_nape.util.ZNPList_ZPP_Component"/></comps>
		<at public="1" set="method" line="518"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.space.ZPP_Island"/>
</f></at>
		<iterator_at public="1" set="method" line="505"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.space.ZPP_Island"/>
</f></iterator_at>
		<back public="1" set="method" line="496"><f a=""><c path="zpp_nape.space.ZPP_Island"/></f></back>
		<front public="1" get="inline" set="null" line="493"><f a=""><c path="zpp_nape.space.ZPP_Island"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="463"><f a="obj">
	<c path="zpp_nape.space.ZPP_Island"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="458"><f a="obj">
	<c path="zpp_nape.space.ZPP_Island"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="455"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="450"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="435"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="429"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="424"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="420"><f a="pre:n">
	<c path="zpp_nape.space.ZPP_Island"/>
	<x path="Int"/>
	<c path="zpp_nape.space.ZPP_Island"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="388"><f a="pre">
	<c path="zpp_nape.space.ZPP_Island"/>
	<c path="zpp_nape.space.ZPP_Island"/>
</f></inlined_erase>
		<erase public="1" set="method" line="383"><f a="pre">
	<c path="zpp_nape.space.ZPP_Island"/>
	<c path="zpp_nape.space.ZPP_Island"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="360"><f a="obj">
	<c path="zpp_nape.space.ZPP_Island"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="347"><f a="obj">
	<c path="zpp_nape.space.ZPP_Island"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="322"><f a="obj">
	<c path="zpp_nape.space.ZPP_Island"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="311"><f a="obj">
	<c path="zpp_nape.space.ZPP_Island"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="298"><f a=""><c path="zpp_nape.space.ZPP_Island"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="293"><f a=""><c path="zpp_nape.space.ZPP_Island"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="274"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="269"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="244"><f a="cur:o">
	<c path="zpp_nape.space.ZPP_Island"/>
	<c path="zpp_nape.space.ZPP_Island"/>
	<c path="zpp_nape.space.ZPP_Island"/>
</f></inlined_insert>
		<insert public="1" set="method" line="239"><f a="cur:o">
	<c path="zpp_nape.space.ZPP_Island"/>
	<c path="zpp_nape.space.ZPP_Island"/>
	<c path="zpp_nape.space.ZPP_Island"/>
</f></insert>
		<addAll public="1" set="method" line="221"><f a="x">
	<c path="zpp_nape.space.ZPP_Island"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="202"><f a="o">
	<c path="zpp_nape.space.ZPP_Island"/>
	<c path="zpp_nape.space.ZPP_Island"/>
</f></inlined_add>
		<add public="1" set="method" line="197"><f a="o">
	<c path="zpp_nape.space.ZPP_Island"/>
	<c path="zpp_nape.space.ZPP_Island"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="192"><f a="i">
	<c path="zpp_nape.space.ZPP_Island"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<_inuse public="1"><x path="Bool"/></_inuse>
		<begin public="1" get="inline" set="null" line="183"><f a=""><c path="zpp_nape.space.ZPP_Island"/></f></begin>
		<elem public="1" get="inline" set="null" line="178"><f a=""><c path="zpp_nape.space.ZPP_Island"/></f></elem>
		<next public="1"><c path="zpp_nape.space.ZPP_Island"/></next>
		<new public="1" set="method" line="574"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.space.ZPP_Component" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/space/Space.hx" module="zpp_nape.space.Space">
		<zpp_pool public="1" line="581" static="1"><c path="zpp_nape.space.ZPP_Component"/></zpp_pool>
		<reset public="1" get="inline" set="null" line="637"><f a=""><x path="Void"/></f></reset>
		<alloc public="1" get="inline" set="null" line="630"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="616"><f a=""><x path="Void"/></f></free>
		<woken public="1"><x path="Bool"/></woken>
		<waket public="1"><x path="Int"/></waket>
		<sleeping public="1"><x path="Bool"/></sleeping>
		<island public="1"><c path="zpp_nape.space.ZPP_Island"/></island>
		<constraint public="1"><c path="zpp_nape.constraint.ZPP_Constraint"/></constraint>
		<body public="1"><c path="zpp_nape.phys.ZPP_Body"/></body>
		<isBody public="1"><x path="Bool"/></isBody>
		<rank public="1"><x path="Int"/></rank>
		<parent public="1"><c path="zpp_nape.space.ZPP_Component"/></parent>
		<next public="1"><c path="zpp_nape.space.ZPP_Component"/></next>
		<new public="1" set="method" line="631"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.space.ZPP_CallbackSet" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/space/Space.hx" module="zpp_nape.space.Space">
		<get public="1" set="method" line="650" static="1"><f a="i1:i2">
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
</f></get>
		<zpp_pool public="1" line="1059" static="1"><c path="zpp_nape.space.ZPP_CallbackSet"/></zpp_pool>
		<sleeping public="1" get="inline" set="null" line="1163"><f a=""><x path="Bool"/></f></sleeping>
		<really_empty public="1" get="inline" set="null" line="1158"><f a=""><x path="Bool"/></f></really_empty>
		<empty_arb public="1" set="method" line="1130"><f a="type">
	<x path="Int"/>
	<x path="Bool"/>
</f></empty_arb>
		<remove_arb public="1" set="method" line="1127"><f a="x">
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
	<x path="Void"/>
</f></remove_arb>
		<try_remove_arb public="1" set="method" line="1124"><f a="x">
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
	<x path="Bool"/>
</f></try_remove_arb>
		<add_arb public="1" get="inline" set="null" line="1117"><f a="x">
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
	<x path="Bool"/>
</f></add_arb>
		<alloc public="1" get="inline" set="null" line="1102"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="1087"><f a=""><x path="Void"/></f></free>
		<lazydel public="1"><x path="Bool"/></lazydel>
		<freed public="1"><x path="Bool"/></freed>
		<at public="1" set="method" line="1047"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
</f></at>
		<iterator_at public="1" set="method" line="1034"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
</f></iterator_at>
		<back public="1" set="method" line="1025"><f a=""><c path="zpp_nape.space.ZPP_CallbackSet"/></f></back>
		<front public="1" get="inline" set="null" line="1022"><f a=""><c path="zpp_nape.space.ZPP_CallbackSet"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="992"><f a="obj">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="987"><f a="obj">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="984"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="979"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="964"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="958"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="953"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="949"><f a="pre:n">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<x path="Int"/>
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="917"><f a="pre">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
</f></inlined_erase>
		<erase public="1" set="method" line="912"><f a="pre">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="889"><f a="obj">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="876"><f a="obj">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="851"><f a="obj">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="840"><f a="obj">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="827"><f a=""><c path="zpp_nape.space.ZPP_CallbackSet"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="822"><f a=""><c path="zpp_nape.space.ZPP_CallbackSet"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="803"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="798"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="773"><f a="cur:o">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
</f></inlined_insert>
		<insert public="1" set="method" line="768"><f a="cur:o">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
</f></insert>
		<addAll public="1" set="method" line="750"><f a="x">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="731"><f a="o">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
</f></inlined_add>
		<add public="1" set="method" line="726"><f a="o">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="721"><f a="i">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<_inuse public="1"><x path="Bool"/></_inuse>
		<begin public="1" get="inline" set="null" line="712"><f a=""><c path="zpp_nape.space.ZPP_CallbackSet"/></f></begin>
		<elem public="1" get="inline" set="null" line="707"><f a=""><c path="zpp_nape.space.ZPP_CallbackSet"/></f></elem>
		<next public="1"><c path="zpp_nape.space.ZPP_CallbackSet"/></next>
		<FLUIDstamp public="1"><x path="Int"/></FLUIDstamp>
		<FLUIDstate public="1"><x path="Int"/></FLUIDstate>
		<SENSORstamp public="1"><x path="Int"/></SENSORstamp>
		<SENSORstate public="1"><x path="Int"/></SENSORstate>
		<COLLISIONstamp public="1"><x path="Int"/></COLLISIONstamp>
		<COLLISIONstate public="1"><x path="Int"/></COLLISIONstate>
		<arbiters public="1"><c path="zpp_nape.util.ZNPList_ZPP_Arbiter"/></arbiters>
		<int2 public="1"><c path="zpp_nape.phys.ZPP_Interactor"/></int2>
		<int1 public="1"><c path="zpp_nape.phys.ZPP_Interactor"/></int1>
		<di public="1"><x path="Int"/></di>
		<id public="1"><x path="Int"/></id>
		<new public="1" set="method" line="1113"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.space.ZPP_CbSetManager" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/space/Space.hx" module="zpp_nape.space.Space">
		<valid_listener public="1" get="inline" set="null" line="1374"><f a="i">
	<c path="zpp_nape.callbacks.ZPP_Listener"/>
	<x path="Bool"/>
</f></valid_listener>
		<pair public="1" get="inline" set="null" line="1348"><f a="a:b">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
</f></pair>
		<validate public="1" get="inline" set="null" line="1318"><f a=""><x path="Void"/></f></validate>
		<clear public="1" set="method" line="1285"><f a=""><x path="Void"/></f></clear>
		<remove public="1" set="method" line="1253"><f a="set">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<x path="Void"/>
</f></remove>
		<get public="1" set="method" line="1194"><f a="cbTypes">
	<c path="zpp_nape.util.ZNPList_ZPP_CbType"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
</f></get>
		<space public="1"><c path="zpp_nape.space.ZPP_Space"/></space>
		<cbsets public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_CbSet"/></cbsets>
		<new public="1" set="method" line="1295"><f a="space">
	<c path="zpp_nape.space.ZPP_Space"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="zpp_nape.space.ZPP_Space" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/space/Space.hx" module="zpp_nape.space.Space">
		<inlined_MRCA_chains public="1" get="inline" set="null" line="7220"><f a="s1:s2">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></inlined_MRCA_chains>
		<MRCA_chains public="1" set="method" line="7215"><f a="s1:s2">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></MRCA_chains>
		<mrca2 public="1"><c path="zpp_nape.util.ZNPList_ZPP_Interactor"/></mrca2>
		<mrca1 public="1"><c path="zpp_nape.util.ZNPList_ZPP_Interactor"/></mrca1>
		<narrowPhase public="1" set="method" line="5860"><f a="s1:s2:stat:in_arb:continuous">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
</f></narrowPhase>
		<prelisteners><c path="zpp_nape.util.ZNPList_ZPP_InteractionListener"/></prelisteners>
		<precb><c path="nape.callbacks.PreCallback"/></precb>
		<interactionType public="1" get="inline" set="null" line="5810"><f a="s1:s2:b1:b2">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Int"/>
</f></interactionType>
		<group_ignore public="1" get="inline" set="null" line="5788"><f a="s1:s2">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
</f></group_ignore>
		<iteratePos public="1" set="method" line="5731"><f a="times">
	<x path="Int"/>
	<x path="Void"/>
</f></iteratePos>
		<iterateVel public="1" set="method" line="5674"><f a="times">
	<x path="Int"/>
	<x path="Void"/>
</f></iterateVel>
		<warmStart public="1" set="method" line="5637"><f a=""><x path="Void"/></f></warmStart>
		<prestep public="1" set="method" line="5492"><f a="dt">
	<x path="Float"/>
	<x path="Void"/>
</f></prestep>
		<presteparb public="1" set="method" line="5348"><f a="arb:dt:?cont">
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></presteparb>
		<continuous public="1"><x path="Bool"/></continuous>
		<updatePos public="1" set="method" line="5158"><f a="dt">
	<x path="Float"/>
	<x path="Void"/>
</f></updatePos>
		<updateVel public="1" set="method" line="5128"><f a="dt">
	<x path="Float"/>
	<x path="Void"/>
</f></updateVel>
		<validation public="1" set="method" line="4936"><f a=""><x path="Void"/></f></validation>
		<static_validation public="1" set="method" line="4906"><f a="body">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Void"/>
</f></static_validation>
		<sleepArbiters public="1" set="method" line="4757"><f a=""><x path="Void"/></f></sleepArbiters>
		<doForests public="1" set="method" line="4467"><f a="dt">
	<x path="Float"/>
	<x path="Void"/>
</f></doForests>
		<wake_constraint public="1" set="method" line="4424"><f a="con:?fst">
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></wake_constraint>
		<really_wake public="1" set="method" line="4315"><f a="o:?fst">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></really_wake>
		<non_inlined_wake public="1" set="method" line="4287"><f a="o:?fst">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></non_inlined_wake>
		<wakeIsland public="1" set="method" line="4184"><f a="i">
	<c path="zpp_nape.space.ZPP_Island"/>
	<x path="Void"/>
</f></wakeIsland>
		<wakeCompound public="1" set="method" line="4133"><f a="x">
	<c path="zpp_nape.phys.ZPP_Compound"/>
	<x path="Void"/>
</f></wakeCompound>
		<freshInteractorType public="1" set="method" line="4045"><f a="intx:?me">
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<x path="Void"/>
</f></freshInteractorType>
		<freshListenerType public="1" set="method" line="3948"><f a="cb1:cb2">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<x path="Void"/>
</f></freshListenerType>
		<nullInteractorType public="1" set="method" line="3866"><f a="intx:?me">
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<x path="Void"/>
</f></nullInteractorType>
		<nullListenerType public="1" set="method" line="3757"><f a="cb1:cb2">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<x path="Void"/>
</f></nullListenerType>
		<constraintCbBreak public="1" set="method" line="3737"><f a="con">
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
	<x path="Void"/>
</f></constraintCbBreak>
		<constraintCbSleep public="1" set="method" line="3717"><f a="con">
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
	<x path="Void"/>
</f></constraintCbSleep>
		<constraintCbWake public="1" set="method" line="3694"><f a="con">
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
	<x path="Void"/>
</f></constraintCbWake>
		<bodyCbSleep public="1" set="method" line="3674"><f a="b">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Void"/>
</f></bodyCbSleep>
		<bodyCbWake public="1" set="method" line="3651"><f a="b">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Void"/>
</f></bodyCbWake>
		<continuousEvent public="1" set="method" line="3565"><f a="s1:s2:stat:in_arb:_">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
</f></continuousEvent>
		<continuousCollisions public="1" set="method" line="3355"><f a="deltaTime">
	<x path="Float"/>
	<x path="Void"/>
</f></continuousCollisions>
		<toiEvents public="1"><c path="zpp_nape.util.ZNPList_ZPP_ToiEvent"/></toiEvents>
		<step public="1" set="method" line="3014"><f a="deltaTime:velocityIterations:positionIterations">
	<x path="Float"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></step>
		<pre_dt public="1"><x path="Float"/></pre_dt>
		<push_callback public="1" set="method" line="2982"><f a="i">
	<c path="zpp_nape.callbacks.ZPP_Listener"/>
	<c path="zpp_nape.callbacks.ZPP_Callback"/>
</f></push_callback>
		<convexMultiCast public="1" set="method" line="2837"><f a="shape:deltaTime:filter:dynamics:output">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Float"/>
	<c path="nape.dynamics.InteractionFilter"/>
	<x path="Bool"/>
	<c path="nape.geom.ConvexResultList"/>
	<c path="nape.geom.ConvexResultList"/>
</f></convexMultiCast>
		<prepareCast get="inline" set="null" line="2833"><f a="s">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></prepareCast>
		<convexCast public="1" set="method" line="2612"><f a="shape:deltaTime:filter:dynamics">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Float"/>
	<c path="nape.dynamics.InteractionFilter"/>
	<x path="Bool"/>
	<c path="nape.geom.ConvexResult"/>
</f></convexCast>
		<convexShapeList><c path="nape.shape.ShapeList"/></convexShapeList>
		<rayMultiCast public="1" set="method" line="2608"><f a="ray:inner:filter:output">
	<c path="nape.geom.Ray"/>
	<x path="Bool"/>
	<c path="nape.dynamics.InteractionFilter"/>
	<c path="nape.geom.RayResultList"/>
	<c path="nape.geom.RayResultList"/>
</f></rayMultiCast>
		<rayCast public="1" set="method" line="2605"><f a="ray:inner:filter">
	<c path="nape.geom.Ray"/>
	<x path="Bool"/>
	<c path="nape.dynamics.InteractionFilter"/>
	<c path="nape.geom.RayResult"/>
</f></rayCast>
		<bodiesInShape public="1" set="method" line="2602"><f a="shape:cont:filter:output">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></bodiesInShape>
		<shapesInShape public="1" set="method" line="2599"><f a="shape:cont:filter:output">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.shape.ShapeList"/>
	<c path="nape.shape.ShapeList"/>
</f></shapesInShape>
		<bodiesInCircle public="1" set="method" line="2596"><f a="pos:rad:cont:filter:output">
	<c path="nape.geom.Vec2"/>
	<x path="Float"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></bodiesInCircle>
		<shapesInCircle public="1" set="method" line="2593"><f a="pos:rad:cont:filter:output">
	<c path="nape.geom.Vec2"/>
	<x path="Float"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.shape.ShapeList"/>
	<c path="nape.shape.ShapeList"/>
</f></shapesInCircle>
		<bodiesInAABB public="1" set="method" line="2590"><f a="aabb:strict:cont:filter:output">
	<c path="nape.geom.AABB"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></bodiesInAABB>
		<shapesInAABB public="1" set="method" line="2587"><f a="aabb:strict:cont:filter:output">
	<c path="nape.geom.AABB"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.shape.ShapeList"/>
	<c path="nape.shape.ShapeList"/>
</f></shapesInAABB>
		<bodiesUnderPoint public="1" set="method" line="2584"><f a="x:y:filter:output">
	<x path="Float"/>
	<x path="Float"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></bodiesUnderPoint>
		<shapesUnderPoint public="1" set="method" line="2581"><f a="x:y:filter:output">
	<x path="Float"/>
	<x path="Float"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.shape.ShapeList"/>
	<c path="nape.shape.ShapeList"/>
</f></shapesUnderPoint>
		<remBody public="1" set="method" line="2439"><f a="body:?flag">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Int"/>
	<x path="Void"/>
</f></remBody>
		<addBody public="1" set="method" line="2358"><f a="body:?flag">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Int"/>
	<x path="Void"/>
</f></addBody>
		<remCompound public="1" set="method" line="2330"><f a="x">
	<c path="zpp_nape.phys.ZPP_Compound"/>
	<x path="Void"/>
</f></remCompound>
		<addCompound public="1" set="method" line="2302"><f a="x">
	<c path="zpp_nape.phys.ZPP_Compound"/>
	<x path="Void"/>
</f></addCompound>
		<remConstraint public="1" set="method" line="2294"><f a="con">
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
	<x path="Void"/>
</f></remConstraint>
		<addConstraint public="1" set="method" line="2278"><f a="con">
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
	<x path="Void"/>
</f></addConstraint>
		<removed_shape public="1" set="method" line="2134"><f a="s:?deleting">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></removed_shape>
		<added_shape public="1" get="inline" set="null" line="2102"><f a="s:?dontwake">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></added_shape>
		<transmitType public="1" set="method" line="2033"><f a="p:new_type">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Int"/>
	<x path="Void"/>
</f></transmitType>
		<remove_callbackset public="1" set="method" line="2028"><f a="cb">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<x path="Void"/>
</f></remove_callbackset>
		<add_callbackset public="1" set="method" line="2015"><f a="cb">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<x path="Void"/>
</f></add_callbackset>
		<remListener public="1" set="method" line="2008"><f a="x">
	<c path="zpp_nape.callbacks.ZPP_Listener"/>
	<x path="Void"/>
</f></remListener>
		<addListener public="1" set="method" line="2001"><f a="x">
	<c path="zpp_nape.callbacks.ZPP_Listener"/>
	<x path="Void"/>
</f></addListener>
		<unrevoke_listener public="1" get="inline" set="null" line="2000"><f a="x">
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
	<x path="Void"/>
</f></unrevoke_listener>
		<revoke_listener public="1" get="inline" set="null" line="1997"><f a="x">
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
	<x path="Void"/>
</f></revoke_listener>
		<listeners_modifiable set="method" line="1884"><f a=""><x path="Void"/></f></listeners_modifiable>
		<listeners_subber set="method" line="1880"><f a="x">
	<c path="nape.callbacks.Listener"/>
	<x path="Void"/>
</f></listeners_subber>
		<listeners_adder set="method" line="1872"><f a="x">
	<c path="nape.callbacks.Listener"/>
	<x path="Bool"/>
</f></listeners_adder>
		<constraints_modifiable set="method" line="1868"><f a=""><x path="Void"/></f></constraints_modifiable>
		<constraints_subber set="method" line="1864"><f a="x">
	<c path="nape.constraint.Constraint"/>
	<x path="Void"/>
</f></constraints_subber>
		<constraints_adder set="method" line="1853"><f a="x">
	<c path="nape.constraint.Constraint"/>
	<x path="Bool"/>
</f></constraints_adder>
		<compounds_modifiable set="method" line="1849"><f a=""><x path="Void"/></f></compounds_modifiable>
		<compounds_subber set="method" line="1845"><f a="x">
	<c path="nape.phys.Compound"/>
	<x path="Void"/>
</f></compounds_subber>
		<compounds_adder set="method" line="1834"><f a="x">
	<c path="nape.phys.Compound"/>
	<x path="Bool"/>
</f></compounds_adder>
		<bodies_modifiable set="method" line="1830"><f a=""><x path="Void"/></f></bodies_modifiable>
		<bodies_subber set="method" line="1826"><f a="x">
	<c path="nape.phys.Body"/>
	<x path="Void"/>
</f></bodies_subber>
		<bodies_adder set="method" line="1815"><f a="x">
	<c path="nape.phys.Body"/>
	<x path="Bool"/>
</f></bodies_adder>
		<clear public="1" set="method" line="1556"><f a=""><x path="Void"/></f></clear>
		<cbsets public="1"><c path="zpp_nape.space.ZPP_CbSetManager"/></cbsets>
		<callbackset_list public="1"><c path="zpp_nape.space.ZPP_CallbackSet"/></callbackset_list>
		<callbacks public="1"><c path="zpp_nape.callbacks.ZPP_Callback"/></callbacks>
		<wrap_listeners public="1"><c path="nape.callbacks.ListenerList"/></wrap_listeners>
		<listeners public="1"><c path="zpp_nape.util.ZNPList_ZPP_Listener"/></listeners>
		<islands public="1"><c path="zpp_nape.space.ZPP_Island"/></islands>
		<staticsleep public="1"><c path="zpp_nape.util.ZNPList_ZPP_Body"/></staticsleep>
		<wrap_livecon public="1"><c path="nape.constraint.ConstraintList"/></wrap_livecon>
		<live_constraints public="1"><c path="zpp_nape.util.ZNPList_ZPP_Constraint"/></live_constraints>
		<wrap_live public="1"><c path="nape.phys.BodyList"/></wrap_live>
		<live public="1"><c path="zpp_nape.util.ZNPList_ZPP_Body"/></live>
		<wrap_arbiters public="1"><c path="nape.dynamics.ArbiterList"/></wrap_arbiters>
		<s_arbiters public="1"><c path="zpp_nape.util.ZNPList_ZPP_SensorArbiter"/></s_arbiters>
		<f_arbiters public="1"><c path="zpp_nape.util.ZNPList_ZPP_FluidArbiter"/></f_arbiters>
		<c_arbiters_false public="1"><c path="zpp_nape.util.ZNPList_ZPP_ColArbiter"/></c_arbiters_false>
		<c_arbiters_true public="1"><c path="zpp_nape.util.ZNPList_ZPP_ColArbiter"/></c_arbiters_true>
		<sortcontacts public="1"><x path="Bool"/></sortcontacts>
		<time public="1"><x path="Float"/></time>
		<midstep public="1"><x path="Bool"/></midstep>
		<stamp public="1"><x path="Int"/></stamp>
		<global_ang_drag public="1"><x path="Float"/></global_ang_drag>
		<global_lin_drag public="1"><x path="Float"/></global_lin_drag>
		<__static public="1"><c path="nape.phys.Body"/></__static>
		<bphase public="1"><c path="zpp_nape.space.ZPP_Broadphase"/></bphase>
		<kinematics public="1"><c path="zpp_nape.util.ZNPList_ZPP_Body"/></kinematics>
		<wrap_constraints public="1"><c path="nape.constraint.ConstraintList"/></wrap_constraints>
		<constraints public="1"><c path="zpp_nape.util.ZNPList_ZPP_Constraint"/></constraints>
		<wrap_compounds public="1"><c path="nape.phys.CompoundList"/></wrap_compounds>
		<compounds public="1"><c path="zpp_nape.util.ZNPList_ZPP_Compound"/></compounds>
		<wrap_bodies public="1"><c path="nape.phys.BodyList"/></wrap_bodies>
		<bodies public="1"><c path="zpp_nape.util.ZNPList_ZPP_Body"/></bodies>
		<gravity_validate set="method" line="1502"><f a=""><x path="Void"/></f></gravity_validate>
		<gravity_invalidate set="method" line="1391"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></gravity_invalidate>
		<getgravity public="1" set="method" line="1385"><f a=""><x path="Void"/></f></getgravity>
		<wrap_gravity public="1"><c path="nape.geom.Vec2"/></wrap_gravity>
		<gravityy public="1"><x path="Float"/></gravityy>
		<gravityx public="1"><x path="Float"/></gravityx>
		<userData public="1"><d><d/></d></userData>
		<outer public="1"><c path="nape.space.Space"/></outer>
		<new public="1" set="method" line="1888"><f a="gravity:broadphase">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<c path="nape.space.Broadphase"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="zpp_nape.space.ZPP_SweepData" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/space/SweepPhase.hx" module="zpp_nape.space.SweepPhase">
		<zpp_pool public="1" line="176" static="1"><c path="zpp_nape.space.ZPP_SweepData"/></zpp_pool>
		<gt public="1" get="inline" set="null" line="216"><f a="x">
	<c path="zpp_nape.space.ZPP_SweepData"/>
	<x path="Bool"/>
</f></gt>
		<alloc public="1" get="inline" set="null" line="212"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="205"><f a=""><x path="Void"/></f></free>
		<aabb public="1"><c path="zpp_nape.geom.ZPP_AABB"/></aabb>
		<shape public="1"><c path="zpp_nape.shape.ZPP_Shape"/></shape>
		<prev public="1"><c path="zpp_nape.space.ZPP_SweepData"/></prev>
		<next public="1"><c path="zpp_nape.space.ZPP_SweepData"/></next>
		<new public="1" set="method" line="213"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.space.ZPP_SweepPhase" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/space/SweepPhase.hx" module="zpp_nape.space.SweepPhase">
		<extends path="zpp_nape.space.ZPP_Broadphase"/>
		<rayMultiCast public="1" set="method" line="745" override="1"><f a="ray:inner:filter:output">
	<c path="zpp_nape.geom.ZPP_Ray"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.geom.RayResultList"/>
	<c path="nape.geom.RayResultList"/>
</f></rayMultiCast>
		<rayCast public="1" set="method" line="657" override="1"><f a="ray:inner:filter">
	<c path="zpp_nape.geom.ZPP_Ray"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.geom.RayResult"/>
</f></rayCast>
		<bodiesInShape public="1" set="method" line="624" override="1"><f a="shape:containment:filter:output">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></bodiesInShape>
		<shapesInShape public="1" set="method" line="603" override="1"><f a="shape:containment:filter:output">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.shape.ShapeList"/>
	<c path="nape.shape.ShapeList"/>
</f></shapesInShape>
		<bodiesInCircle public="1" set="method" line="570" override="1"><f a="x:y:r:containment:filter:output">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></bodiesInCircle>
		<shapesInCircle public="1" set="method" line="549" override="1"><f a="x:y:r:containment:filter:output">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.shape.ShapeList"/>
	<c path="nape.shape.ShapeList"/>
</f></shapesInCircle>
		<bodiesInAABB public="1" set="method" line="499" override="1"><f a="aabb:strict:containment:filter:output">
	<c path="zpp_nape.geom.ZPP_AABB"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></bodiesInAABB>
		<failed public="1"><c path="nape.phys.BodyList"/></failed>
		<shapesInAABB public="1" set="method" line="471" override="1"><f a="aabb:strict:containment:filter:output">
	<c path="zpp_nape.geom.ZPP_AABB"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.shape.ShapeList"/>
	<c path="nape.shape.ShapeList"/>
</f></shapesInAABB>
		<bodiesUnderPoint public="1" set="method" line="429" override="1"><f a="x:y:filter:output">
	<x path="Float"/>
	<x path="Float"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></bodiesUnderPoint>
		<shapesUnderPoint public="1" set="method" line="390" override="1"><f a="x:y:filter:output">
	<x path="Float"/>
	<x path="Float"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.shape.ShapeList"/>
	<c path="nape.shape.ShapeList"/>
</f></shapesUnderPoint>
		<clear public="1" set="method" line="384" override="1"><f a=""><x path="Void"/></f></clear>
		<broadphase public="1" set="method" line="345" override="1"><f a="space:discrete">
	<c path="zpp_nape.space.ZPP_Space"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></broadphase>
		<sync_broadphase_fast public="1" get="inline" set="null" line="313"><f a=""><x path="Void"/></f></sync_broadphase_fast>
		<sync_broadphase public="1" set="method" line="307"><f a=""><x path="Void"/></f></sync_broadphase>
		<__sync public="1" get="inline" set="null" line="296"><f a="shape">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></__sync>
		<__remove public="1" set="method" line="262"><f a="shape">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></__remove>
		<__insert public="1" set="method" line="228"><f a="shape">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></__insert>
		<list public="1"><c path="zpp_nape.space.ZPP_SweepData"/></list>
		<new public="1" set="method" line="223"><f a="space">
	<c path="zpp_nape.space.ZPP_Space"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="zpp_nape.util.ZNPArray2_Float" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Array2.hx" module="zpp_nape.util.Array2">
		<set public="1" get="inline" set="null" line="222"><f a="x:y:obj">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set>
		<get public="1" get="inline" set="null" line="209"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
</f></get>
		<resize public="1" set="method" line="191"><f a="width:height:def">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></resize>
		<width public="1"><x path="Int"/></width>
		<list public="1"><t path="nape.TArray"><x path="Float"/></t></list>
		<new public="1" set="method" line="182"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="zpp_nape.util.ZNPArray2_ZPP_GeomVert" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Array2.hx" module="zpp_nape.util.Array2">
		<set public="1" get="inline" set="null" line="282"><f a="x:y:obj">
	<x path="Int"/>
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
</f></set>
		<get public="1" get="inline" set="null" line="269"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
</f></get>
		<resize public="1" set="method" line="251"><f a="width:height:def">
	<x path="Int"/>
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<x path="Void"/>
</f></resize>
		<width public="1"><x path="Int"/></width>
		<list public="1"><t path="nape.TArray"><c path="zpp_nape.geom.ZPP_GeomVert"/></t></list>
		<new public="1" set="method" line="242"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="zpp_nape.util.ZNPArray2_ZPP_MarchPair" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Array2.hx" module="zpp_nape.util.Array2">
		<set public="1" get="inline" set="null" line="342"><f a="x:y:obj">
	<x path="Int"/>
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_MarchPair"/>
	<c path="zpp_nape.geom.ZPP_MarchPair"/>
</f></set>
		<get public="1" get="inline" set="null" line="329"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_MarchPair"/>
</f></get>
		<resize public="1" set="method" line="311"><f a="width:height:def">
	<x path="Int"/>
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_MarchPair"/>
	<x path="Void"/>
</f></resize>
		<width public="1"><x path="Int"/></width>
		<list public="1"><t path="nape.TArray"><c path="zpp_nape.geom.ZPP_MarchPair"/></t></list>
		<new public="1" set="method" line="302"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="zpp_nape.util.Hashable2_Boolfalse" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/FastHash.hx" module="zpp_nape.util.FastHash">
		<zpp_pool public="1" line="179" static="1"><c path="zpp_nape.util.Hashable2_Boolfalse"/></zpp_pool>
		<get public="1" get="inline" set="null" line="214" static="1"><f a="id:di:val">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<c path="zpp_nape.util.Hashable2_Boolfalse"/>
</f></get>
		<getpersist public="1" get="inline" set="null" line="220" static="1"><f a="id:di">
	<x path="Int"/>
	<x path="Int"/>
	<c path="zpp_nape.util.Hashable2_Boolfalse"/>
</f></getpersist>
		<ordered_get public="1" get="inline" set="null" line="244" static="1"><f a="id:di:val">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<c path="zpp_nape.util.Hashable2_Boolfalse"/>
</f></ordered_get>
		<ordered_get_persist public="1" get="inline" set="null" line="248" static="1"><f a="id:di">
	<x path="Int"/>
	<x path="Int"/>
	<c path="zpp_nape.util.Hashable2_Boolfalse"/>
</f></ordered_get_persist>
		<alloc public="1" get="inline" set="null" line="211"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="208"><f a=""><x path="Void"/></f></free>
		<di public="1"><x path="Int"/></di>
		<id public="1"><x path="Int"/></id>
		<hnext public="1"><c path="zpp_nape.util.Hashable2_Boolfalse"/></hnext>
		<next public="1"><c path="zpp_nape.util.Hashable2_Boolfalse"/></next>
		<value public="1"><x path="Bool"/></value>
		<new set="method" line="212"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.FastHash2_Hashable2_Boolfalse" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/FastHash.hx" module="zpp_nape.util.FastHash">
		<hash public="1" get="inline" set="null" line="416"><f a="id:di">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></hash>
		<remove public="1" set="method" line="382"><f a="arb">
	<c path="zpp_nape.util.Hashable2_Boolfalse"/>
	<x path="Void"/>
</f></remove>
		<add public="1" set="method" line="350"><f a="arb">
	<c path="zpp_nape.util.Hashable2_Boolfalse"/>
	<x path="Void"/>
</f></add>
		<maybeAdd public="1" set="method" line="316"><f a="arb">
	<c path="zpp_nape.util.Hashable2_Boolfalse"/>
	<x path="Void"/>
</f></maybeAdd>
		<has public="1" set="method" line="307"><f a="id:di">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></has>
		<ordered_get public="1" get="inline" set="null" line="299"><f a="id:di">
	<x path="Int"/>
	<x path="Int"/>
	<c path="zpp_nape.util.Hashable2_Boolfalse"/>
</f></ordered_get>
		<get public="1" get="inline" set="null" line="288"><f a="id:di">
	<x path="Int"/>
	<x path="Int"/>
	<c path="zpp_nape.util.Hashable2_Boolfalse"/>
</f></get>
		<clear public="1" set="method" line="271"><f a=""><x path="Void"/></f></clear>
		<empty public="1" get="inline" set="null" line="268"><f a=""><x path="Bool"/></f></empty>
		<cnt public="1"><x path="Int"/></cnt>
		<table public="1"><t path="nape.TArray"><c path="zpp_nape.util.Hashable2_Boolfalse"/></t></table>
		<new public="1" set="method" line="259"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_Flags" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Flags.hx" module="zpp_nape.util.Flags">
		<internal public="1" line="175" static="1"><x path="Bool"/></internal>
		<id_ImmState_ACCEPT public="1" line="177" static="1"><x path="Int"/></id_ImmState_ACCEPT>
		<id_ImmState_IGNORE public="1" line="178" static="1"><x path="Int"/></id_ImmState_IGNORE>
		<id_ImmState_ALWAYS public="1" line="179" static="1"><x path="Int"/></id_ImmState_ALWAYS>
		<id_GravMassMode_DEFAULT public="1" line="180" static="1"><x path="Int"/></id_GravMassMode_DEFAULT>
		<id_GravMassMode_FIXED public="1" line="181" static="1"><x path="Int"/></id_GravMassMode_FIXED>
		<id_GravMassMode_SCALED public="1" line="182" static="1"><x path="Int"/></id_GravMassMode_SCALED>
		<id_InertiaMode_DEFAULT public="1" line="183" static="1"><x path="Int"/></id_InertiaMode_DEFAULT>
		<id_InertiaMode_FIXED public="1" line="184" static="1"><x path="Int"/></id_InertiaMode_FIXED>
		<id_MassMode_DEFAULT public="1" line="185" static="1"><x path="Int"/></id_MassMode_DEFAULT>
		<id_MassMode_FIXED public="1" line="186" static="1"><x path="Int"/></id_MassMode_FIXED>
		<id_BodyType_STATIC public="1" line="187" static="1"><x path="Int"/></id_BodyType_STATIC>
		<id_BodyType_DYNAMIC public="1" line="188" static="1"><x path="Int"/></id_BodyType_DYNAMIC>
		<id_BodyType_KINEMATIC public="1" line="189" static="1"><x path="Int"/></id_BodyType_KINEMATIC>
		<id_ListenerType_BODY public="1" line="190" static="1"><x path="Int"/></id_ListenerType_BODY>
		<id_PreFlag_ACCEPT public="1" line="191" static="1"><x path="Int"/></id_PreFlag_ACCEPT>
		<id_ListenerType_CONSTRAINT public="1" line="192" static="1"><x path="Int"/></id_ListenerType_CONSTRAINT>
		<id_PreFlag_IGNORE public="1" line="193" static="1"><x path="Int"/></id_PreFlag_IGNORE>
		<id_ListenerType_INTERACTION public="1" line="194" static="1"><x path="Int"/></id_ListenerType_INTERACTION>
		<id_PreFlag_ACCEPT_ONCE public="1" line="195" static="1"><x path="Int"/></id_PreFlag_ACCEPT_ONCE>
		<id_ListenerType_PRE public="1" line="196" static="1"><x path="Int"/></id_ListenerType_PRE>
		<id_PreFlag_IGNORE_ONCE public="1" line="197" static="1"><x path="Int"/></id_PreFlag_IGNORE_ONCE>
		<id_CbEvent_BEGIN public="1" line="198" static="1"><x path="Int"/></id_CbEvent_BEGIN>
		<id_InteractionType_COLLISION public="1" line="199" static="1"><x path="Int"/></id_InteractionType_COLLISION>
		<id_CbEvent_ONGOING public="1" line="200" static="1"><x path="Int"/></id_CbEvent_ONGOING>
		<id_InteractionType_SENSOR public="1" line="201" static="1"><x path="Int"/></id_InteractionType_SENSOR>
		<id_CbEvent_END public="1" line="202" static="1"><x path="Int"/></id_CbEvent_END>
		<id_InteractionType_FLUID public="1" line="203" static="1"><x path="Int"/></id_InteractionType_FLUID>
		<id_CbEvent_WAKE public="1" line="204" static="1"><x path="Int"/></id_CbEvent_WAKE>
		<id_CbEvent_SLEEP public="1" line="205" static="1"><x path="Int"/></id_CbEvent_SLEEP>
		<id_InteractionType_ANY public="1" line="206" static="1"><x path="Int"/></id_InteractionType_ANY>
		<id_CbEvent_BREAK public="1" line="207" static="1"><x path="Int"/></id_CbEvent_BREAK>
		<id_CbEvent_PRE public="1" line="208" static="1"><x path="Int"/></id_CbEvent_PRE>
		<id_Winding_UNDEFINED public="1" line="209" static="1"><x path="Int"/></id_Winding_UNDEFINED>
		<id_Winding_CLOCKWISE public="1" line="210" static="1"><x path="Int"/></id_Winding_CLOCKWISE>
		<id_Winding_ANTICLOCKWISE public="1" line="211" static="1"><x path="Int"/></id_Winding_ANTICLOCKWISE>
		<id_ValidationResult_VALID public="1" line="212" static="1"><x path="Int"/></id_ValidationResult_VALID>
		<id_ValidationResult_DEGENERATE public="1" line="213" static="1"><x path="Int"/></id_ValidationResult_DEGENERATE>
		<id_ValidationResult_CONCAVE public="1" line="214" static="1"><x path="Int"/></id_ValidationResult_CONCAVE>
		<id_ValidationResult_SELF_INTERSECTING public="1" line="215" static="1"><x path="Int"/></id_ValidationResult_SELF_INTERSECTING>
		<id_ShapeType_CIRCLE public="1" line="216" static="1"><x path="Int"/></id_ShapeType_CIRCLE>
		<id_ShapeType_POLYGON public="1" line="217" static="1"><x path="Int"/></id_ShapeType_POLYGON>
		<id_Broadphase_DYNAMIC_AABB_TREE public="1" line="218" static="1"><x path="Int"/></id_Broadphase_DYNAMIC_AABB_TREE>
		<id_Broadphase_SWEEP_AND_PRUNE public="1" line="219" static="1"><x path="Int"/></id_Broadphase_SWEEP_AND_PRUNE>
		<id_ArbiterType_COLLISION public="1" line="220" static="1"><x path="Int"/></id_ArbiterType_COLLISION>
		<id_ArbiterType_SENSOR public="1" line="221" static="1"><x path="Int"/></id_ArbiterType_SENSOR>
		<id_ArbiterType_FLUID public="1" line="222" static="1"><x path="Int"/></id_ArbiterType_FLUID>
		<GravMassMode_DEFAULT public="1" static="1"><c path="nape.phys.GravMassMode"/></GravMassMode_DEFAULT>
		<GravMassMode_FIXED public="1" static="1"><c path="nape.phys.GravMassMode"/></GravMassMode_FIXED>
		<GravMassMode_SCALED public="1" static="1"><c path="nape.phys.GravMassMode"/></GravMassMode_SCALED>
		<InertiaMode_DEFAULT public="1" static="1"><c path="nape.phys.InertiaMode"/></InertiaMode_DEFAULT>
		<InertiaMode_FIXED public="1" static="1"><c path="nape.phys.InertiaMode"/></InertiaMode_FIXED>
		<MassMode_DEFAULT public="1" static="1"><c path="nape.phys.MassMode"/></MassMode_DEFAULT>
		<MassMode_FIXED public="1" static="1"><c path="nape.phys.MassMode"/></MassMode_FIXED>
		<BodyType_STATIC public="1" static="1"><c path="nape.phys.BodyType"/></BodyType_STATIC>
		<BodyType_DYNAMIC public="1" static="1"><c path="nape.phys.BodyType"/></BodyType_DYNAMIC>
		<BodyType_KINEMATIC public="1" static="1"><c path="nape.phys.BodyType"/></BodyType_KINEMATIC>
		<ListenerType_BODY public="1" static="1"><c path="nape.callbacks.ListenerType"/></ListenerType_BODY>
		<PreFlag_ACCEPT public="1" static="1"><c path="nape.callbacks.PreFlag"/></PreFlag_ACCEPT>
		<ListenerType_CONSTRAINT public="1" static="1"><c path="nape.callbacks.ListenerType"/></ListenerType_CONSTRAINT>
		<PreFlag_IGNORE public="1" static="1"><c path="nape.callbacks.PreFlag"/></PreFlag_IGNORE>
		<ListenerType_INTERACTION public="1" static="1"><c path="nape.callbacks.ListenerType"/></ListenerType_INTERACTION>
		<PreFlag_ACCEPT_ONCE public="1" static="1"><c path="nape.callbacks.PreFlag"/></PreFlag_ACCEPT_ONCE>
		<ListenerType_PRE public="1" static="1"><c path="nape.callbacks.ListenerType"/></ListenerType_PRE>
		<PreFlag_IGNORE_ONCE public="1" static="1"><c path="nape.callbacks.PreFlag"/></PreFlag_IGNORE_ONCE>
		<CbEvent_BEGIN public="1" static="1"><c path="nape.callbacks.CbEvent"/></CbEvent_BEGIN>
		<InteractionType_COLLISION public="1" static="1"><c path="nape.callbacks.InteractionType"/></InteractionType_COLLISION>
		<CbEvent_ONGOING public="1" static="1"><c path="nape.callbacks.CbEvent"/></CbEvent_ONGOING>
		<InteractionType_SENSOR public="1" static="1"><c path="nape.callbacks.InteractionType"/></InteractionType_SENSOR>
		<CbEvent_END public="1" static="1"><c path="nape.callbacks.CbEvent"/></CbEvent_END>
		<InteractionType_FLUID public="1" static="1"><c path="nape.callbacks.InteractionType"/></InteractionType_FLUID>
		<CbEvent_WAKE public="1" static="1"><c path="nape.callbacks.CbEvent"/></CbEvent_WAKE>
		<CbEvent_SLEEP public="1" static="1"><c path="nape.callbacks.CbEvent"/></CbEvent_SLEEP>
		<InteractionType_ANY public="1" static="1"><c path="nape.callbacks.InteractionType"/></InteractionType_ANY>
		<CbEvent_BREAK public="1" static="1"><c path="nape.callbacks.CbEvent"/></CbEvent_BREAK>
		<CbEvent_PRE public="1" static="1"><c path="nape.callbacks.CbEvent"/></CbEvent_PRE>
		<Winding_UNDEFINED public="1" static="1"><c path="nape.geom.Winding"/></Winding_UNDEFINED>
		<Winding_CLOCKWISE public="1" static="1"><c path="nape.geom.Winding"/></Winding_CLOCKWISE>
		<Winding_ANTICLOCKWISE public="1" static="1"><c path="nape.geom.Winding"/></Winding_ANTICLOCKWISE>
		<ValidationResult_VALID public="1" static="1"><c path="nape.shape.ValidationResult"/></ValidationResult_VALID>
		<ValidationResult_DEGENERATE public="1" static="1"><c path="nape.shape.ValidationResult"/></ValidationResult_DEGENERATE>
		<ValidationResult_CONCAVE public="1" static="1"><c path="nape.shape.ValidationResult"/></ValidationResult_CONCAVE>
		<ValidationResult_SELF_INTERSECTING public="1" static="1"><c path="nape.shape.ValidationResult"/></ValidationResult_SELF_INTERSECTING>
		<ShapeType_CIRCLE public="1" static="1"><c path="nape.shape.ShapeType"/></ShapeType_CIRCLE>
		<ShapeType_POLYGON public="1" static="1"><c path="nape.shape.ShapeType"/></ShapeType_POLYGON>
		<Broadphase_DYNAMIC_AABB_TREE public="1" static="1"><c path="nape.space.Broadphase"/></Broadphase_DYNAMIC_AABB_TREE>
		<Broadphase_SWEEP_AND_PRUNE public="1" static="1"><c path="nape.space.Broadphase"/></Broadphase_SWEEP_AND_PRUNE>
		<ArbiterType_COLLISION public="1" static="1"><c path="nape.dynamics.ArbiterType"/></ArbiterType_COLLISION>
		<ArbiterType_SENSOR public="1" static="1"><c path="nape.dynamics.ArbiterType"/></ArbiterType_SENSOR>
		<ArbiterType_FLUID public="1" static="1"><c path="nape.dynamics.ArbiterType"/></ArbiterType_FLUID>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_CallbackSet" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="995"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
</f></at>
		<iterator_at public="1" set="method" line="982"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CallbackSet"/>
</f></iterator_at>
		<back public="1" set="method" line="973"><f a=""><c path="zpp_nape.space.ZPP_CallbackSet"/></f></back>
		<front public="1" get="inline" set="null" line="970"><f a=""><c path="zpp_nape.space.ZPP_CallbackSet"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="940"><f a="obj">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="935"><f a="obj">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="932"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="927"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="912"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="906"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="901"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="897"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_CallbackSet"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CallbackSet"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="851"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_CallbackSet"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CallbackSet"/>
</f></inlined_erase>
		<erase public="1" set="method" line="846"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_CallbackSet"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CallbackSet"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="823"><f a="obj">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="810"><f a="obj">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="785"><f a="obj">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="774"><f a="obj">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="761"><f a=""><c path="zpp_nape.space.ZPP_CallbackSet"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="756"><f a=""><c path="zpp_nape.space.ZPP_CallbackSet"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="723"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="718"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="675"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_CallbackSet"/>
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CallbackSet"/>
</f></inlined_insert>
		<insert public="1" set="method" line="670"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_CallbackSet"/>
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CallbackSet"/>
</f></insert>
		<addAll public="1" set="method" line="652"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_CallbackSet"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="615"><f a="o">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
</f></inlined_add>
		<add public="1" set="method" line="610"><f a="o">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="605"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_CallbackSet"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="597"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_CallbackSet"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_CallbackSet"/></head>
		<new public="1" set="method" line="594"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_Shape" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="1412"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
</f></at>
		<iterator_at public="1" set="method" line="1399"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Shape"/>
</f></iterator_at>
		<back public="1" set="method" line="1390"><f a=""><c path="zpp_nape.shape.ZPP_Shape"/></f></back>
		<front public="1" get="inline" set="null" line="1387"><f a=""><c path="zpp_nape.shape.ZPP_Shape"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="1357"><f a="obj">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="1352"><f a="obj">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="1349"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="1344"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="1329"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="1323"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="1318"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="1314"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_Shape"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Shape"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="1268"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_Shape"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Shape"/>
</f></inlined_erase>
		<erase public="1" set="method" line="1263"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_Shape"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Shape"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="1240"><f a="obj">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="1227"><f a="obj">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="1202"><f a="obj">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="1191"><f a="obj">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="1178"><f a=""><c path="zpp_nape.shape.ZPP_Shape"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="1173"><f a=""><c path="zpp_nape.shape.ZPP_Shape"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="1140"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="1135"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="1092"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_Shape"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Shape"/>
</f></inlined_insert>
		<insert public="1" set="method" line="1087"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_Shape"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Shape"/>
</f></insert>
		<addAll public="1" set="method" line="1069"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_Shape"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="1032"><f a="o">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
</f></inlined_add>
		<add public="1" set="method" line="1027"><f a="o">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="1022"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_Shape"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="1014"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_Shape"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Shape"/></head>
		<new public="1" set="method" line="1011"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_Body" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="1829"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.phys.ZPP_Body"/>
</f></at>
		<iterator_at public="1" set="method" line="1816"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Body"/>
</f></iterator_at>
		<back public="1" set="method" line="1807"><f a=""><c path="zpp_nape.phys.ZPP_Body"/></f></back>
		<front public="1" get="inline" set="null" line="1804"><f a=""><c path="zpp_nape.phys.ZPP_Body"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="1774"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="1769"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="1766"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="1761"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="1746"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="1740"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="1735"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="1731"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_Body"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Body"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="1685"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_Body"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Body"/>
</f></inlined_erase>
		<erase public="1" set="method" line="1680"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_Body"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Body"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="1657"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="1644"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="1619"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="1608"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="1595"><f a=""><c path="zpp_nape.phys.ZPP_Body"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="1590"><f a=""><c path="zpp_nape.phys.ZPP_Body"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="1557"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="1552"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="1509"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_Body"/>
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Body"/>
</f></inlined_insert>
		<insert public="1" set="method" line="1504"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_Body"/>
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Body"/>
</f></insert>
		<addAll public="1" set="method" line="1486"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_Body"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="1449"><f a="o">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="zpp_nape.phys.ZPP_Body"/>
</f></inlined_add>
		<add public="1" set="method" line="1444"><f a="o">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="zpp_nape.phys.ZPP_Body"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="1439"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_Body"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="1431"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_Body"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Body"/></head>
		<new public="1" set="method" line="1428"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_Compound" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="2663"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.phys.ZPP_Compound"/>
</f></at>
		<iterator_at public="1" set="method" line="2650"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Compound"/>
</f></iterator_at>
		<back public="1" set="method" line="2641"><f a=""><c path="zpp_nape.phys.ZPP_Compound"/></f></back>
		<front public="1" get="inline" set="null" line="2638"><f a=""><c path="zpp_nape.phys.ZPP_Compound"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="2608"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Compound"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="2603"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Compound"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="2600"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="2595"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="2580"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="2574"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="2569"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="2565"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_Compound"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Compound"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="2519"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_Compound"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Compound"/>
</f></inlined_erase>
		<erase public="1" set="method" line="2514"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_Compound"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Compound"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="2491"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Compound"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="2478"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Compound"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="2453"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Compound"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="2442"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Compound"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="2429"><f a=""><c path="zpp_nape.phys.ZPP_Compound"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="2424"><f a=""><c path="zpp_nape.phys.ZPP_Compound"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="2391"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="2386"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="2343"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_Compound"/>
	<c path="zpp_nape.phys.ZPP_Compound"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Compound"/>
</f></inlined_insert>
		<insert public="1" set="method" line="2338"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_Compound"/>
	<c path="zpp_nape.phys.ZPP_Compound"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Compound"/>
</f></insert>
		<addAll public="1" set="method" line="2320"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_Compound"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="2283"><f a="o">
	<c path="zpp_nape.phys.ZPP_Compound"/>
	<c path="zpp_nape.phys.ZPP_Compound"/>
</f></inlined_add>
		<add public="1" set="method" line="2278"><f a="o">
	<c path="zpp_nape.phys.ZPP_Compound"/>
	<c path="zpp_nape.phys.ZPP_Compound"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="2273"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_Compound"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="2265"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_Compound"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Compound"/></head>
		<new public="1" set="method" line="2262"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_CbSetPair" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="4331"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
</f></at>
		<iterator_at public="1" set="method" line="4318"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSetPair"/>
</f></iterator_at>
		<back public="1" set="method" line="4309"><f a=""><c path="zpp_nape.callbacks.ZPP_CbSetPair"/></f></back>
		<front public="1" get="inline" set="null" line="4306"><f a=""><c path="zpp_nape.callbacks.ZPP_CbSetPair"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="4276"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="4271"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="4268"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="4263"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="4248"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="4242"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="4237"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="4233"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSetPair"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSetPair"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="4187"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSetPair"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSetPair"/>
</f></inlined_erase>
		<erase public="1" set="method" line="4182"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSetPair"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSetPair"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="4159"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="4146"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="4121"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="4110"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="4097"><f a=""><c path="zpp_nape.callbacks.ZPP_CbSetPair"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="4092"><f a=""><c path="zpp_nape.callbacks.ZPP_CbSetPair"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="4059"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="4054"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="4011"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSetPair"/>
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSetPair"/>
</f></inlined_insert>
		<insert public="1" set="method" line="4006"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSetPair"/>
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSetPair"/>
</f></insert>
		<addAll public="1" set="method" line="3988"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_CbSetPair"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="3951"><f a="o">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
</f></inlined_add>
		<add public="1" set="method" line="3946"><f a="o">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="3941"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSetPair"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="3933"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_CbSetPair"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_CbSetPair"/></head>
		<new public="1" set="method" line="3930"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_Arbiter" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="5582"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
</f></at>
		<iterator_at public="1" set="method" line="5569"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Arbiter"/>
</f></iterator_at>
		<back public="1" set="method" line="5560"><f a=""><c path="zpp_nape.dynamics.ZPP_Arbiter"/></f></back>
		<front public="1" get="inline" set="null" line="5557"><f a=""><c path="zpp_nape.dynamics.ZPP_Arbiter"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="5527"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="5522"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="5519"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="5514"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="5499"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="5493"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="5488"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="5484"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_Arbiter"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Arbiter"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="5438"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_Arbiter"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Arbiter"/>
</f></inlined_erase>
		<erase public="1" set="method" line="5433"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_Arbiter"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Arbiter"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="5410"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="5397"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="5372"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="5361"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="5348"><f a=""><c path="zpp_nape.dynamics.ZPP_Arbiter"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="5343"><f a=""><c path="zpp_nape.dynamics.ZPP_Arbiter"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="5310"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="5305"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="5262"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_Arbiter"/>
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Arbiter"/>
</f></inlined_insert>
		<insert public="1" set="method" line="5257"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_Arbiter"/>
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Arbiter"/>
</f></insert>
		<addAll public="1" set="method" line="5239"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_Arbiter"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="5202"><f a="o">
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
</f></inlined_add>
		<add public="1" set="method" line="5197"><f a="o">
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="5192"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_Arbiter"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="5184"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_Arbiter"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Arbiter"/></head>
		<new public="1" set="method" line="5181"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_CutInt" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="5999"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_CutInt"/>
</f></at>
		<iterator_at public="1" set="method" line="5986"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CutInt"/>
</f></iterator_at>
		<back public="1" set="method" line="5977"><f a=""><c path="zpp_nape.geom.ZPP_CutInt"/></f></back>
		<front public="1" get="inline" set="null" line="5974"><f a=""><c path="zpp_nape.geom.ZPP_CutInt"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="5944"><f a="obj">
	<c path="zpp_nape.geom.ZPP_CutInt"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="5939"><f a="obj">
	<c path="zpp_nape.geom.ZPP_CutInt"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="5936"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="5931"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="5916"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="5910"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="5905"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="5901"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_CutInt"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CutInt"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="5855"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_CutInt"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CutInt"/>
</f></inlined_erase>
		<erase public="1" set="method" line="5850"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_CutInt"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CutInt"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="5827"><f a="obj">
	<c path="zpp_nape.geom.ZPP_CutInt"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="5814"><f a="obj">
	<c path="zpp_nape.geom.ZPP_CutInt"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="5789"><f a="obj">
	<c path="zpp_nape.geom.ZPP_CutInt"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="5778"><f a="obj">
	<c path="zpp_nape.geom.ZPP_CutInt"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="5765"><f a=""><c path="zpp_nape.geom.ZPP_CutInt"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="5760"><f a=""><c path="zpp_nape.geom.ZPP_CutInt"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="5727"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="5722"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="5679"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_CutInt"/>
	<c path="zpp_nape.geom.ZPP_CutInt"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CutInt"/>
</f></inlined_insert>
		<insert public="1" set="method" line="5674"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_CutInt"/>
	<c path="zpp_nape.geom.ZPP_CutInt"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CutInt"/>
</f></insert>
		<addAll public="1" set="method" line="5656"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_CutInt"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="5619"><f a="o">
	<c path="zpp_nape.geom.ZPP_CutInt"/>
	<c path="zpp_nape.geom.ZPP_CutInt"/>
</f></inlined_add>
		<add public="1" set="method" line="5614"><f a="o">
	<c path="zpp_nape.geom.ZPP_CutInt"/>
	<c path="zpp_nape.geom.ZPP_CutInt"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="5609"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_CutInt"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="5601"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_CutInt"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_CutInt"/></head>
		<new public="1" set="method" line="5598"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_CutVert" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="6416"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_CutVert"/>
</f></at>
		<iterator_at public="1" set="method" line="6403"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CutVert"/>
</f></iterator_at>
		<back public="1" set="method" line="6394"><f a=""><c path="zpp_nape.geom.ZPP_CutVert"/></f></back>
		<front public="1" get="inline" set="null" line="6391"><f a=""><c path="zpp_nape.geom.ZPP_CutVert"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="6361"><f a="obj">
	<c path="zpp_nape.geom.ZPP_CutVert"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="6356"><f a="obj">
	<c path="zpp_nape.geom.ZPP_CutVert"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="6353"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="6348"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="6333"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="6327"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="6322"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="6318"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_CutVert"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CutVert"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="6272"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_CutVert"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CutVert"/>
</f></inlined_erase>
		<erase public="1" set="method" line="6267"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_CutVert"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CutVert"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="6244"><f a="obj">
	<c path="zpp_nape.geom.ZPP_CutVert"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="6231"><f a="obj">
	<c path="zpp_nape.geom.ZPP_CutVert"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="6206"><f a="obj">
	<c path="zpp_nape.geom.ZPP_CutVert"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="6195"><f a="obj">
	<c path="zpp_nape.geom.ZPP_CutVert"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="6182"><f a=""><c path="zpp_nape.geom.ZPP_CutVert"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="6177"><f a=""><c path="zpp_nape.geom.ZPP_CutVert"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="6144"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="6139"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="6096"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_CutVert"/>
	<c path="zpp_nape.geom.ZPP_CutVert"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CutVert"/>
</f></inlined_insert>
		<insert public="1" set="method" line="6091"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_CutVert"/>
	<c path="zpp_nape.geom.ZPP_CutVert"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CutVert"/>
</f></insert>
		<addAll public="1" set="method" line="6073"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_CutVert"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="6036"><f a="o">
	<c path="zpp_nape.geom.ZPP_CutVert"/>
	<c path="zpp_nape.geom.ZPP_CutVert"/>
</f></inlined_add>
		<add public="1" set="method" line="6031"><f a="o">
	<c path="zpp_nape.geom.ZPP_CutVert"/>
	<c path="zpp_nape.geom.ZPP_CutVert"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="6026"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_CutVert"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="6018"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_CutVert"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_CutVert"/></head>
		<new public="1" set="method" line="6015"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_PartitionVertex" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="6833"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
</f></at>
		<iterator_at public="1" set="method" line="6820"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionVertex"/>
</f></iterator_at>
		<back public="1" set="method" line="6811"><f a=""><c path="zpp_nape.geom.ZPP_PartitionVertex"/></f></back>
		<front public="1" get="inline" set="null" line="6808"><f a=""><c path="zpp_nape.geom.ZPP_PartitionVertex"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="6778"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="6773"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="6770"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="6765"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="6750"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="6744"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="6739"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="6735"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionVertex"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionVertex"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="6689"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionVertex"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionVertex"/>
</f></inlined_erase>
		<erase public="1" set="method" line="6684"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionVertex"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionVertex"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="6661"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="6648"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="6623"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="6612"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="6599"><f a=""><c path="zpp_nape.geom.ZPP_PartitionVertex"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="6594"><f a=""><c path="zpp_nape.geom.ZPP_PartitionVertex"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="6561"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="6556"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="6513"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionVertex"/>
</f></inlined_insert>
		<insert public="1" set="method" line="6508"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionVertex"/>
</f></insert>
		<addAll public="1" set="method" line="6490"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_PartitionVertex"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="6453"><f a="o">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
</f></inlined_add>
		<add public="1" set="method" line="6448"><f a="o">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="6443"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionVertex"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="6435"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_PartitionVertex"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_PartitionVertex"/></head>
		<new public="1" set="method" line="6432"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_PartitionedPoly" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="7250"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_PartitionedPoly"/>
</f></at>
		<iterator_at public="1" set="method" line="7237"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionedPoly"/>
</f></iterator_at>
		<back public="1" set="method" line="7228"><f a=""><c path="zpp_nape.geom.ZPP_PartitionedPoly"/></f></back>
		<front public="1" get="inline" set="null" line="7225"><f a=""><c path="zpp_nape.geom.ZPP_PartitionedPoly"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="7195"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionedPoly"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="7190"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionedPoly"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="7187"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="7182"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="7167"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="7161"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="7156"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="7152"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionedPoly"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionedPoly"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="7106"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionedPoly"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionedPoly"/>
</f></inlined_erase>
		<erase public="1" set="method" line="7101"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionedPoly"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionedPoly"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="7078"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionedPoly"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="7065"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionedPoly"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="7040"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionedPoly"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="7029"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionedPoly"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="7016"><f a=""><c path="zpp_nape.geom.ZPP_PartitionedPoly"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="7011"><f a=""><c path="zpp_nape.geom.ZPP_PartitionedPoly"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="6978"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="6973"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="6930"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionedPoly"/>
	<c path="zpp_nape.geom.ZPP_PartitionedPoly"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionedPoly"/>
</f></inlined_insert>
		<insert public="1" set="method" line="6925"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionedPoly"/>
	<c path="zpp_nape.geom.ZPP_PartitionedPoly"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionedPoly"/>
</f></insert>
		<addAll public="1" set="method" line="6907"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_PartitionedPoly"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="6870"><f a="o">
	<c path="zpp_nape.geom.ZPP_PartitionedPoly"/>
	<c path="zpp_nape.geom.ZPP_PartitionedPoly"/>
</f></inlined_add>
		<add public="1" set="method" line="6865"><f a="o">
	<c path="zpp_nape.geom.ZPP_PartitionedPoly"/>
	<c path="zpp_nape.geom.ZPP_PartitionedPoly"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="6860"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionedPoly"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="6852"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_PartitionedPoly"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_PartitionedPoly"/></head>
		<new public="1" set="method" line="6849"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_SimplifyP" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="7667"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_SimplifyP"/>
</f></at>
		<iterator_at public="1" set="method" line="7654"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SimplifyP"/>
</f></iterator_at>
		<back public="1" set="method" line="7645"><f a=""><c path="zpp_nape.geom.ZPP_SimplifyP"/></f></back>
		<front public="1" get="inline" set="null" line="7642"><f a=""><c path="zpp_nape.geom.ZPP_SimplifyP"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="7612"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimplifyP"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="7607"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimplifyP"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="7604"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="7599"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="7584"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="7578"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="7573"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="7569"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_SimplifyP"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SimplifyP"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="7523"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_SimplifyP"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SimplifyP"/>
</f></inlined_erase>
		<erase public="1" set="method" line="7518"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_SimplifyP"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SimplifyP"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="7495"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimplifyP"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="7482"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimplifyP"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="7457"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimplifyP"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="7446"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimplifyP"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="7433"><f a=""><c path="zpp_nape.geom.ZPP_SimplifyP"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="7428"><f a=""><c path="zpp_nape.geom.ZPP_SimplifyP"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="7395"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="7390"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="7347"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_SimplifyP"/>
	<c path="zpp_nape.geom.ZPP_SimplifyP"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SimplifyP"/>
</f></inlined_insert>
		<insert public="1" set="method" line="7342"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_SimplifyP"/>
	<c path="zpp_nape.geom.ZPP_SimplifyP"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SimplifyP"/>
</f></insert>
		<addAll public="1" set="method" line="7324"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_SimplifyP"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="7287"><f a="o">
	<c path="zpp_nape.geom.ZPP_SimplifyP"/>
	<c path="zpp_nape.geom.ZPP_SimplifyP"/>
</f></inlined_add>
		<add public="1" set="method" line="7282"><f a="o">
	<c path="zpp_nape.geom.ZPP_SimplifyP"/>
	<c path="zpp_nape.geom.ZPP_SimplifyP"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="7277"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_SimplifyP"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="7269"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_SimplifyP"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_SimplifyP"/></head>
		<new public="1" set="method" line="7266"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_GeomVert" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="8084"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
</f></at>
		<iterator_at public="1" set="method" line="8071"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomVert"/>
</f></iterator_at>
		<back public="1" set="method" line="8062"><f a=""><c path="zpp_nape.geom.ZPP_GeomVert"/></f></back>
		<front public="1" get="inline" set="null" line="8059"><f a=""><c path="zpp_nape.geom.ZPP_GeomVert"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="8029"><f a="obj">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="8024"><f a="obj">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="8021"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="8016"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="8001"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="7995"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="7990"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="7986"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomVert"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomVert"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="7940"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomVert"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomVert"/>
</f></inlined_erase>
		<erase public="1" set="method" line="7935"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomVert"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomVert"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="7912"><f a="obj">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="7899"><f a="obj">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="7874"><f a="obj">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="7863"><f a="obj">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="7850"><f a=""><c path="zpp_nape.geom.ZPP_GeomVert"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="7845"><f a=""><c path="zpp_nape.geom.ZPP_GeomVert"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="7812"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="7807"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="7764"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomVert"/>
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomVert"/>
</f></inlined_insert>
		<insert public="1" set="method" line="7759"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomVert"/>
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomVert"/>
</f></insert>
		<addAll public="1" set="method" line="7741"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_GeomVert"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="7704"><f a="o">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
</f></inlined_add>
		<add public="1" set="method" line="7699"><f a="o">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="7694"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomVert"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="7686"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_GeomVert"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_GeomVert"/></head>
		<new public="1" set="method" line="7683"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_SimpleVert" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="8501"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
</f></at>
		<iterator_at public="1" set="method" line="8488"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleVert"/>
</f></iterator_at>
		<back public="1" set="method" line="8479"><f a=""><c path="zpp_nape.geom.ZPP_SimpleVert"/></f></back>
		<front public="1" get="inline" set="null" line="8476"><f a=""><c path="zpp_nape.geom.ZPP_SimpleVert"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="8446"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="8441"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="8438"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="8433"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="8418"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="8412"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="8407"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="8403"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleVert"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleVert"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="8357"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleVert"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleVert"/>
</f></inlined_erase>
		<erase public="1" set="method" line="8352"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleVert"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleVert"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="8329"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="8316"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="8291"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="8280"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="8267"><f a=""><c path="zpp_nape.geom.ZPP_SimpleVert"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="8262"><f a=""><c path="zpp_nape.geom.ZPP_SimpleVert"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="8229"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="8224"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="8181"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleVert"/>
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleVert"/>
</f></inlined_insert>
		<insert public="1" set="method" line="8176"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleVert"/>
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleVert"/>
</f></insert>
		<addAll public="1" set="method" line="8158"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_SimpleVert"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="8121"><f a="o">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
</f></inlined_add>
		<add public="1" set="method" line="8116"><f a="o">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="8111"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleVert"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="8103"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_SimpleVert"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_SimpleVert"/></head>
		<new public="1" set="method" line="8100"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_SimpleEvent" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="8918"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
</f></at>
		<iterator_at public="1" set="method" line="8905"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleEvent"/>
</f></iterator_at>
		<back public="1" set="method" line="8896"><f a=""><c path="zpp_nape.geom.ZPP_SimpleEvent"/></f></back>
		<front public="1" get="inline" set="null" line="8893"><f a=""><c path="zpp_nape.geom.ZPP_SimpleEvent"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="8863"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="8858"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="8855"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="8850"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="8835"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="8829"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="8824"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="8820"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleEvent"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleEvent"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="8774"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleEvent"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleEvent"/>
</f></inlined_erase>
		<erase public="1" set="method" line="8769"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleEvent"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleEvent"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="8746"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="8733"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="8708"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="8697"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="8684"><f a=""><c path="zpp_nape.geom.ZPP_SimpleEvent"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="8679"><f a=""><c path="zpp_nape.geom.ZPP_SimpleEvent"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="8646"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="8641"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="8598"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleEvent"/>
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleEvent"/>
</f></inlined_insert>
		<insert public="1" set="method" line="8593"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleEvent"/>
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleEvent"/>
</f></insert>
		<addAll public="1" set="method" line="8575"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_SimpleEvent"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="8538"><f a="o">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
</f></inlined_add>
		<add public="1" set="method" line="8533"><f a="o">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="8528"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleEvent"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="8520"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_SimpleEvent"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_SimpleEvent"/></head>
		<new public="1" set="method" line="8517"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_AABBPair" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="9752"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.space.ZPP_AABBPair"/>
</f></at>
		<iterator_at public="1" set="method" line="9739"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBPair"/>
</f></iterator_at>
		<back public="1" set="method" line="9730"><f a=""><c path="zpp_nape.space.ZPP_AABBPair"/></f></back>
		<front public="1" get="inline" set="null" line="9727"><f a=""><c path="zpp_nape.space.ZPP_AABBPair"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="9697"><f a="obj">
	<c path="zpp_nape.space.ZPP_AABBPair"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="9692"><f a="obj">
	<c path="zpp_nape.space.ZPP_AABBPair"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="9689"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="9684"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="9669"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="9663"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="9658"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="9654"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBPair"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBPair"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="9608"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBPair"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBPair"/>
</f></inlined_erase>
		<erase public="1" set="method" line="9603"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBPair"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBPair"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="9580"><f a="obj">
	<c path="zpp_nape.space.ZPP_AABBPair"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="9567"><f a="obj">
	<c path="zpp_nape.space.ZPP_AABBPair"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="9542"><f a="obj">
	<c path="zpp_nape.space.ZPP_AABBPair"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="9531"><f a="obj">
	<c path="zpp_nape.space.ZPP_AABBPair"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="9518"><f a=""><c path="zpp_nape.space.ZPP_AABBPair"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="9513"><f a=""><c path="zpp_nape.space.ZPP_AABBPair"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="9480"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="9475"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="9432"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBPair"/>
	<c path="zpp_nape.space.ZPP_AABBPair"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBPair"/>
</f></inlined_insert>
		<insert public="1" set="method" line="9427"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBPair"/>
	<c path="zpp_nape.space.ZPP_AABBPair"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBPair"/>
</f></insert>
		<addAll public="1" set="method" line="9409"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_AABBPair"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="9372"><f a="o">
	<c path="zpp_nape.space.ZPP_AABBPair"/>
	<c path="zpp_nape.space.ZPP_AABBPair"/>
</f></inlined_add>
		<add public="1" set="method" line="9367"><f a="o">
	<c path="zpp_nape.space.ZPP_AABBPair"/>
	<c path="zpp_nape.space.ZPP_AABBPair"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="9362"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBPair"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="9354"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_AABBPair"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_AABBPair"/></head>
		<new public="1" set="method" line="9351"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_Edge" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="10169"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.shape.ZPP_Edge"/>
</f></at>
		<iterator_at public="1" set="method" line="10156"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Edge"/>
</f></iterator_at>
		<back public="1" set="method" line="10147"><f a=""><c path="zpp_nape.shape.ZPP_Edge"/></f></back>
		<front public="1" get="inline" set="null" line="10144"><f a=""><c path="zpp_nape.shape.ZPP_Edge"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="10114"><f a="obj">
	<c path="zpp_nape.shape.ZPP_Edge"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="10109"><f a="obj">
	<c path="zpp_nape.shape.ZPP_Edge"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="10106"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="10101"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="10086"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="10080"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="10075"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="10071"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_Edge"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Edge"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="10025"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_Edge"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Edge"/>
</f></inlined_erase>
		<erase public="1" set="method" line="10020"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_Edge"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Edge"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="9997"><f a="obj">
	<c path="zpp_nape.shape.ZPP_Edge"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="9984"><f a="obj">
	<c path="zpp_nape.shape.ZPP_Edge"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="9959"><f a="obj">
	<c path="zpp_nape.shape.ZPP_Edge"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="9948"><f a="obj">
	<c path="zpp_nape.shape.ZPP_Edge"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="9935"><f a=""><c path="zpp_nape.shape.ZPP_Edge"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="9930"><f a=""><c path="zpp_nape.shape.ZPP_Edge"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="9897"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="9892"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="9849"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_Edge"/>
	<c path="zpp_nape.shape.ZPP_Edge"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Edge"/>
</f></inlined_insert>
		<insert public="1" set="method" line="9844"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_Edge"/>
	<c path="zpp_nape.shape.ZPP_Edge"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Edge"/>
</f></insert>
		<addAll public="1" set="method" line="9826"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_Edge"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="9789"><f a="o">
	<c path="zpp_nape.shape.ZPP_Edge"/>
	<c path="zpp_nape.shape.ZPP_Edge"/>
</f></inlined_add>
		<add public="1" set="method" line="9784"><f a="o">
	<c path="zpp_nape.shape.ZPP_Edge"/>
	<c path="zpp_nape.shape.ZPP_Edge"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="9779"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_Edge"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="9771"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_Edge"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Edge"/></head>
		<new public="1" set="method" line="9768"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_AABBNode" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="10586"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.space.ZPP_AABBNode"/>
</f></at>
		<iterator_at public="1" set="method" line="10573"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBNode"/>
</f></iterator_at>
		<back public="1" set="method" line="10564"><f a=""><c path="zpp_nape.space.ZPP_AABBNode"/></f></back>
		<front public="1" get="inline" set="null" line="10561"><f a=""><c path="zpp_nape.space.ZPP_AABBNode"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="10531"><f a="obj">
	<c path="zpp_nape.space.ZPP_AABBNode"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="10526"><f a="obj">
	<c path="zpp_nape.space.ZPP_AABBNode"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="10523"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="10518"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="10503"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="10497"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="10492"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="10488"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBNode"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBNode"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="10442"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBNode"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBNode"/>
</f></inlined_erase>
		<erase public="1" set="method" line="10437"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBNode"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBNode"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="10414"><f a="obj">
	<c path="zpp_nape.space.ZPP_AABBNode"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="10401"><f a="obj">
	<c path="zpp_nape.space.ZPP_AABBNode"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="10376"><f a="obj">
	<c path="zpp_nape.space.ZPP_AABBNode"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="10365"><f a="obj">
	<c path="zpp_nape.space.ZPP_AABBNode"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="10352"><f a=""><c path="zpp_nape.space.ZPP_AABBNode"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="10347"><f a=""><c path="zpp_nape.space.ZPP_AABBNode"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="10314"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="10309"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="10266"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBNode"/>
	<c path="zpp_nape.space.ZPP_AABBNode"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBNode"/>
</f></inlined_insert>
		<insert public="1" set="method" line="10261"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBNode"/>
	<c path="zpp_nape.space.ZPP_AABBNode"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBNode"/>
</f></insert>
		<addAll public="1" set="method" line="10243"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_AABBNode"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="10206"><f a="o">
	<c path="zpp_nape.space.ZPP_AABBNode"/>
	<c path="zpp_nape.space.ZPP_AABBNode"/>
</f></inlined_add>
		<add public="1" set="method" line="10201"><f a="o">
	<c path="zpp_nape.space.ZPP_AABBNode"/>
	<c path="zpp_nape.space.ZPP_AABBNode"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="10196"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBNode"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="10188"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_AABBNode"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_AABBNode"/></head>
		<new public="1" set="method" line="10185"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_Component" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="11003"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.space.ZPP_Component"/>
</f></at>
		<iterator_at public="1" set="method" line="10990"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Component"/>
</f></iterator_at>
		<back public="1" set="method" line="10981"><f a=""><c path="zpp_nape.space.ZPP_Component"/></f></back>
		<front public="1" get="inline" set="null" line="10978"><f a=""><c path="zpp_nape.space.ZPP_Component"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="10948"><f a="obj">
	<c path="zpp_nape.space.ZPP_Component"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="10943"><f a="obj">
	<c path="zpp_nape.space.ZPP_Component"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="10940"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="10935"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="10920"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="10914"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="10909"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="10905"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_Component"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Component"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="10859"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_Component"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Component"/>
</f></inlined_erase>
		<erase public="1" set="method" line="10854"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_Component"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Component"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="10831"><f a="obj">
	<c path="zpp_nape.space.ZPP_Component"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="10818"><f a="obj">
	<c path="zpp_nape.space.ZPP_Component"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="10793"><f a="obj">
	<c path="zpp_nape.space.ZPP_Component"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="10782"><f a="obj">
	<c path="zpp_nape.space.ZPP_Component"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="10769"><f a=""><c path="zpp_nape.space.ZPP_Component"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="10764"><f a=""><c path="zpp_nape.space.ZPP_Component"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="10731"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="10726"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="10683"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_Component"/>
	<c path="zpp_nape.space.ZPP_Component"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Component"/>
</f></inlined_insert>
		<insert public="1" set="method" line="10678"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_Component"/>
	<c path="zpp_nape.space.ZPP_Component"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Component"/>
</f></insert>
		<addAll public="1" set="method" line="10660"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_Component"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="10623"><f a="o">
	<c path="zpp_nape.space.ZPP_Component"/>
	<c path="zpp_nape.space.ZPP_Component"/>
</f></inlined_add>
		<add public="1" set="method" line="10618"><f a="o">
	<c path="zpp_nape.space.ZPP_Component"/>
	<c path="zpp_nape.space.ZPP_Component"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="10613"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_Component"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="10605"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_Component"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Component"/></head>
		<new public="1" set="method" line="10602"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_FluidArbiter" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="11420"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.dynamics.ZPP_FluidArbiter"/>
</f></at>
		<iterator_at public="1" set="method" line="11407"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_FluidArbiter"/>
</f></iterator_at>
		<back public="1" set="method" line="11398"><f a=""><c path="zpp_nape.dynamics.ZPP_FluidArbiter"/></f></back>
		<front public="1" get="inline" set="null" line="11395"><f a=""><c path="zpp_nape.dynamics.ZPP_FluidArbiter"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="11365"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_FluidArbiter"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="11360"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_FluidArbiter"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="11357"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="11352"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="11337"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="11331"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="11326"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="11322"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_FluidArbiter"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_FluidArbiter"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="11276"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_FluidArbiter"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_FluidArbiter"/>
</f></inlined_erase>
		<erase public="1" set="method" line="11271"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_FluidArbiter"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_FluidArbiter"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="11248"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_FluidArbiter"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="11235"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_FluidArbiter"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="11210"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_FluidArbiter"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="11199"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_FluidArbiter"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="11186"><f a=""><c path="zpp_nape.dynamics.ZPP_FluidArbiter"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="11181"><f a=""><c path="zpp_nape.dynamics.ZPP_FluidArbiter"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="11148"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="11143"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="11100"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_FluidArbiter"/>
	<c path="zpp_nape.dynamics.ZPP_FluidArbiter"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_FluidArbiter"/>
</f></inlined_insert>
		<insert public="1" set="method" line="11095"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_FluidArbiter"/>
	<c path="zpp_nape.dynamics.ZPP_FluidArbiter"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_FluidArbiter"/>
</f></insert>
		<addAll public="1" set="method" line="11077"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_FluidArbiter"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="11040"><f a="o">
	<c path="zpp_nape.dynamics.ZPP_FluidArbiter"/>
	<c path="zpp_nape.dynamics.ZPP_FluidArbiter"/>
</f></inlined_add>
		<add public="1" set="method" line="11035"><f a="o">
	<c path="zpp_nape.dynamics.ZPP_FluidArbiter"/>
	<c path="zpp_nape.dynamics.ZPP_FluidArbiter"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="11030"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_FluidArbiter"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="11022"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_FluidArbiter"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_FluidArbiter"/></head>
		<new public="1" set="method" line="11019"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_SensorArbiter" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="11837"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.dynamics.ZPP_SensorArbiter"/>
</f></at>
		<iterator_at public="1" set="method" line="11824"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SensorArbiter"/>
</f></iterator_at>
		<back public="1" set="method" line="11815"><f a=""><c path="zpp_nape.dynamics.ZPP_SensorArbiter"/></f></back>
		<front public="1" get="inline" set="null" line="11812"><f a=""><c path="zpp_nape.dynamics.ZPP_SensorArbiter"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="11782"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_SensorArbiter"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="11777"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_SensorArbiter"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="11774"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="11769"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="11754"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="11748"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="11743"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="11739"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_SensorArbiter"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SensorArbiter"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="11693"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_SensorArbiter"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SensorArbiter"/>
</f></inlined_erase>
		<erase public="1" set="method" line="11688"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_SensorArbiter"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SensorArbiter"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="11665"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_SensorArbiter"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="11652"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_SensorArbiter"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="11627"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_SensorArbiter"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="11616"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_SensorArbiter"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="11603"><f a=""><c path="zpp_nape.dynamics.ZPP_SensorArbiter"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="11598"><f a=""><c path="zpp_nape.dynamics.ZPP_SensorArbiter"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="11565"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="11560"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="11517"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_SensorArbiter"/>
	<c path="zpp_nape.dynamics.ZPP_SensorArbiter"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SensorArbiter"/>
</f></inlined_insert>
		<insert public="1" set="method" line="11512"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_SensorArbiter"/>
	<c path="zpp_nape.dynamics.ZPP_SensorArbiter"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SensorArbiter"/>
</f></insert>
		<addAll public="1" set="method" line="11494"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_SensorArbiter"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="11457"><f a="o">
	<c path="zpp_nape.dynamics.ZPP_SensorArbiter"/>
	<c path="zpp_nape.dynamics.ZPP_SensorArbiter"/>
</f></inlined_add>
		<add public="1" set="method" line="11452"><f a="o">
	<c path="zpp_nape.dynamics.ZPP_SensorArbiter"/>
	<c path="zpp_nape.dynamics.ZPP_SensorArbiter"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="11447"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_SensorArbiter"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="11439"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_SensorArbiter"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_SensorArbiter"/></head>
		<new public="1" set="method" line="11436"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_Listener" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="12254"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.callbacks.ZPP_Listener"/>
</f></at>
		<iterator_at public="1" set="method" line="12241"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Listener"/>
</f></iterator_at>
		<back public="1" set="method" line="12232"><f a=""><c path="zpp_nape.callbacks.ZPP_Listener"/></f></back>
		<front public="1" get="inline" set="null" line="12229"><f a=""><c path="zpp_nape.callbacks.ZPP_Listener"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="12199"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_Listener"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="12194"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_Listener"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="12191"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="12186"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="12171"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="12165"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="12160"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="12156"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_Listener"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Listener"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="12110"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_Listener"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Listener"/>
</f></inlined_erase>
		<erase public="1" set="method" line="12105"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_Listener"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Listener"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="12082"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_Listener"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="12069"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_Listener"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="12044"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_Listener"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="12033"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_Listener"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="12020"><f a=""><c path="zpp_nape.callbacks.ZPP_Listener"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="12015"><f a=""><c path="zpp_nape.callbacks.ZPP_Listener"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="11982"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="11977"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="11934"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_Listener"/>
	<c path="zpp_nape.callbacks.ZPP_Listener"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Listener"/>
</f></inlined_insert>
		<insert public="1" set="method" line="11929"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_Listener"/>
	<c path="zpp_nape.callbacks.ZPP_Listener"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Listener"/>
</f></insert>
		<addAll public="1" set="method" line="11911"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_Listener"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="11874"><f a="o">
	<c path="zpp_nape.callbacks.ZPP_Listener"/>
	<c path="zpp_nape.callbacks.ZPP_Listener"/>
</f></inlined_add>
		<add public="1" set="method" line="11869"><f a="o">
	<c path="zpp_nape.callbacks.ZPP_Listener"/>
	<c path="zpp_nape.callbacks.ZPP_Listener"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="11864"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_Listener"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="11856"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_Listener"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Listener"/></head>
		<new public="1" set="method" line="11853"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_ColArbiter" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="12671"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.dynamics.ZPP_ColArbiter"/>
</f></at>
		<iterator_at public="1" set="method" line="12658"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_ColArbiter"/>
</f></iterator_at>
		<back public="1" set="method" line="12649"><f a=""><c path="zpp_nape.dynamics.ZPP_ColArbiter"/></f></back>
		<front public="1" get="inline" set="null" line="12646"><f a=""><c path="zpp_nape.dynamics.ZPP_ColArbiter"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="12616"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_ColArbiter"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="12611"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_ColArbiter"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="12608"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="12603"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="12588"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="12582"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="12577"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="12573"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_ColArbiter"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_ColArbiter"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="12527"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_ColArbiter"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_ColArbiter"/>
</f></inlined_erase>
		<erase public="1" set="method" line="12522"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_ColArbiter"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_ColArbiter"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="12499"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_ColArbiter"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="12486"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_ColArbiter"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="12461"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_ColArbiter"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="12450"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_ColArbiter"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="12437"><f a=""><c path="zpp_nape.dynamics.ZPP_ColArbiter"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="12432"><f a=""><c path="zpp_nape.dynamics.ZPP_ColArbiter"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="12399"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="12394"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="12351"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_ColArbiter"/>
	<c path="zpp_nape.dynamics.ZPP_ColArbiter"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_ColArbiter"/>
</f></inlined_insert>
		<insert public="1" set="method" line="12346"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_ColArbiter"/>
	<c path="zpp_nape.dynamics.ZPP_ColArbiter"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_ColArbiter"/>
</f></insert>
		<addAll public="1" set="method" line="12328"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_ColArbiter"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="12291"><f a="o">
	<c path="zpp_nape.dynamics.ZPP_ColArbiter"/>
	<c path="zpp_nape.dynamics.ZPP_ColArbiter"/>
</f></inlined_add>
		<add public="1" set="method" line="12286"><f a="o">
	<c path="zpp_nape.dynamics.ZPP_ColArbiter"/>
	<c path="zpp_nape.dynamics.ZPP_ColArbiter"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="12281"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_ColArbiter"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="12273"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_ColArbiter"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_ColArbiter"/></head>
		<new public="1" set="method" line="12270"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_InteractionGroup" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="13088"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionGroup"/>
</f></at>
		<iterator_at public="1" set="method" line="13075"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionGroup"/>
</f></iterator_at>
		<back public="1" set="method" line="13066"><f a=""><c path="zpp_nape.dynamics.ZPP_InteractionGroup"/></f></back>
		<front public="1" get="inline" set="null" line="13063"><f a=""><c path="zpp_nape.dynamics.ZPP_InteractionGroup"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="13033"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_InteractionGroup"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="13028"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_InteractionGroup"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="13025"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="13020"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="13005"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="12999"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="12994"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="12990"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionGroup"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionGroup"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="12944"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionGroup"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionGroup"/>
</f></inlined_erase>
		<erase public="1" set="method" line="12939"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionGroup"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionGroup"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="12916"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_InteractionGroup"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="12903"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_InteractionGroup"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="12878"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_InteractionGroup"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="12867"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_InteractionGroup"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="12854"><f a=""><c path="zpp_nape.dynamics.ZPP_InteractionGroup"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="12849"><f a=""><c path="zpp_nape.dynamics.ZPP_InteractionGroup"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="12816"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="12811"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="12768"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionGroup"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionGroup"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionGroup"/>
</f></inlined_insert>
		<insert public="1" set="method" line="12763"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionGroup"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionGroup"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionGroup"/>
</f></insert>
		<addAll public="1" set="method" line="12745"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_InteractionGroup"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="12708"><f a="o">
	<c path="zpp_nape.dynamics.ZPP_InteractionGroup"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionGroup"/>
</f></inlined_add>
		<add public="1" set="method" line="12703"><f a="o">
	<c path="zpp_nape.dynamics.ZPP_InteractionGroup"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionGroup"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="12698"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionGroup"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="12690"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_InteractionGroup"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_InteractionGroup"/></head>
		<new public="1" set="method" line="12687"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_ToiEvent" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="13505"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_ToiEvent"/>
</f></at>
		<iterator_at public="1" set="method" line="13492"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_ToiEvent"/>
</f></iterator_at>
		<back public="1" set="method" line="13483"><f a=""><c path="zpp_nape.geom.ZPP_ToiEvent"/></f></back>
		<front public="1" get="inline" set="null" line="13480"><f a=""><c path="zpp_nape.geom.ZPP_ToiEvent"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="13450"><f a="obj">
	<c path="zpp_nape.geom.ZPP_ToiEvent"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="13445"><f a="obj">
	<c path="zpp_nape.geom.ZPP_ToiEvent"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="13442"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="13437"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="13422"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="13416"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="13411"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="13407"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_ToiEvent"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_ToiEvent"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="13361"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_ToiEvent"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_ToiEvent"/>
</f></inlined_erase>
		<erase public="1" set="method" line="13356"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_ToiEvent"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_ToiEvent"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="13333"><f a="obj">
	<c path="zpp_nape.geom.ZPP_ToiEvent"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="13320"><f a="obj">
	<c path="zpp_nape.geom.ZPP_ToiEvent"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="13295"><f a="obj">
	<c path="zpp_nape.geom.ZPP_ToiEvent"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="13284"><f a="obj">
	<c path="zpp_nape.geom.ZPP_ToiEvent"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="13271"><f a=""><c path="zpp_nape.geom.ZPP_ToiEvent"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="13266"><f a=""><c path="zpp_nape.geom.ZPP_ToiEvent"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="13233"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="13228"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="13185"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_ToiEvent"/>
	<c path="zpp_nape.geom.ZPP_ToiEvent"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_ToiEvent"/>
</f></inlined_insert>
		<insert public="1" set="method" line="13180"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_ToiEvent"/>
	<c path="zpp_nape.geom.ZPP_ToiEvent"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_ToiEvent"/>
</f></insert>
		<addAll public="1" set="method" line="13162"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_ToiEvent"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="13125"><f a="o">
	<c path="zpp_nape.geom.ZPP_ToiEvent"/>
	<c path="zpp_nape.geom.ZPP_ToiEvent"/>
</f></inlined_add>
		<add public="1" set="method" line="13120"><f a="o">
	<c path="zpp_nape.geom.ZPP_ToiEvent"/>
	<c path="zpp_nape.geom.ZPP_ToiEvent"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="13115"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_ToiEvent"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="13107"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_ToiEvent"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_ToiEvent"/></head>
		<new public="1" set="method" line="13104"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ConvexResult" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="13922"><f a="ind">
	<x path="Int"/>
	<c path="nape.geom.ConvexResult"/>
</f></at>
		<iterator_at public="1" set="method" line="13909"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ConvexResult"/>
</f></iterator_at>
		<back public="1" set="method" line="13900"><f a=""><c path="nape.geom.ConvexResult"/></f></back>
		<front public="1" get="inline" set="null" line="13897"><f a=""><c path="nape.geom.ConvexResult"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="13867"><f a="obj">
	<c path="nape.geom.ConvexResult"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="13862"><f a="obj">
	<c path="nape.geom.ConvexResult"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="13859"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="13854"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="13839"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="13833"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="13828"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="13824"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ConvexResult"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ConvexResult"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="13778"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ConvexResult"/>
	<c path="zpp_nape.util.ZNPNode_ConvexResult"/>
</f></inlined_erase>
		<erase public="1" set="method" line="13773"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ConvexResult"/>
	<c path="zpp_nape.util.ZNPNode_ConvexResult"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="13750"><f a="obj">
	<c path="nape.geom.ConvexResult"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="13737"><f a="obj">
	<c path="nape.geom.ConvexResult"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="13712"><f a="obj">
	<c path="nape.geom.ConvexResult"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="13701"><f a="obj">
	<c path="nape.geom.ConvexResult"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="13688"><f a=""><c path="nape.geom.ConvexResult"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="13683"><f a=""><c path="nape.geom.ConvexResult"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="13650"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="13645"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="13602"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ConvexResult"/>
	<c path="nape.geom.ConvexResult"/>
	<c path="zpp_nape.util.ZNPNode_ConvexResult"/>
</f></inlined_insert>
		<insert public="1" set="method" line="13597"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ConvexResult"/>
	<c path="nape.geom.ConvexResult"/>
	<c path="zpp_nape.util.ZNPNode_ConvexResult"/>
</f></insert>
		<addAll public="1" set="method" line="13579"><f a="x">
	<c path="zpp_nape.util.ZNPList_ConvexResult"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="13542"><f a="o">
	<c path="nape.geom.ConvexResult"/>
	<c path="nape.geom.ConvexResult"/>
</f></inlined_add>
		<add public="1" set="method" line="13537"><f a="o">
	<c path="nape.geom.ConvexResult"/>
	<c path="nape.geom.ConvexResult"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="13532"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ConvexResult"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="13524"><f a=""><c path="zpp_nape.util.ZNPNode_ConvexResult"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ConvexResult"/></head>
		<new public="1" set="method" line="13521"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_GeomPoly" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="14339"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_GeomPoly"/>
</f></at>
		<iterator_at public="1" set="method" line="14326"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomPoly"/>
</f></iterator_at>
		<back public="1" set="method" line="14317"><f a=""><c path="zpp_nape.geom.ZPP_GeomPoly"/></f></back>
		<front public="1" get="inline" set="null" line="14314"><f a=""><c path="zpp_nape.geom.ZPP_GeomPoly"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="14284"><f a="obj">
	<c path="zpp_nape.geom.ZPP_GeomPoly"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="14279"><f a="obj">
	<c path="zpp_nape.geom.ZPP_GeomPoly"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="14276"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="14271"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="14256"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="14250"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="14245"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="14241"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomPoly"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomPoly"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="14195"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomPoly"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomPoly"/>
</f></inlined_erase>
		<erase public="1" set="method" line="14190"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomPoly"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomPoly"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="14167"><f a="obj">
	<c path="zpp_nape.geom.ZPP_GeomPoly"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="14154"><f a="obj">
	<c path="zpp_nape.geom.ZPP_GeomPoly"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="14129"><f a="obj">
	<c path="zpp_nape.geom.ZPP_GeomPoly"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="14118"><f a="obj">
	<c path="zpp_nape.geom.ZPP_GeomPoly"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="14105"><f a=""><c path="zpp_nape.geom.ZPP_GeomPoly"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="14100"><f a=""><c path="zpp_nape.geom.ZPP_GeomPoly"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="14067"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="14062"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="14019"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomPoly"/>
	<c path="zpp_nape.geom.ZPP_GeomPoly"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomPoly"/>
</f></inlined_insert>
		<insert public="1" set="method" line="14014"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomPoly"/>
	<c path="zpp_nape.geom.ZPP_GeomPoly"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomPoly"/>
</f></insert>
		<addAll public="1" set="method" line="13996"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_GeomPoly"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="13959"><f a="o">
	<c path="zpp_nape.geom.ZPP_GeomPoly"/>
	<c path="zpp_nape.geom.ZPP_GeomPoly"/>
</f></inlined_add>
		<add public="1" set="method" line="13954"><f a="o">
	<c path="zpp_nape.geom.ZPP_GeomPoly"/>
	<c path="zpp_nape.geom.ZPP_GeomPoly"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="13949"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomPoly"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="13941"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_GeomPoly"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_GeomPoly"/></head>
		<new public="1" set="method" line="13938"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_RayResult" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="14756"><f a="ind">
	<x path="Int"/>
	<c path="nape.geom.RayResult"/>
</f></at>
		<iterator_at public="1" set="method" line="14743"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_RayResult"/>
</f></iterator_at>
		<back public="1" set="method" line="14734"><f a=""><c path="nape.geom.RayResult"/></f></back>
		<front public="1" get="inline" set="null" line="14731"><f a=""><c path="nape.geom.RayResult"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="14701"><f a="obj">
	<c path="nape.geom.RayResult"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="14696"><f a="obj">
	<c path="nape.geom.RayResult"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="14693"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="14688"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="14673"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="14667"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="14662"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="14658"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_RayResult"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_RayResult"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="14612"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_RayResult"/>
	<c path="zpp_nape.util.ZNPNode_RayResult"/>
</f></inlined_erase>
		<erase public="1" set="method" line="14607"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_RayResult"/>
	<c path="zpp_nape.util.ZNPNode_RayResult"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="14584"><f a="obj">
	<c path="nape.geom.RayResult"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="14571"><f a="obj">
	<c path="nape.geom.RayResult"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="14546"><f a="obj">
	<c path="nape.geom.RayResult"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="14535"><f a="obj">
	<c path="nape.geom.RayResult"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="14522"><f a=""><c path="nape.geom.RayResult"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="14517"><f a=""><c path="nape.geom.RayResult"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="14484"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="14479"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="14436"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_RayResult"/>
	<c path="nape.geom.RayResult"/>
	<c path="zpp_nape.util.ZNPNode_RayResult"/>
</f></inlined_insert>
		<insert public="1" set="method" line="14431"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_RayResult"/>
	<c path="nape.geom.RayResult"/>
	<c path="zpp_nape.util.ZNPNode_RayResult"/>
</f></insert>
		<addAll public="1" set="method" line="14413"><f a="x">
	<c path="zpp_nape.util.ZNPList_RayResult"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="14376"><f a="o">
	<c path="nape.geom.RayResult"/>
	<c path="nape.geom.RayResult"/>
</f></inlined_add>
		<add public="1" set="method" line="14371"><f a="o">
	<c path="nape.geom.RayResult"/>
	<c path="nape.geom.RayResult"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="14366"><f a="i">
	<c path="zpp_nape.util.ZNPNode_RayResult"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="14358"><f a=""><c path="zpp_nape.util.ZNPNode_RayResult"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_RayResult"/></head>
		<new public="1" set="method" line="14355"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_CbType" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="14772" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_CbType"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="14809"><f a=""><c path="zpp_nape.callbacks.ZPP_CbType"/></f></elem>
		<elt public="1"><c path="zpp_nape.callbacks.ZPP_CbType"/></elt>
		<free public="1" get="inline" set="null" line="14802"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="14799"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_CbType"/></next>
		<new public="1" set="method" line="14806"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_CallbackSet" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="14815" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_CallbackSet"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="14852"><f a=""><c path="zpp_nape.space.ZPP_CallbackSet"/></f></elem>
		<elt public="1"><c path="zpp_nape.space.ZPP_CallbackSet"/></elt>
		<free public="1" get="inline" set="null" line="14845"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="14842"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_CallbackSet"/></next>
		<new public="1" set="method" line="14849"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_Shape" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="14858" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_Shape"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="14895"><f a=""><c path="zpp_nape.shape.ZPP_Shape"/></f></elem>
		<elt public="1"><c path="zpp_nape.shape.ZPP_Shape"/></elt>
		<free public="1" get="inline" set="null" line="14888"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="14885"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Shape"/></next>
		<new public="1" set="method" line="14892"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_Body" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="14901" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_Body"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="14938"><f a=""><c path="zpp_nape.phys.ZPP_Body"/></f></elem>
		<elt public="1"><c path="zpp_nape.phys.ZPP_Body"/></elt>
		<free public="1" get="inline" set="null" line="14931"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="14928"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Body"/></next>
		<new public="1" set="method" line="14935"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_Constraint" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="14944" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_Constraint"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="14981"><f a=""><c path="zpp_nape.constraint.ZPP_Constraint"/></f></elem>
		<elt public="1"><c path="zpp_nape.constraint.ZPP_Constraint"/></elt>
		<free public="1" get="inline" set="null" line="14974"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="14971"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Constraint"/></next>
		<new public="1" set="method" line="14978"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_Compound" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="14987" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_Compound"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="15024"><f a=""><c path="zpp_nape.phys.ZPP_Compound"/></f></elem>
		<elt public="1"><c path="zpp_nape.phys.ZPP_Compound"/></elt>
		<free public="1" get="inline" set="null" line="15017"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="15014"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Compound"/></next>
		<new public="1" set="method" line="15021"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_InteractionListener" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15030" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_InteractionListener"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="15067"><f a=""><c path="zpp_nape.callbacks.ZPP_InteractionListener"/></f></elem>
		<elt public="1"><c path="zpp_nape.callbacks.ZPP_InteractionListener"/></elt>
		<free public="1" get="inline" set="null" line="15060"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="15057"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_InteractionListener"/></next>
		<new public="1" set="method" line="15064"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_CbSet" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15073" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_CbSet"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="15110"><f a=""><c path="zpp_nape.callbacks.ZPP_CbSet"/></f></elem>
		<elt public="1"><c path="zpp_nape.callbacks.ZPP_CbSet"/></elt>
		<free public="1" get="inline" set="null" line="15103"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="15100"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_CbSet"/></next>
		<new public="1" set="method" line="15107"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_Interactor" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15116" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_Interactor"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="15153"><f a=""><c path="zpp_nape.phys.ZPP_Interactor"/></f></elem>
		<elt public="1"><c path="zpp_nape.phys.ZPP_Interactor"/></elt>
		<free public="1" get="inline" set="null" line="15146"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="15143"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Interactor"/></next>
		<new public="1" set="method" line="15150"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_CbSetPair" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15159" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_CbSetPair"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="15196"><f a=""><c path="zpp_nape.callbacks.ZPP_CbSetPair"/></f></elem>
		<elt public="1"><c path="zpp_nape.callbacks.ZPP_CbSetPair"/></elt>
		<free public="1" get="inline" set="null" line="15189"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="15186"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_CbSetPair"/></next>
		<new public="1" set="method" line="15193"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_BodyListener" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15202" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_BodyListener"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="15239"><f a=""><c path="zpp_nape.callbacks.ZPP_BodyListener"/></f></elem>
		<elt public="1"><c path="zpp_nape.callbacks.ZPP_BodyListener"/></elt>
		<free public="1" get="inline" set="null" line="15232"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="15229"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_BodyListener"/></next>
		<new public="1" set="method" line="15236"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_ConstraintListener" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15245" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_ConstraintListener"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="15282"><f a=""><c path="zpp_nape.callbacks.ZPP_ConstraintListener"/></f></elem>
		<elt public="1"><c path="zpp_nape.callbacks.ZPP_ConstraintListener"/></elt>
		<free public="1" get="inline" set="null" line="15275"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="15272"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_ConstraintListener"/></next>
		<new public="1" set="method" line="15279"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_Arbiter" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15288" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_Arbiter"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="15325"><f a=""><c path="zpp_nape.dynamics.ZPP_Arbiter"/></f></elem>
		<elt public="1"><c path="zpp_nape.dynamics.ZPP_Arbiter"/></elt>
		<free public="1" get="inline" set="null" line="15318"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="15315"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Arbiter"/></next>
		<new public="1" set="method" line="15322"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_CutInt" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15331" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_CutInt"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="15368"><f a=""><c path="zpp_nape.geom.ZPP_CutInt"/></f></elem>
		<elt public="1"><c path="zpp_nape.geom.ZPP_CutInt"/></elt>
		<free public="1" get="inline" set="null" line="15361"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="15358"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_CutInt"/></next>
		<new public="1" set="method" line="15365"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_CutVert" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15374" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_CutVert"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="15411"><f a=""><c path="zpp_nape.geom.ZPP_CutVert"/></f></elem>
		<elt public="1"><c path="zpp_nape.geom.ZPP_CutVert"/></elt>
		<free public="1" get="inline" set="null" line="15404"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="15401"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_CutVert"/></next>
		<new public="1" set="method" line="15408"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_PartitionVertex" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15417" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_PartitionVertex"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="15454"><f a=""><c path="zpp_nape.geom.ZPP_PartitionVertex"/></f></elem>
		<elt public="1"><c path="zpp_nape.geom.ZPP_PartitionVertex"/></elt>
		<free public="1" get="inline" set="null" line="15447"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="15444"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_PartitionVertex"/></next>
		<new public="1" set="method" line="15451"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_PartitionedPoly" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15460" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_PartitionedPoly"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="15497"><f a=""><c path="zpp_nape.geom.ZPP_PartitionedPoly"/></f></elem>
		<elt public="1"><c path="zpp_nape.geom.ZPP_PartitionedPoly"/></elt>
		<free public="1" get="inline" set="null" line="15490"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="15487"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_PartitionedPoly"/></next>
		<new public="1" set="method" line="15494"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_SimplifyP" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15503" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_SimplifyP"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="15540"><f a=""><c path="zpp_nape.geom.ZPP_SimplifyP"/></f></elem>
		<elt public="1"><c path="zpp_nape.geom.ZPP_SimplifyP"/></elt>
		<free public="1" get="inline" set="null" line="15533"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="15530"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_SimplifyP"/></next>
		<new public="1" set="method" line="15537"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_GeomVert" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15546" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_GeomVert"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="15583"><f a=""><c path="zpp_nape.geom.ZPP_GeomVert"/></f></elem>
		<elt public="1"><c path="zpp_nape.geom.ZPP_GeomVert"/></elt>
		<free public="1" get="inline" set="null" line="15576"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="15573"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_GeomVert"/></next>
		<new public="1" set="method" line="15580"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_SimpleVert" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15589" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_SimpleVert"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="15626"><f a=""><c path="zpp_nape.geom.ZPP_SimpleVert"/></f></elem>
		<elt public="1"><c path="zpp_nape.geom.ZPP_SimpleVert"/></elt>
		<free public="1" get="inline" set="null" line="15619"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="15616"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_SimpleVert"/></next>
		<new public="1" set="method" line="15623"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_SimpleEvent" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15632" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_SimpleEvent"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="15669"><f a=""><c path="zpp_nape.geom.ZPP_SimpleEvent"/></f></elem>
		<elt public="1"><c path="zpp_nape.geom.ZPP_SimpleEvent"/></elt>
		<free public="1" get="inline" set="null" line="15662"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="15659"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_SimpleEvent"/></next>
		<new public="1" set="method" line="15666"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_Vec2" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15675" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_Vec2"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="15712"><f a=""><c path="zpp_nape.geom.ZPP_Vec2"/></f></elem>
		<elt public="1"><c path="zpp_nape.geom.ZPP_Vec2"/></elt>
		<free public="1" get="inline" set="null" line="15705"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="15702"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Vec2"/></next>
		<new public="1" set="method" line="15709"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_AABBPair" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15718" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_AABBPair"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="15755"><f a=""><c path="zpp_nape.space.ZPP_AABBPair"/></f></elem>
		<elt public="1"><c path="zpp_nape.space.ZPP_AABBPair"/></elt>
		<free public="1" get="inline" set="null" line="15748"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="15745"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_AABBPair"/></next>
		<new public="1" set="method" line="15752"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_Edge" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15761" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_Edge"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="15798"><f a=""><c path="zpp_nape.shape.ZPP_Edge"/></f></elem>
		<elt public="1"><c path="zpp_nape.shape.ZPP_Edge"/></elt>
		<free public="1" get="inline" set="null" line="15791"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="15788"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Edge"/></next>
		<new public="1" set="method" line="15795"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_AABBNode" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15804" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_AABBNode"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="15841"><f a=""><c path="zpp_nape.space.ZPP_AABBNode"/></f></elem>
		<elt public="1"><c path="zpp_nape.space.ZPP_AABBNode"/></elt>
		<free public="1" get="inline" set="null" line="15834"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="15831"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_AABBNode"/></next>
		<new public="1" set="method" line="15838"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_Component" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15847" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_Component"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="15884"><f a=""><c path="zpp_nape.space.ZPP_Component"/></f></elem>
		<elt public="1"><c path="zpp_nape.space.ZPP_Component"/></elt>
		<free public="1" get="inline" set="null" line="15877"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="15874"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Component"/></next>
		<new public="1" set="method" line="15881"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_FluidArbiter" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15890" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_FluidArbiter"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="15927"><f a=""><c path="zpp_nape.dynamics.ZPP_FluidArbiter"/></f></elem>
		<elt public="1"><c path="zpp_nape.dynamics.ZPP_FluidArbiter"/></elt>
		<free public="1" get="inline" set="null" line="15920"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="15917"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_FluidArbiter"/></next>
		<new public="1" set="method" line="15924"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_SensorArbiter" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15933" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_SensorArbiter"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="15970"><f a=""><c path="zpp_nape.dynamics.ZPP_SensorArbiter"/></f></elem>
		<elt public="1"><c path="zpp_nape.dynamics.ZPP_SensorArbiter"/></elt>
		<free public="1" get="inline" set="null" line="15963"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="15960"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_SensorArbiter"/></next>
		<new public="1" set="method" line="15967"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_Listener" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15976" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_Listener"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="16013"><f a=""><c path="zpp_nape.callbacks.ZPP_Listener"/></f></elem>
		<elt public="1"><c path="zpp_nape.callbacks.ZPP_Listener"/></elt>
		<free public="1" get="inline" set="null" line="16006"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="16003"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Listener"/></next>
		<new public="1" set="method" line="16010"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_ColArbiter" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="16019" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_ColArbiter"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="16056"><f a=""><c path="zpp_nape.dynamics.ZPP_ColArbiter"/></f></elem>
		<elt public="1"><c path="zpp_nape.dynamics.ZPP_ColArbiter"/></elt>
		<free public="1" get="inline" set="null" line="16049"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="16046"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_ColArbiter"/></next>
		<new public="1" set="method" line="16053"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_InteractionGroup" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="16062" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_InteractionGroup"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="16099"><f a=""><c path="zpp_nape.dynamics.ZPP_InteractionGroup"/></f></elem>
		<elt public="1"><c path="zpp_nape.dynamics.ZPP_InteractionGroup"/></elt>
		<free public="1" get="inline" set="null" line="16092"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="16089"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_InteractionGroup"/></next>
		<new public="1" set="method" line="16096"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_ToiEvent" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="16105" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_ToiEvent"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="16142"><f a=""><c path="zpp_nape.geom.ZPP_ToiEvent"/></f></elem>
		<elt public="1"><c path="zpp_nape.geom.ZPP_ToiEvent"/></elt>
		<free public="1" get="inline" set="null" line="16135"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="16132"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_ToiEvent"/></next>
		<new public="1" set="method" line="16139"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ConvexResult" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="16148" static="1"><c path="zpp_nape.util.ZNPNode_ConvexResult"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="16185"><f a=""><c path="nape.geom.ConvexResult"/></f></elem>
		<elt public="1"><c path="nape.geom.ConvexResult"/></elt>
		<free public="1" get="inline" set="null" line="16178"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="16175"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ConvexResult"/></next>
		<new public="1" set="method" line="16182"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_GeomPoly" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="16191" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_GeomPoly"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="16228"><f a=""><c path="zpp_nape.geom.ZPP_GeomPoly"/></f></elem>
		<elt public="1"><c path="zpp_nape.geom.ZPP_GeomPoly"/></elt>
		<free public="1" get="inline" set="null" line="16221"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="16218"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_GeomPoly"/></next>
		<new public="1" set="method" line="16225"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_RayResult" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="16234" static="1"><c path="zpp_nape.util.ZNPNode_RayResult"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="16271"><f a=""><c path="nape.geom.RayResult"/></f></elem>
		<elt public="1"><c path="nape.geom.RayResult"/></elt>
		<free public="1" get="inline" set="null" line="16264"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="16261"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_RayResult"/></next>
		<new public="1" set="method" line="16268"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_MixVec2List" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<extends path="nape.geom.Vec2List"/>
		<get public="1" set="method" line="16283" static="1"><f a="list:?immutable">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Bool"/>
	<c path="zpp_nape.util.ZPP_MixVec2List"/>
</f></get>
		<clear public="1" set="method" line="16481" override="1"><f a=""><x path="Void"/></f></clear>
		<remove public="1" set="method" line="16450" override="1"><f a="obj">
	<c path="nape.geom.Vec2"/>
	<x path="Bool"/>
</f></remove>
		<shift public="1" set="method" line="16421" override="1"><f a=""><c path="nape.geom.Vec2"/></f></shift>
		<pop public="1" set="method" line="16392" override="1"><f a=""><c path="nape.geom.Vec2"/></f></pop>
		<unshift public="1" set="method" line="16370" override="1"><f a="obj">
	<c path="nape.geom.Vec2"/>
	<x path="Bool"/>
</f></unshift>
		<push public="1" set="method" line="16348" override="1"><f a="obj">
	<c path="nape.geom.Vec2"/>
	<x path="Bool"/>
</f></push>
		<at public="1" set="method" line="16321" override="1"><f a="index">
	<x path="Int"/>
	<c path="nape.geom.Vec2"/>
</f></at>
		<zpp_vm public="1" set="method" line="16312" override="1"><f a=""><x path="Void"/></f></zpp_vm>
		<zpp_gl public="1" set="method" line="16296" override="1"><f a=""><x path="Int"/></f></zpp_gl>
		<at_index public="1"><x path="Int"/></at_index>
		<at_ite public="1"><c path="zpp_nape.geom.ZPP_Vec2"/></at_ite>
		<zip_length public="1"><x path="Bool"/></zip_length>
		<_length public="1"><x path="Int"/></_length>
		<inner public="1"><c path="zpp_nape.geom.ZPP_Vec2"/></inner>
		<new public="1" set="method" line="16289"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_ConstraintList" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<internal public="1" line="16503" static="1"><x path="Bool"/></internal>
		<get public="1" set="method" line="16509" static="1"><f a="list:?imm">
	<c path="zpp_nape.util.ZNPList_ZPP_Constraint"/>
	<x path="Bool"/>
	<c path="nape.constraint.ConstraintList"/>
</f></get>
		<user_length public="1"><x path="Int"/></user_length>
		<zip_length public="1"><x path="Bool"/></zip_length>
		<push_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Constraint"/></push_ite>
		<at_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Constraint"/></at_ite>
		<at_index public="1"><x path="Int"/></at_index>
		<invalidate public="1" set="method" line="16542"><f a=""><x path="Void"/></f></invalidate>
		<validate public="1" set="method" line="16536"><f a=""><x path="Void"/></f></validate>
		<modify_test public="1" set="method" line="16531"><f a=""><x path="Void"/></f></modify_test>
		<modified public="1" set="method" line="16526"><f a=""><x path="Void"/></f></modified>
		<valmod public="1" set="method" line="16516"><f a=""><x path="Void"/></f></valmod>
		<reverse_flag public="1"><x path="Bool"/></reverse_flag>
		<dontremove public="1"><x path="Bool"/></dontremove>
		<subber public="1"><f a="">
	<c path="nape.constraint.Constraint"/>
	<x path="Void"/>
</f></subber>
		<post_adder public="1"><f a="">
	<c path="nape.constraint.Constraint"/>
	<x path="Void"/>
</f></post_adder>
		<adder public="1"><f a="">
	<c path="nape.constraint.Constraint"/>
	<x path="Bool"/>
</f></adder>
		<_modifiable public="1"><f a=""><x path="Void"/></f></_modifiable>
		<_validate public="1"><f a=""><x path="Void"/></f></_validate>
		<_invalidate public="1"><f a="">
	<c path="zpp_nape.util.ZPP_ConstraintList"/>
	<x path="Void"/>
</f></_invalidate>
		<_invalidated public="1"><x path="Bool"/></_invalidated>
		<immutable public="1"><x path="Bool"/></immutable>
		<inner public="1"><c path="zpp_nape.util.ZNPList_ZPP_Constraint"/></inner>
		<outer public="1"><c path="nape.constraint.ConstraintList"/></outer>
		<new public="1" set="method" line="16551"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_BodyList" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<internal public="1" line="16565" static="1"><x path="Bool"/></internal>
		<get public="1" set="method" line="16571" static="1"><f a="list:?imm">
	<c path="zpp_nape.util.ZNPList_ZPP_Body"/>
	<x path="Bool"/>
	<c path="nape.phys.BodyList"/>
</f></get>
		<user_length public="1"><x path="Int"/></user_length>
		<zip_length public="1"><x path="Bool"/></zip_length>
		<push_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Body"/></push_ite>
		<at_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Body"/></at_ite>
		<at_index public="1"><x path="Int"/></at_index>
		<invalidate public="1" set="method" line="16604"><f a=""><x path="Void"/></f></invalidate>
		<validate public="1" set="method" line="16598"><f a=""><x path="Void"/></f></validate>
		<modify_test public="1" set="method" line="16593"><f a=""><x path="Void"/></f></modify_test>
		<modified public="1" set="method" line="16588"><f a=""><x path="Void"/></f></modified>
		<valmod public="1" set="method" line="16578"><f a=""><x path="Void"/></f></valmod>
		<reverse_flag public="1"><x path="Bool"/></reverse_flag>
		<dontremove public="1"><x path="Bool"/></dontremove>
		<subber public="1"><f a="">
	<c path="nape.phys.Body"/>
	<x path="Void"/>
</f></subber>
		<post_adder public="1"><f a="">
	<c path="nape.phys.Body"/>
	<x path="Void"/>
</f></post_adder>
		<adder public="1"><f a="">
	<c path="nape.phys.Body"/>
	<x path="Bool"/>
</f></adder>
		<_modifiable public="1"><f a=""><x path="Void"/></f></_modifiable>
		<_validate public="1"><f a=""><x path="Void"/></f></_validate>
		<_invalidate public="1"><f a="">
	<c path="zpp_nape.util.ZPP_BodyList"/>
	<x path="Void"/>
</f></_invalidate>
		<_invalidated public="1"><x path="Bool"/></_invalidated>
		<immutable public="1"><x path="Bool"/></immutable>
		<inner public="1"><c path="zpp_nape.util.ZNPList_ZPP_Body"/></inner>
		<outer public="1"><c path="nape.phys.BodyList"/></outer>
		<new public="1" set="method" line="16613"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_InteractorList" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<internal public="1" line="16627" static="1"><x path="Bool"/></internal>
		<get public="1" set="method" line="16633" static="1"><f a="list:?imm">
	<c path="zpp_nape.util.ZNPList_ZPP_Interactor"/>
	<x path="Bool"/>
	<c path="nape.phys.InteractorList"/>
</f></get>
		<user_length public="1"><x path="Int"/></user_length>
		<zip_length public="1"><x path="Bool"/></zip_length>
		<push_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Interactor"/></push_ite>
		<at_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Interactor"/></at_ite>
		<at_index public="1"><x path="Int"/></at_index>
		<invalidate public="1" set="method" line="16666"><f a=""><x path="Void"/></f></invalidate>
		<validate public="1" set="method" line="16660"><f a=""><x path="Void"/></f></validate>
		<modify_test public="1" set="method" line="16655"><f a=""><x path="Void"/></f></modify_test>
		<modified public="1" set="method" line="16650"><f a=""><x path="Void"/></f></modified>
		<valmod public="1" set="method" line="16640"><f a=""><x path="Void"/></f></valmod>
		<reverse_flag public="1"><x path="Bool"/></reverse_flag>
		<dontremove public="1"><x path="Bool"/></dontremove>
		<subber public="1"><f a="">
	<c path="nape.phys.Interactor"/>
	<x path="Void"/>
</f></subber>
		<post_adder public="1"><f a="">
	<c path="nape.phys.Interactor"/>
	<x path="Void"/>
</f></post_adder>
		<adder public="1"><f a="">
	<c path="nape.phys.Interactor"/>
	<x path="Bool"/>
</f></adder>
		<_modifiable public="1"><f a=""><x path="Void"/></f></_modifiable>
		<_validate public="1"><f a=""><x path="Void"/></f></_validate>
		<_invalidate public="1"><f a="">
	<c path="zpp_nape.util.ZPP_InteractorList"/>
	<x path="Void"/>
</f></_invalidate>
		<_invalidated public="1"><x path="Bool"/></_invalidated>
		<immutable public="1"><x path="Bool"/></immutable>
		<inner public="1"><c path="zpp_nape.util.ZNPList_ZPP_Interactor"/></inner>
		<outer public="1"><c path="nape.phys.InteractorList"/></outer>
		<new public="1" set="method" line="16675"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_CompoundList" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<internal public="1" line="16689" static="1"><x path="Bool"/></internal>
		<get public="1" set="method" line="16695" static="1"><f a="list:?imm">
	<c path="zpp_nape.util.ZNPList_ZPP_Compound"/>
	<x path="Bool"/>
	<c path="nape.phys.CompoundList"/>
</f></get>
		<user_length public="1"><x path="Int"/></user_length>
		<zip_length public="1"><x path="Bool"/></zip_length>
		<push_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Compound"/></push_ite>
		<at_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Compound"/></at_ite>
		<at_index public="1"><x path="Int"/></at_index>
		<invalidate public="1" set="method" line="16728"><f a=""><x path="Void"/></f></invalidate>
		<validate public="1" set="method" line="16722"><f a=""><x path="Void"/></f></validate>
		<modify_test public="1" set="method" line="16717"><f a=""><x path="Void"/></f></modify_test>
		<modified public="1" set="method" line="16712"><f a=""><x path="Void"/></f></modified>
		<valmod public="1" set="method" line="16702"><f a=""><x path="Void"/></f></valmod>
		<reverse_flag public="1"><x path="Bool"/></reverse_flag>
		<dontremove public="1"><x path="Bool"/></dontremove>
		<subber public="1"><f a="">
	<c path="nape.phys.Compound"/>
	<x path="Void"/>
</f></subber>
		<post_adder public="1"><f a="">
	<c path="nape.phys.Compound"/>
	<x path="Void"/>
</f></post_adder>
		<adder public="1"><f a="">
	<c path="nape.phys.Compound"/>
	<x path="Bool"/>
</f></adder>
		<_modifiable public="1"><f a=""><x path="Void"/></f></_modifiable>
		<_validate public="1"><f a=""><x path="Void"/></f></_validate>
		<_invalidate public="1"><f a="">
	<c path="zpp_nape.util.ZPP_CompoundList"/>
	<x path="Void"/>
</f></_invalidate>
		<_invalidated public="1"><x path="Bool"/></_invalidated>
		<immutable public="1"><x path="Bool"/></immutable>
		<inner public="1"><c path="zpp_nape.util.ZNPList_ZPP_Compound"/></inner>
		<outer public="1"><c path="nape.phys.CompoundList"/></outer>
		<new public="1" set="method" line="16737"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_ListenerList" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<internal public="1" line="16751" static="1"><x path="Bool"/></internal>
		<get public="1" set="method" line="16757" static="1"><f a="list:?imm">
	<c path="zpp_nape.util.ZNPList_ZPP_Listener"/>
	<x path="Bool"/>
	<c path="nape.callbacks.ListenerList"/>
</f></get>
		<user_length public="1"><x path="Int"/></user_length>
		<zip_length public="1"><x path="Bool"/></zip_length>
		<push_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Listener"/></push_ite>
		<at_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Listener"/></at_ite>
		<at_index public="1"><x path="Int"/></at_index>
		<invalidate public="1" set="method" line="16790"><f a=""><x path="Void"/></f></invalidate>
		<validate public="1" set="method" line="16784"><f a=""><x path="Void"/></f></validate>
		<modify_test public="1" set="method" line="16779"><f a=""><x path="Void"/></f></modify_test>
		<modified public="1" set="method" line="16774"><f a=""><x path="Void"/></f></modified>
		<valmod public="1" set="method" line="16764"><f a=""><x path="Void"/></f></valmod>
		<reverse_flag public="1"><x path="Bool"/></reverse_flag>
		<dontremove public="1"><x path="Bool"/></dontremove>
		<subber public="1"><f a="">
	<c path="nape.callbacks.Listener"/>
	<x path="Void"/>
</f></subber>
		<post_adder public="1"><f a="">
	<c path="nape.callbacks.Listener"/>
	<x path="Void"/>
</f></post_adder>
		<adder public="1"><f a="">
	<c path="nape.callbacks.Listener"/>
	<x path="Bool"/>
</f></adder>
		<_modifiable public="1"><f a=""><x path="Void"/></f></_modifiable>
		<_validate public="1"><f a=""><x path="Void"/></f></_validate>
		<_invalidate public="1"><f a="">
	<c path="zpp_nape.util.ZPP_ListenerList"/>
	<x path="Void"/>
</f></_invalidate>
		<_invalidated public="1"><x path="Bool"/></_invalidated>
		<immutable public="1"><x path="Bool"/></immutable>
		<inner public="1"><c path="zpp_nape.util.ZNPList_ZPP_Listener"/></inner>
		<outer public="1"><c path="nape.callbacks.ListenerList"/></outer>
		<new public="1" set="method" line="16799"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_CbTypeList" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<internal public="1" line="16813" static="1"><x path="Bool"/></internal>
		<get public="1" set="method" line="16819" static="1"><f a="list:?imm">
	<c path="zpp_nape.util.ZNPList_ZPP_CbType"/>
	<x path="Bool"/>
	<c path="nape.callbacks.CbTypeList"/>
</f></get>
		<user_length public="1"><x path="Int"/></user_length>
		<zip_length public="1"><x path="Bool"/></zip_length>
		<push_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_CbType"/></push_ite>
		<at_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_CbType"/></at_ite>
		<at_index public="1"><x path="Int"/></at_index>
		<invalidate public="1" set="method" line="16852"><f a=""><x path="Void"/></f></invalidate>
		<validate public="1" set="method" line="16846"><f a=""><x path="Void"/></f></validate>
		<modify_test public="1" set="method" line="16841"><f a=""><x path="Void"/></f></modify_test>
		<modified public="1" set="method" line="16836"><f a=""><x path="Void"/></f></modified>
		<valmod public="1" set="method" line="16826"><f a=""><x path="Void"/></f></valmod>
		<reverse_flag public="1"><x path="Bool"/></reverse_flag>
		<dontremove public="1"><x path="Bool"/></dontremove>
		<subber public="1"><f a="">
	<c path="nape.callbacks.CbType"/>
	<x path="Void"/>
</f></subber>
		<post_adder public="1"><f a="">
	<c path="nape.callbacks.CbType"/>
	<x path="Void"/>
</f></post_adder>
		<adder public="1"><f a="">
	<c path="nape.callbacks.CbType"/>
	<x path="Bool"/>
</f></adder>
		<_modifiable public="1"><f a=""><x path="Void"/></f></_modifiable>
		<_validate public="1"><f a=""><x path="Void"/></f></_validate>
		<_invalidate public="1"><f a="">
	<c path="zpp_nape.util.ZPP_CbTypeList"/>
	<x path="Void"/>
</f></_invalidate>
		<_invalidated public="1"><x path="Bool"/></_invalidated>
		<immutable public="1"><x path="Bool"/></immutable>
		<inner public="1"><c path="zpp_nape.util.ZNPList_ZPP_CbType"/></inner>
		<outer public="1"><c path="nape.callbacks.CbTypeList"/></outer>
		<new public="1" set="method" line="16861"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_Vec2List" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<internal public="1" line="16875" static="1"><x path="Bool"/></internal>
		<get public="1" set="method" line="16881" static="1"><f a="list:?imm">
	<c path="zpp_nape.util.ZNPList_ZPP_Vec2"/>
	<x path="Bool"/>
	<c path="nape.geom.Vec2List"/>
</f></get>
		<user_length public="1"><x path="Int"/></user_length>
		<zip_length public="1"><x path="Bool"/></zip_length>
		<push_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Vec2"/></push_ite>
		<at_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Vec2"/></at_ite>
		<at_index public="1"><x path="Int"/></at_index>
		<invalidate public="1" set="method" line="16914"><f a=""><x path="Void"/></f></invalidate>
		<validate public="1" set="method" line="16908"><f a=""><x path="Void"/></f></validate>
		<modify_test public="1" set="method" line="16903"><f a=""><x path="Void"/></f></modify_test>
		<modified public="1" set="method" line="16898"><f a=""><x path="Void"/></f></modified>
		<valmod public="1" set="method" line="16888"><f a=""><x path="Void"/></f></valmod>
		<reverse_flag public="1"><x path="Bool"/></reverse_flag>
		<dontremove public="1"><x path="Bool"/></dontremove>
		<subber public="1"><f a="">
	<c path="nape.geom.Vec2"/>
	<x path="Void"/>
</f></subber>
		<post_adder public="1"><f a="">
	<c path="nape.geom.Vec2"/>
	<x path="Void"/>
</f></post_adder>
		<adder public="1"><f a="">
	<c path="nape.geom.Vec2"/>
	<x path="Bool"/>
</f></adder>
		<_modifiable public="1"><f a=""><x path="Void"/></f></_modifiable>
		<_validate public="1"><f a=""><x path="Void"/></f></_validate>
		<_invalidate public="1"><f a="">
	<c path="zpp_nape.util.ZPP_Vec2List"/>
	<x path="Void"/>
</f></_invalidate>
		<_invalidated public="1"><x path="Bool"/></_invalidated>
		<immutable public="1"><x path="Bool"/></immutable>
		<inner public="1"><c path="zpp_nape.util.ZNPList_ZPP_Vec2"/></inner>
		<outer public="1"><c path="nape.geom.Vec2List"/></outer>
		<new public="1" set="method" line="16923"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_GeomPolyList" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<internal public="1" line="16937" static="1"><x path="Bool"/></internal>
		<get public="1" set="method" line="16943" static="1"><f a="list:?imm">
	<c path="zpp_nape.util.ZNPList_ZPP_GeomPoly"/>
	<x path="Bool"/>
	<c path="nape.geom.GeomPolyList"/>
</f></get>
		<user_length public="1"><x path="Int"/></user_length>
		<zip_length public="1"><x path="Bool"/></zip_length>
		<push_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_GeomPoly"/></push_ite>
		<at_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_GeomPoly"/></at_ite>
		<at_index public="1"><x path="Int"/></at_index>
		<invalidate public="1" set="method" line="16976"><f a=""><x path="Void"/></f></invalidate>
		<validate public="1" set="method" line="16970"><f a=""><x path="Void"/></f></validate>
		<modify_test public="1" set="method" line="16965"><f a=""><x path="Void"/></f></modify_test>
		<modified public="1" set="method" line="16960"><f a=""><x path="Void"/></f></modified>
		<valmod public="1" set="method" line="16950"><f a=""><x path="Void"/></f></valmod>
		<reverse_flag public="1"><x path="Bool"/></reverse_flag>
		<dontremove public="1"><x path="Bool"/></dontremove>
		<subber public="1"><f a="">
	<c path="nape.geom.GeomPoly"/>
	<x path="Void"/>
</f></subber>
		<post_adder public="1"><f a="">
	<c path="nape.geom.GeomPoly"/>
	<x path="Void"/>
</f></post_adder>
		<adder public="1"><f a="">
	<c path="nape.geom.GeomPoly"/>
	<x path="Bool"/>
</f></adder>
		<_modifiable public="1"><f a=""><x path="Void"/></f></_modifiable>
		<_validate public="1"><f a=""><x path="Void"/></f></_validate>
		<_invalidate public="1"><f a="">
	<c path="zpp_nape.util.ZPP_GeomPolyList"/>
	<x path="Void"/>
</f></_invalidate>
		<_invalidated public="1"><x path="Bool"/></_invalidated>
		<immutable public="1"><x path="Bool"/></immutable>
		<inner public="1"><c path="zpp_nape.util.ZNPList_ZPP_GeomPoly"/></inner>
		<outer public="1"><c path="nape.geom.GeomPolyList"/></outer>
		<new public="1" set="method" line="16985"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_RayResultList" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<internal public="1" line="16999" static="1"><x path="Bool"/></internal>
		<get public="1" set="method" line="17005" static="1"><f a="list:?imm">
	<c path="zpp_nape.util.ZNPList_RayResult"/>
	<x path="Bool"/>
	<c path="nape.geom.RayResultList"/>
</f></get>
		<user_length public="1"><x path="Int"/></user_length>
		<zip_length public="1"><x path="Bool"/></zip_length>
		<push_ite public="1"><c path="zpp_nape.util.ZNPNode_RayResult"/></push_ite>
		<at_ite public="1"><c path="zpp_nape.util.ZNPNode_RayResult"/></at_ite>
		<at_index public="1"><x path="Int"/></at_index>
		<invalidate public="1" set="method" line="17038"><f a=""><x path="Void"/></f></invalidate>
		<validate public="1" set="method" line="17032"><f a=""><x path="Void"/></f></validate>
		<modify_test public="1" set="method" line="17027"><f a=""><x path="Void"/></f></modify_test>
		<modified public="1" set="method" line="17022"><f a=""><x path="Void"/></f></modified>
		<valmod public="1" set="method" line="17012"><f a=""><x path="Void"/></f></valmod>
		<reverse_flag public="1"><x path="Bool"/></reverse_flag>
		<dontremove public="1"><x path="Bool"/></dontremove>
		<subber public="1"><f a="">
	<c path="nape.geom.RayResult"/>
	<x path="Void"/>
</f></subber>
		<post_adder public="1"><f a="">
	<c path="nape.geom.RayResult"/>
	<x path="Void"/>
</f></post_adder>
		<adder public="1"><f a="">
	<c path="nape.geom.RayResult"/>
	<x path="Bool"/>
</f></adder>
		<_modifiable public="1"><f a=""><x path="Void"/></f></_modifiable>
		<_validate public="1"><f a=""><x path="Void"/></f></_validate>
		<_invalidate public="1"><f a="">
	<c path="zpp_nape.util.ZPP_RayResultList"/>
	<x path="Void"/>
</f></_invalidate>
		<_invalidated public="1"><x path="Bool"/></_invalidated>
		<immutable public="1"><x path="Bool"/></immutable>
		<inner public="1"><c path="zpp_nape.util.ZNPList_RayResult"/></inner>
		<outer public="1"><c path="nape.geom.RayResultList"/></outer>
		<new public="1" set="method" line="17047"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_ConvexResultList" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<internal public="1" line="17061" static="1"><x path="Bool"/></internal>
		<get public="1" set="method" line="17067" static="1"><f a="list:?imm">
	<c path="zpp_nape.util.ZNPList_ConvexResult"/>
	<x path="Bool"/>
	<c path="nape.geom.ConvexResultList"/>
</f></get>
		<user_length public="1"><x path="Int"/></user_length>
		<zip_length public="1"><x path="Bool"/></zip_length>
		<push_ite public="1"><c path="zpp_nape.util.ZNPNode_ConvexResult"/></push_ite>
		<at_ite public="1"><c path="zpp_nape.util.ZNPNode_ConvexResult"/></at_ite>
		<at_index public="1"><x path="Int"/></at_index>
		<invalidate public="1" set="method" line="17100"><f a=""><x path="Void"/></f></invalidate>
		<validate public="1" set="method" line="17094"><f a=""><x path="Void"/></f></validate>
		<modify_test public="1" set="method" line="17089"><f a=""><x path="Void"/></f></modify_test>
		<modified public="1" set="method" line="17084"><f a=""><x path="Void"/></f></modified>
		<valmod public="1" set="method" line="17074"><f a=""><x path="Void"/></f></valmod>
		<reverse_flag public="1"><x path="Bool"/></reverse_flag>
		<dontremove public="1"><x path="Bool"/></dontremove>
		<subber public="1"><f a="">
	<c path="nape.geom.ConvexResult"/>
	<x path="Void"/>
</f></subber>
		<post_adder public="1"><f a="">
	<c path="nape.geom.ConvexResult"/>
	<x path="Void"/>
</f></post_adder>
		<adder public="1"><f a="">
	<c path="nape.geom.ConvexResult"/>
	<x path="Bool"/>
</f></adder>
		<_modifiable public="1"><f a=""><x path="Void"/></f></_modifiable>
		<_validate public="1"><f a=""><x path="Void"/></f></_validate>
		<_invalidate public="1"><f a="">
	<c path="zpp_nape.util.ZPP_ConvexResultList"/>
	<x path="Void"/>
</f></_invalidate>
		<_invalidated public="1"><x path="Bool"/></_invalidated>
		<immutable public="1"><x path="Bool"/></immutable>
		<inner public="1"><c path="zpp_nape.util.ZNPList_ConvexResult"/></inner>
		<outer public="1"><c path="nape.geom.ConvexResultList"/></outer>
		<new public="1" set="method" line="17109"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_EdgeList" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<internal public="1" line="17123" static="1"><x path="Bool"/></internal>
		<get public="1" set="method" line="17129" static="1"><f a="list:?imm">
	<c path="zpp_nape.util.ZNPList_ZPP_Edge"/>
	<x path="Bool"/>
	<c path="nape.shape.EdgeList"/>
</f></get>
		<user_length public="1"><x path="Int"/></user_length>
		<zip_length public="1"><x path="Bool"/></zip_length>
		<push_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Edge"/></push_ite>
		<at_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Edge"/></at_ite>
		<at_index public="1"><x path="Int"/></at_index>
		<invalidate public="1" set="method" line="17162"><f a=""><x path="Void"/></f></invalidate>
		<validate public="1" set="method" line="17156"><f a=""><x path="Void"/></f></validate>
		<modify_test public="1" set="method" line="17151"><f a=""><x path="Void"/></f></modify_test>
		<modified public="1" set="method" line="17146"><f a=""><x path="Void"/></f></modified>
		<valmod public="1" set="method" line="17136"><f a=""><x path="Void"/></f></valmod>
		<reverse_flag public="1"><x path="Bool"/></reverse_flag>
		<dontremove public="1"><x path="Bool"/></dontremove>
		<subber public="1"><f a="">
	<c path="nape.shape.Edge"/>
	<x path="Void"/>
</f></subber>
		<post_adder public="1"><f a="">
	<c path="nape.shape.Edge"/>
	<x path="Void"/>
</f></post_adder>
		<adder public="1"><f a="">
	<c path="nape.shape.Edge"/>
	<x path="Bool"/>
</f></adder>
		<_modifiable public="1"><f a=""><x path="Void"/></f></_modifiable>
		<_validate public="1"><f a=""><x path="Void"/></f></_validate>
		<_invalidate public="1"><f a="">
	<c path="zpp_nape.util.ZPP_EdgeList"/>
	<x path="Void"/>
</f></_invalidate>
		<_invalidated public="1"><x path="Bool"/></_invalidated>
		<immutable public="1"><x path="Bool"/></immutable>
		<inner public="1"><c path="zpp_nape.util.ZNPList_ZPP_Edge"/></inner>
		<outer public="1"><c path="nape.shape.EdgeList"/></outer>
		<new public="1" set="method" line="17171"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_ShapeList" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<internal public="1" line="17185" static="1"><x path="Bool"/></internal>
		<get public="1" set="method" line="17191" static="1"><f a="list:?imm">
	<c path="zpp_nape.util.ZNPList_ZPP_Shape"/>
	<x path="Bool"/>
	<c path="nape.shape.ShapeList"/>
</f></get>
		<user_length public="1"><x path="Int"/></user_length>
		<zip_length public="1"><x path="Bool"/></zip_length>
		<push_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Shape"/></push_ite>
		<at_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Shape"/></at_ite>
		<at_index public="1"><x path="Int"/></at_index>
		<invalidate public="1" set="method" line="17224"><f a=""><x path="Void"/></f></invalidate>
		<validate public="1" set="method" line="17218"><f a=""><x path="Void"/></f></validate>
		<modify_test public="1" set="method" line="17213"><f a=""><x path="Void"/></f></modify_test>
		<modified public="1" set="method" line="17208"><f a=""><x path="Void"/></f></modified>
		<valmod public="1" set="method" line="17198"><f a=""><x path="Void"/></f></valmod>
		<reverse_flag public="1"><x path="Bool"/></reverse_flag>
		<dontremove public="1"><x path="Bool"/></dontremove>
		<subber public="1"><f a="">
	<c path="nape.shape.Shape"/>
	<x path="Void"/>
</f></subber>
		<post_adder public="1"><f a="">
	<c path="nape.shape.Shape"/>
	<x path="Void"/>
</f></post_adder>
		<adder public="1"><f a="">
	<c path="nape.shape.Shape"/>
	<x path="Bool"/>
</f></adder>
		<_modifiable public="1"><f a=""><x path="Void"/></f></_modifiable>
		<_validate public="1"><f a=""><x path="Void"/></f></_validate>
		<_invalidate public="1"><f a="">
	<c path="zpp_nape.util.ZPP_ShapeList"/>
	<x path="Void"/>
</f></_invalidate>
		<_invalidated public="1"><x path="Bool"/></_invalidated>
		<immutable public="1"><x path="Bool"/></immutable>
		<inner public="1"><c path="zpp_nape.util.ZNPList_ZPP_Shape"/></inner>
		<outer public="1"><c path="nape.shape.ShapeList"/></outer>
		<new public="1" set="method" line="17233"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_InteractionGroupList" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<internal public="1" line="17247" static="1"><x path="Bool"/></internal>
		<get public="1" set="method" line="17253" static="1"><f a="list:?imm">
	<c path="zpp_nape.util.ZNPList_ZPP_InteractionGroup"/>
	<x path="Bool"/>
	<c path="nape.dynamics.InteractionGroupList"/>
</f></get>
		<user_length public="1"><x path="Int"/></user_length>
		<zip_length public="1"><x path="Bool"/></zip_length>
		<push_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_InteractionGroup"/></push_ite>
		<at_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_InteractionGroup"/></at_ite>
		<at_index public="1"><x path="Int"/></at_index>
		<invalidate public="1" set="method" line="17286"><f a=""><x path="Void"/></f></invalidate>
		<validate public="1" set="method" line="17280"><f a=""><x path="Void"/></f></validate>
		<modify_test public="1" set="method" line="17275"><f a=""><x path="Void"/></f></modify_test>
		<modified public="1" set="method" line="17270"><f a=""><x path="Void"/></f></modified>
		<valmod public="1" set="method" line="17260"><f a=""><x path="Void"/></f></valmod>
		<reverse_flag public="1"><x path="Bool"/></reverse_flag>
		<dontremove public="1"><x path="Bool"/></dontremove>
		<subber public="1"><f a="">
	<c path="nape.dynamics.InteractionGroup"/>
	<x path="Void"/>
</f></subber>
		<post_adder public="1"><f a="">
	<c path="nape.dynamics.InteractionGroup"/>
	<x path="Void"/>
</f></post_adder>
		<adder public="1"><f a="">
	<c path="nape.dynamics.InteractionGroup"/>
	<x path="Bool"/>
</f></adder>
		<_modifiable public="1"><f a=""><x path="Void"/></f></_modifiable>
		<_validate public="1"><f a=""><x path="Void"/></f></_validate>
		<_invalidate public="1"><f a="">
	<c path="zpp_nape.util.ZPP_InteractionGroupList"/>
	<x path="Void"/>
</f></_invalidate>
		<_invalidated public="1"><x path="Bool"/></_invalidated>
		<immutable public="1"><x path="Bool"/></immutable>
		<inner public="1"><c path="zpp_nape.util.ZNPList_ZPP_InteractionGroup"/></inner>
		<outer public="1"><c path="nape.dynamics.InteractionGroupList"/></outer>
		<new public="1" set="method" line="17295"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_ArbiterList" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<internal public="1" line="17309" static="1"><x path="Bool"/></internal>
		<get public="1" set="method" line="17315" static="1"><f a="list:?imm">
	<c path="zpp_nape.util.ZNPList_ZPP_Arbiter"/>
	<x path="Bool"/>
	<c path="nape.dynamics.ArbiterList"/>
</f></get>
		<user_length public="1"><x path="Int"/></user_length>
		<zip_length public="1"><x path="Bool"/></zip_length>
		<push_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Arbiter"/></push_ite>
		<at_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Arbiter"/></at_ite>
		<at_index public="1"><x path="Int"/></at_index>
		<invalidate public="1" set="method" line="17348"><f a=""><x path="Void"/></f></invalidate>
		<validate public="1" set="method" line="17342"><f a=""><x path="Void"/></f></validate>
		<modify_test public="1" set="method" line="17337"><f a=""><x path="Void"/></f></modify_test>
		<modified public="1" set="method" line="17332"><f a=""><x path="Void"/></f></modified>
		<valmod public="1" set="method" line="17322"><f a=""><x path="Void"/></f></valmod>
		<reverse_flag public="1"><x path="Bool"/></reverse_flag>
		<dontremove public="1"><x path="Bool"/></dontremove>
		<subber public="1"><f a="">
	<c path="nape.dynamics.Arbiter"/>
	<x path="Void"/>
</f></subber>
		<post_adder public="1"><f a="">
	<c path="nape.dynamics.Arbiter"/>
	<x path="Void"/>
</f></post_adder>
		<adder public="1"><f a="">
	<c path="nape.dynamics.Arbiter"/>
	<x path="Bool"/>
</f></adder>
		<_modifiable public="1"><f a=""><x path="Void"/></f></_modifiable>
		<_validate public="1"><f a=""><x path="Void"/></f></_validate>
		<_invalidate public="1"><f a="">
	<c path="zpp_nape.util.ZPP_ArbiterList"/>
	<x path="Void"/>
</f></_invalidate>
		<_invalidated public="1"><x path="Bool"/></_invalidated>
		<immutable public="1"><x path="Bool"/></immutable>
		<inner public="1"><c path="zpp_nape.util.ZNPList_ZPP_Arbiter"/></inner>
		<outer public="1"><c path="nape.dynamics.ArbiterList"/></outer>
		<new public="1" set="method" line="17357"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_ContactList" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<internal public="1" line="17371" static="1"><x path="Bool"/></internal>
		<get public="1" set="method" line="17377" static="1"><f a="list:?imm">
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
	<x path="Bool"/>
	<c path="nape.dynamics.ContactList"/>
</f></get>
		<user_length public="1"><x path="Int"/></user_length>
		<zip_length public="1"><x path="Bool"/></zip_length>
		<push_ite public="1"><c path="zpp_nape.dynamics.ZPP_Contact"/></push_ite>
		<at_ite public="1"><c path="zpp_nape.dynamics.ZPP_Contact"/></at_ite>
		<at_index public="1"><x path="Int"/></at_index>
		<invalidate public="1" set="method" line="17410"><f a=""><x path="Void"/></f></invalidate>
		<validate public="1" set="method" line="17404"><f a=""><x path="Void"/></f></validate>
		<modify_test public="1" set="method" line="17399"><f a=""><x path="Void"/></f></modify_test>
		<modified public="1" set="method" line="17394"><f a=""><x path="Void"/></f></modified>
		<valmod public="1" set="method" line="17384"><f a=""><x path="Void"/></f></valmod>
		<reverse_flag public="1"><x path="Bool"/></reverse_flag>
		<dontremove public="1"><x path="Bool"/></dontremove>
		<subber public="1"><f a="">
	<c path="nape.dynamics.Contact"/>
	<x path="Void"/>
</f></subber>
		<post_adder public="1"><f a="">
	<c path="nape.dynamics.Contact"/>
	<x path="Void"/>
</f></post_adder>
		<adder public="1"><f a="">
	<c path="nape.dynamics.Contact"/>
	<x path="Bool"/>
</f></adder>
		<_modifiable public="1"><f a=""><x path="Void"/></f></_modifiable>
		<_validate public="1"><f a=""><x path="Void"/></f></_validate>
		<_invalidate public="1"><f a="">
	<c path="zpp_nape.util.ZPP_ContactList"/>
	<x path="Void"/>
</f></_invalidate>
		<_invalidated public="1"><x path="Bool"/></_invalidated>
		<immutable public="1"><x path="Bool"/></immutable>
		<inner public="1"><c path="zpp_nape.dynamics.ZPP_Contact"/></inner>
		<outer public="1"><c path="nape.dynamics.ContactList"/></outer>
		<new public="1" set="method" line="17419"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_Math" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Math.hx" module="zpp_nape.util.Math">
		<sqrt public="1" get="inline" set="null" line="179" static="1"><f a="x">
	<x path="Float"/>
	<x path="Float"/>
</f></sqrt>
		<invsqrt public="1" get="inline" set="null" line="193" static="1"><f a="x">
	<x path="Float"/>
	<x path="Float"/>
</f></invsqrt>
		<sqr public="1" get="inline" set="null" line="210" static="1"><f a="x">
	<x path="Float"/>
	<x path="Float"/>
</f></sqr>
		<clamp2 public="1" get="inline" set="null" line="222" static="1"><f a="x:a">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></clamp2>
		<clamp public="1" get="inline" set="null" line="234" static="1"><f a="x:a:b">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></clamp>
	</class>
	<class path="zpp_nape.util.ZPP_PubPool" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/Pool.hx" module="zpp_nape.util.Pool">
		<poolGeomPoly public="1" line="176" static="1"><c path="nape.geom.GeomPoly"/></poolGeomPoly>
		<nextGeomPoly public="1" line="178" static="1"><c path="nape.geom.GeomPoly"/></nextGeomPoly>
		<poolVec2 public="1" line="180" static="1"><c path="nape.geom.Vec2"/></poolVec2>
		<nextVec2 public="1" line="182" static="1"><c path="nape.geom.Vec2"/></nextVec2>
		<poolVec3 public="1" line="184" static="1"><c path="nape.geom.Vec3"/></poolVec3>
		<nextVec3 public="1" line="186" static="1"><c path="nape.geom.Vec3"/></nextVec3>
	</class>
	<class path="zpp_nape.util.ZPP_Set_ZPP_Body" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/RBTree.hx" module="zpp_nape.util.RBTree">
		<zpp_pool public="1" line="176" static="1"><c path="zpp_nape.util.ZPP_Set_ZPP_Body"/></zpp_pool>
		<insert public="1" set="method" line="997"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_Body"/>
</f></insert>
		<try_insert public="1" set="method" line="905"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_Body"/>
</f></try_insert>
		<try_insert_bool public="1" set="method" line="813"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Bool"/>
</f></try_insert_bool>
		<__fix_dbl_red public="1" set="method" line="724"><f a="x">
	<c path="zpp_nape.util.ZPP_Set_ZPP_Body"/>
	<x path="Void"/>
</f></__fix_dbl_red>
		<__fix_neg_red public="1" set="method" line="657"><f a="negred">
	<c path="zpp_nape.util.ZPP_Set_ZPP_Body"/>
	<x path="Void"/>
</f></__fix_neg_red>
		<clear_node get="inline" set="null" line="622"><f a="node:lambda">
	<c path="zpp_nape.util.ZPP_Set_ZPP_Body"/>
	<f a="">
		<c path="zpp_nape.phys.ZPP_Body"/>
		<x path="Void"/>
	</f>
	<c path="zpp_nape.util.ZPP_Set_ZPP_Body"/>
</f></clear_node>
		<clear_with public="1" get="inline" set="null" line="613"><f a="lambda">
	<f a="">
		<c path="zpp_nape.phys.ZPP_Body"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></clear_with>
		<clear public="1" set="method" line="609"><f a=""><x path="Void"/></f></clear>
		<remove_node public="1" set="method" line="489"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_Body"/>
	<x path="Void"/>
</f></remove_node>
		<predecessor public="1" set="method" line="477"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="zpp_nape.phys.ZPP_Body"/>
</f></predecessor>
		<successor public="1" set="method" line="465"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="zpp_nape.phys.ZPP_Body"/>
</f></successor>
		<predecessor_node public="1" set="method" line="442"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_Body"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_Body"/>
</f></predecessor_node>
		<successor_node public="1" set="method" line="419"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_Body"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_Body"/>
</f></successor_node>
		<remove public="1" set="method" line="407"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Void"/>
</f></remove>
		<pop_front public="1" set="method" line="392"><f a=""><c path="zpp_nape.phys.ZPP_Body"/></f></pop_front>
		<first public="1" set="method" line="379"><f a=""><c path="zpp_nape.phys.ZPP_Body"/></f></first>
		<lower_bound public="1" set="method" line="342"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="zpp_nape.phys.ZPP_Body"/>
</f></lower_bound>
		<find_weak public="1" set="method" line="333"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_Body"/>
</f></find_weak>
		<has_weak public="1" set="method" line="330"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Bool"/>
</f></has_weak>
		<find public="1" set="method" line="322"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_Body"/>
</f></find>
		<has public="1" set="method" line="319"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Bool"/>
</f></has>
		<size public="1" set="method" line="289"><f a=""><x path="Int"/></f></size>
		<singular public="1" set="method" line="286"><f a=""><x path="Bool"/></f></singular>
		<empty public="1" set="method" line="283"><f a=""><x path="Bool"/></f></empty>
		<verify public="1" set="method" line="218"><f a=""><x path="Bool"/></f></verify>
		<colour public="1"><x path="Int"/></colour>
		<parent public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_Body"/></parent>
		<next public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_Body"/></next>
		<prev public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_Body"/></prev>
		<data public="1"><c path="zpp_nape.phys.ZPP_Body"/></data>
		<swapped public="1"><f a=":">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Void"/>
</f></swapped>
		<lt public="1"><f a=":">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Bool"/>
</f></lt>
		<alloc public="1" get="inline" set="null" line="209"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="202"><f a=""><x path="Void"/></f></free>
		<new public="1" set="method" line="217"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_Set_ZPP_CbSetPair" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/RBTree.hx" module="zpp_nape.util.RBTree">
		<zpp_pool public="1" line="1065" static="1"><c path="zpp_nape.util.ZPP_Set_ZPP_CbSetPair"/></zpp_pool>
		<insert public="1" set="method" line="1886"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSetPair"/>
</f></insert>
		<try_insert public="1" set="method" line="1794"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSetPair"/>
</f></try_insert>
		<try_insert_bool public="1" set="method" line="1702"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<x path="Bool"/>
</f></try_insert_bool>
		<__fix_dbl_red public="1" set="method" line="1613"><f a="x">
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSetPair"/>
	<x path="Void"/>
</f></__fix_dbl_red>
		<__fix_neg_red public="1" set="method" line="1546"><f a="negred">
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSetPair"/>
	<x path="Void"/>
</f></__fix_neg_red>
		<clear_node get="inline" set="null" line="1511"><f a="node:lambda">
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSetPair"/>
	<f a="">
		<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
		<x path="Void"/>
	</f>
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSetPair"/>
</f></clear_node>
		<clear_with public="1" get="inline" set="null" line="1502"><f a="lambda">
	<f a="">
		<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></clear_with>
		<clear public="1" set="method" line="1498"><f a=""><x path="Void"/></f></clear>
		<remove_node public="1" set="method" line="1378"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSetPair"/>
	<x path="Void"/>
</f></remove_node>
		<predecessor public="1" set="method" line="1366"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
</f></predecessor>
		<successor public="1" set="method" line="1354"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
</f></successor>
		<predecessor_node public="1" set="method" line="1331"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSetPair"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSetPair"/>
</f></predecessor_node>
		<successor_node public="1" set="method" line="1308"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSetPair"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSetPair"/>
</f></successor_node>
		<remove public="1" set="method" line="1296"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<x path="Void"/>
</f></remove>
		<pop_front public="1" set="method" line="1281"><f a=""><c path="zpp_nape.callbacks.ZPP_CbSetPair"/></f></pop_front>
		<first public="1" set="method" line="1268"><f a=""><c path="zpp_nape.callbacks.ZPP_CbSetPair"/></f></first>
		<lower_bound public="1" set="method" line="1231"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
</f></lower_bound>
		<find_weak public="1" set="method" line="1222"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSetPair"/>
</f></find_weak>
		<has_weak public="1" set="method" line="1219"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<x path="Bool"/>
</f></has_weak>
		<find public="1" set="method" line="1211"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSetPair"/>
</f></find>
		<has public="1" set="method" line="1208"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<x path="Bool"/>
</f></has>
		<size public="1" set="method" line="1178"><f a=""><x path="Int"/></f></size>
		<singular public="1" set="method" line="1175"><f a=""><x path="Bool"/></f></singular>
		<empty public="1" set="method" line="1172"><f a=""><x path="Bool"/></f></empty>
		<verify public="1" set="method" line="1107"><f a=""><x path="Bool"/></f></verify>
		<colour public="1"><x path="Int"/></colour>
		<parent public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_CbSetPair"/></parent>
		<next public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_CbSetPair"/></next>
		<prev public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_CbSetPair"/></prev>
		<data public="1"><c path="zpp_nape.callbacks.ZPP_CbSetPair"/></data>
		<swapped public="1"><f a=":">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<x path="Void"/>
</f></swapped>
		<lt public="1"><f a=":">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<x path="Bool"/>
</f></lt>
		<alloc public="1" get="inline" set="null" line="1098"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="1091"><f a=""><x path="Void"/></f></free>
		<new public="1" set="method" line="1106"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_Set_ZPP_PartitionPair" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/RBTree.hx" module="zpp_nape.util.RBTree">
		<zpp_pool public="1" line="1954" static="1"><c path="zpp_nape.util.ZPP_Set_ZPP_PartitionPair"/></zpp_pool>
		<insert public="1" set="method" line="2775"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionPair"/>
</f></insert>
		<try_insert public="1" set="method" line="2683"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionPair"/>
</f></try_insert>
		<try_insert_bool public="1" set="method" line="2591"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<x path="Bool"/>
</f></try_insert_bool>
		<__fix_dbl_red public="1" set="method" line="2502"><f a="x">
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionPair"/>
	<x path="Void"/>
</f></__fix_dbl_red>
		<__fix_neg_red public="1" set="method" line="2435"><f a="negred">
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionPair"/>
	<x path="Void"/>
</f></__fix_neg_red>
		<clear_node get="inline" set="null" line="2400"><f a="node:lambda">
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionPair"/>
	<f a="">
		<c path="zpp_nape.geom.ZPP_PartitionPair"/>
		<x path="Void"/>
	</f>
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionPair"/>
</f></clear_node>
		<clear_with public="1" get="inline" set="null" line="2391"><f a="lambda">
	<f a="">
		<c path="zpp_nape.geom.ZPP_PartitionPair"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></clear_with>
		<clear public="1" set="method" line="2387"><f a=""><x path="Void"/></f></clear>
		<remove_node public="1" set="method" line="2267"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionPair"/>
	<x path="Void"/>
</f></remove_node>
		<predecessor public="1" set="method" line="2255"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
</f></predecessor>
		<successor public="1" set="method" line="2243"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
</f></successor>
		<predecessor_node public="1" set="method" line="2220"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionPair"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionPair"/>
</f></predecessor_node>
		<successor_node public="1" set="method" line="2197"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionPair"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionPair"/>
</f></successor_node>
		<remove public="1" set="method" line="2185"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<x path="Void"/>
</f></remove>
		<pop_front public="1" set="method" line="2170"><f a=""><c path="zpp_nape.geom.ZPP_PartitionPair"/></f></pop_front>
		<first public="1" set="method" line="2157"><f a=""><c path="zpp_nape.geom.ZPP_PartitionPair"/></f></first>
		<lower_bound public="1" set="method" line="2120"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
</f></lower_bound>
		<find_weak public="1" set="method" line="2111"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionPair"/>
</f></find_weak>
		<has_weak public="1" set="method" line="2108"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<x path="Bool"/>
</f></has_weak>
		<find public="1" set="method" line="2100"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionPair"/>
</f></find>
		<has public="1" set="method" line="2097"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<x path="Bool"/>
</f></has>
		<size public="1" set="method" line="2067"><f a=""><x path="Int"/></f></size>
		<singular public="1" set="method" line="2064"><f a=""><x path="Bool"/></f></singular>
		<empty public="1" set="method" line="2061"><f a=""><x path="Bool"/></f></empty>
		<verify public="1" set="method" line="1996"><f a=""><x path="Bool"/></f></verify>
		<colour public="1"><x path="Int"/></colour>
		<parent public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_PartitionPair"/></parent>
		<next public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_PartitionPair"/></next>
		<prev public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_PartitionPair"/></prev>
		<data public="1"><c path="zpp_nape.geom.ZPP_PartitionPair"/></data>
		<swapped public="1"><f a=":">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<x path="Void"/>
</f></swapped>
		<lt public="1"><f a=":">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<x path="Bool"/>
</f></lt>
		<alloc public="1" get="inline" set="null" line="1987"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="1980"><f a=""><x path="Void"/></f></free>
		<new public="1" set="method" line="1995"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_Set_ZPP_PartitionVertex" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/RBTree.hx" module="zpp_nape.util.RBTree">
		<zpp_pool public="1" line="2843" static="1"><c path="zpp_nape.util.ZPP_Set_ZPP_PartitionVertex"/></zpp_pool>
		<insert public="1" set="method" line="3664"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionVertex"/>
</f></insert>
		<try_insert public="1" set="method" line="3572"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionVertex"/>
</f></try_insert>
		<try_insert_bool public="1" set="method" line="3480"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Bool"/>
</f></try_insert_bool>
		<__fix_dbl_red public="1" set="method" line="3391"><f a="x">
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionVertex"/>
	<x path="Void"/>
</f></__fix_dbl_red>
		<__fix_neg_red public="1" set="method" line="3324"><f a="negred">
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionVertex"/>
	<x path="Void"/>
</f></__fix_neg_red>
		<clear_node get="inline" set="null" line="3289"><f a="node:lambda">
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionVertex"/>
	<f a="">
		<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
		<x path="Void"/>
	</f>
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionVertex"/>
</f></clear_node>
		<clear_with public="1" get="inline" set="null" line="3280"><f a="lambda">
	<f a="">
		<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></clear_with>
		<clear public="1" set="method" line="3276"><f a=""><x path="Void"/></f></clear>
		<remove_node public="1" set="method" line="3156"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionVertex"/>
	<x path="Void"/>
</f></remove_node>
		<predecessor public="1" set="method" line="3144"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
</f></predecessor>
		<successor public="1" set="method" line="3132"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
</f></successor>
		<predecessor_node public="1" set="method" line="3109"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionVertex"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionVertex"/>
</f></predecessor_node>
		<successor_node public="1" set="method" line="3086"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionVertex"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionVertex"/>
</f></successor_node>
		<remove public="1" set="method" line="3074"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Void"/>
</f></remove>
		<pop_front public="1" set="method" line="3059"><f a=""><c path="zpp_nape.geom.ZPP_PartitionVertex"/></f></pop_front>
		<first public="1" set="method" line="3046"><f a=""><c path="zpp_nape.geom.ZPP_PartitionVertex"/></f></first>
		<lower_bound public="1" set="method" line="3009"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
</f></lower_bound>
		<find_weak public="1" set="method" line="3000"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionVertex"/>
</f></find_weak>
		<has_weak public="1" set="method" line="2997"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Bool"/>
</f></has_weak>
		<find public="1" set="method" line="2989"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionVertex"/>
</f></find>
		<has public="1" set="method" line="2986"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Bool"/>
</f></has>
		<size public="1" set="method" line="2956"><f a=""><x path="Int"/></f></size>
		<singular public="1" set="method" line="2953"><f a=""><x path="Bool"/></f></singular>
		<empty public="1" set="method" line="2950"><f a=""><x path="Bool"/></f></empty>
		<verify public="1" set="method" line="2885"><f a=""><x path="Bool"/></f></verify>
		<colour public="1"><x path="Int"/></colour>
		<parent public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_PartitionVertex"/></parent>
		<next public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_PartitionVertex"/></next>
		<prev public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_PartitionVertex"/></prev>
		<data public="1"><c path="zpp_nape.geom.ZPP_PartitionVertex"/></data>
		<swapped public="1"><f a=":">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Void"/>
</f></swapped>
		<lt public="1"><f a=":">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Bool"/>
</f></lt>
		<alloc public="1" get="inline" set="null" line="2876"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="2869"><f a=""><x path="Void"/></f></free>
		<new public="1" set="method" line="2884"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/RBTree.hx" module="zpp_nape.util.RBTree">
		<zpp_pool public="1" line="3732" static="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/></zpp_pool>
		<insert public="1" set="method" line="4553"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/>
</f></insert>
		<try_insert public="1" set="method" line="4461"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/>
</f></try_insert>
		<try_insert_bool public="1" set="method" line="4369"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<x path="Bool"/>
</f></try_insert_bool>
		<__fix_dbl_red public="1" set="method" line="4280"><f a="x">
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/>
	<x path="Void"/>
</f></__fix_dbl_red>
		<__fix_neg_red public="1" set="method" line="4213"><f a="negred">
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/>
	<x path="Void"/>
</f></__fix_neg_red>
		<clear_node get="inline" set="null" line="4178"><f a="node:lambda">
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/>
	<f a="">
		<c path="zpp_nape.geom.ZPP_SimpleVert"/>
		<x path="Void"/>
	</f>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/>
</f></clear_node>
		<clear_with public="1" get="inline" set="null" line="4169"><f a="lambda">
	<f a="">
		<c path="zpp_nape.geom.ZPP_SimpleVert"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></clear_with>
		<clear public="1" set="method" line="4165"><f a=""><x path="Void"/></f></clear>
		<remove_node public="1" set="method" line="4045"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/>
	<x path="Void"/>
</f></remove_node>
		<predecessor public="1" set="method" line="4033"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
</f></predecessor>
		<successor public="1" set="method" line="4021"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
</f></successor>
		<predecessor_node public="1" set="method" line="3998"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/>
</f></predecessor_node>
		<successor_node public="1" set="method" line="3975"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/>
</f></successor_node>
		<remove public="1" set="method" line="3963"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<x path="Void"/>
</f></remove>
		<pop_front public="1" set="method" line="3948"><f a=""><c path="zpp_nape.geom.ZPP_SimpleVert"/></f></pop_front>
		<first public="1" set="method" line="3935"><f a=""><c path="zpp_nape.geom.ZPP_SimpleVert"/></f></first>
		<lower_bound public="1" set="method" line="3898"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
</f></lower_bound>
		<find_weak public="1" set="method" line="3889"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/>
</f></find_weak>
		<has_weak public="1" set="method" line="3886"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<x path="Bool"/>
</f></has_weak>
		<find public="1" set="method" line="3878"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/>
</f></find>
		<has public="1" set="method" line="3875"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<x path="Bool"/>
</f></has>
		<size public="1" set="method" line="3845"><f a=""><x path="Int"/></f></size>
		<singular public="1" set="method" line="3842"><f a=""><x path="Bool"/></f></singular>
		<empty public="1" set="method" line="3839"><f a=""><x path="Bool"/></f></empty>
		<verify public="1" set="method" line="3774"><f a=""><x path="Bool"/></f></verify>
		<colour public="1"><x path="Int"/></colour>
		<parent public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/></parent>
		<next public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/></next>
		<prev public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/></prev>
		<data public="1"><c path="zpp_nape.geom.ZPP_SimpleVert"/></data>
		<swapped public="1"><f a=":">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<x path="Void"/>
</f></swapped>
		<lt public="1"><f a=":">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<x path="Bool"/>
</f></lt>
		<alloc public="1" get="inline" set="null" line="3765"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="3758"><f a=""><x path="Void"/></f></free>
		<new public="1" set="method" line="3773"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_Set_ZPP_SimpleSeg" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/RBTree.hx" module="zpp_nape.util.RBTree">
		<zpp_pool public="1" line="4621" static="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleSeg"/></zpp_pool>
		<insert public="1" set="method" line="5442"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleSeg"/>
</f></insert>
		<try_insert public="1" set="method" line="5350"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleSeg"/>
</f></try_insert>
		<try_insert_bool public="1" set="method" line="5258"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<x path="Bool"/>
</f></try_insert_bool>
		<__fix_dbl_red public="1" set="method" line="5169"><f a="x">
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleSeg"/>
	<x path="Void"/>
</f></__fix_dbl_red>
		<__fix_neg_red public="1" set="method" line="5102"><f a="negred">
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleSeg"/>
	<x path="Void"/>
</f></__fix_neg_red>
		<clear_node get="inline" set="null" line="5067"><f a="node:lambda">
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleSeg"/>
	<f a="">
		<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
		<x path="Void"/>
	</f>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleSeg"/>
</f></clear_node>
		<clear_with public="1" get="inline" set="null" line="5058"><f a="lambda">
	<f a="">
		<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></clear_with>
		<clear public="1" set="method" line="5054"><f a=""><x path="Void"/></f></clear>
		<remove_node public="1" set="method" line="4934"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleSeg"/>
	<x path="Void"/>
</f></remove_node>
		<predecessor public="1" set="method" line="4922"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
</f></predecessor>
		<successor public="1" set="method" line="4910"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
</f></successor>
		<predecessor_node public="1" set="method" line="4887"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleSeg"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleSeg"/>
</f></predecessor_node>
		<successor_node public="1" set="method" line="4864"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleSeg"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleSeg"/>
</f></successor_node>
		<remove public="1" set="method" line="4852"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<x path="Void"/>
</f></remove>
		<pop_front public="1" set="method" line="4837"><f a=""><c path="zpp_nape.geom.ZPP_SimpleSeg"/></f></pop_front>
		<first public="1" set="method" line="4824"><f a=""><c path="zpp_nape.geom.ZPP_SimpleSeg"/></f></first>
		<lower_bound public="1" set="method" line="4787"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
</f></lower_bound>
		<find_weak public="1" set="method" line="4778"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleSeg"/>
</f></find_weak>
		<has_weak public="1" set="method" line="4775"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<x path="Bool"/>
</f></has_weak>
		<find public="1" set="method" line="4767"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleSeg"/>
</f></find>
		<has public="1" set="method" line="4764"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<x path="Bool"/>
</f></has>
		<size public="1" set="method" line="4734"><f a=""><x path="Int"/></f></size>
		<singular public="1" set="method" line="4731"><f a=""><x path="Bool"/></f></singular>
		<empty public="1" set="method" line="4728"><f a=""><x path="Bool"/></f></empty>
		<verify public="1" set="method" line="4663"><f a=""><x path="Bool"/></f></verify>
		<colour public="1"><x path="Int"/></colour>
		<parent public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleSeg"/></parent>
		<next public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleSeg"/></next>
		<prev public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleSeg"/></prev>
		<data public="1"><c path="zpp_nape.geom.ZPP_SimpleSeg"/></data>
		<swapped public="1"><f a=":">
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<x path="Void"/>
</f></swapped>
		<lt public="1"><f a=":">
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<x path="Bool"/>
</f></lt>
		<alloc public="1" get="inline" set="null" line="4654"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="4647"><f a=""><x path="Void"/></f></free>
		<new public="1" set="method" line="4662"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/RBTree.hx" module="zpp_nape.util.RBTree">
		<zpp_pool public="1" line="5510" static="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"/></zpp_pool>
		<insert public="1" set="method" line="6331"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"/>
</f></insert>
		<try_insert public="1" set="method" line="6239"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"/>
</f></try_insert>
		<try_insert_bool public="1" set="method" line="6147"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<x path="Bool"/>
</f></try_insert_bool>
		<__fix_dbl_red public="1" set="method" line="6058"><f a="x">
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"/>
	<x path="Void"/>
</f></__fix_dbl_red>
		<__fix_neg_red public="1" set="method" line="5991"><f a="negred">
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"/>
	<x path="Void"/>
</f></__fix_neg_red>
		<clear_node get="inline" set="null" line="5956"><f a="node:lambda">
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"/>
	<f a="">
		<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
		<x path="Void"/>
	</f>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"/>
</f></clear_node>
		<clear_with public="1" get="inline" set="null" line="5947"><f a="lambda">
	<f a="">
		<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></clear_with>
		<clear public="1" set="method" line="5943"><f a=""><x path="Void"/></f></clear>
		<remove_node public="1" set="method" line="5823"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"/>
	<x path="Void"/>
</f></remove_node>
		<predecessor public="1" set="method" line="5811"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
</f></predecessor>
		<successor public="1" set="method" line="5799"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
</f></successor>
		<predecessor_node public="1" set="method" line="5776"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"/>
</f></predecessor_node>
		<successor_node public="1" set="method" line="5753"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"/>
</f></successor_node>
		<remove public="1" set="method" line="5741"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<x path="Void"/>
</f></remove>
		<pop_front public="1" set="method" line="5726"><f a=""><c path="zpp_nape.geom.ZPP_SimpleEvent"/></f></pop_front>
		<first public="1" set="method" line="5713"><f a=""><c path="zpp_nape.geom.ZPP_SimpleEvent"/></f></first>
		<lower_bound public="1" set="method" line="5676"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
</f></lower_bound>
		<find_weak public="1" set="method" line="5667"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"/>
</f></find_weak>
		<has_weak public="1" set="method" line="5664"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<x path="Bool"/>
</f></has_weak>
		<find public="1" set="method" line="5656"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"/>
</f></find>
		<has public="1" set="method" line="5653"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<x path="Bool"/>
</f></has>
		<size public="1" set="method" line="5623"><f a=""><x path="Int"/></f></size>
		<singular public="1" set="method" line="5620"><f a=""><x path="Bool"/></f></singular>
		<empty public="1" set="method" line="5617"><f a=""><x path="Bool"/></f></empty>
		<verify public="1" set="method" line="5552"><f a=""><x path="Bool"/></f></verify>
		<colour public="1"><x path="Int"/></colour>
		<parent public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"/></parent>
		<next public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"/></next>
		<prev public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"/></prev>
		<data public="1"><c path="zpp_nape.geom.ZPP_SimpleEvent"/></data>
		<swapped public="1"><f a=":">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<x path="Void"/>
</f></swapped>
		<lt public="1"><f a=":">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<x path="Bool"/>
</f></lt>
		<alloc public="1" get="inline" set="null" line="5543"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="5536"><f a=""><x path="Void"/></f></free>
		<new public="1" set="method" line="5551"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_Set_ZPP_CbSet" params="" file="C:\Users\abradley\Documents\Programs\haxe-3.0.0-rc2-win\lib\nape/2,0,9/zpp_nape/util/RBTree.hx" module="zpp_nape.util.RBTree">
		<zpp_pool public="1" line="6399" static="1"><c path="zpp_nape.util.ZPP_Set_ZPP_CbSet"/></zpp_pool>
		<insert public="1" set="method" line="7220"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSet"/>
</f></insert>
		<try_insert public="1" set="method" line="7128"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSet"/>
</f></try_insert>
		<try_insert_bool public="1" set="method" line="7036"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<x path="Bool"/>
</f></try_insert_bool>
		<__fix_dbl_red public="1" set="method" line="6947"><f a="x">
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSet"/>
	<x path="Void"/>
</f></__fix_dbl_red>
		<__fix_neg_red public="1" set="method" line="6880"><f a="negred">
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSet"/>
	<x path="Void"/>
</f></__fix_neg_red>
		<clear_node get="inline" set="null" line="6845"><f a="node:lambda">
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSet"/>
	<f a="">
		<c path="zpp_nape.callbacks.ZPP_CbSet"/>
		<x path="Void"/>
	</f>
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSet"/>
</f></clear_node>
		<clear_with public="1" get="inline" set="null" line="6836"><f a="lambda">
	<f a="">
		<c path="zpp_nape.callbacks.ZPP_CbSet"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></clear_with>
		<clear public="1" set="method" line="6832"><f a=""><x path="Void"/></f></clear>
		<remove_node public="1" set="method" line="6712"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSet"/>
	<x path="Void"/>
</f></remove_node>
		<predecessor public="1" set="method" line="6700"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
</f></predecessor>
		<successor public="1" set="method" line="6688"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
</f></successor>
		<predecessor_node public="1" set="method" line="6665"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSet"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSet"/>
</f></predecessor_node>
		<successor_node public="1" set="method" line="6642"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSet"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSet"/>
</f></successor_node>
		<remove public="1" set="method" line="6630"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<x path="Void"/>
</f></remove>
		<pop_front public="1" set="method" line="6615"><f a=""><c path="zpp_nape.callbacks.ZPP_CbSet"/></f></pop_front>
		<first public="1" set="method" line="6602"><f a=""><c path="zpp_nape.callbacks.ZPP_CbSet"/></f></first>
		<lower_bound public="1" set="method" line="6565"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
</f></lower_bound>
		<find_weak public="1" set="method" line="6556"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSet"/>
</f></find_weak>
		<has_weak public="1" set="method" line="6553"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<x path="Bool"/>
</f></has_weak>
		<find public="1" set="method" line="6545"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSet"/>
</f></find>
		<has public="1" set="method" line="6542"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<x path="Bool"/>
</f></has>
		<size public="1" set="method" line="6512"><f a=""><x path="Int"/></f></size>
		<singular public="1" set="method" line="6509"><f a=""><x path="Bool"/></f></singular>
		<empty public="1" set="method" line="6506"><f a=""><x path="Bool"/></f></empty>
		<verify public="1" set="method" line="6441"><f a=""><x path="Bool"/></f></verify>
		<colour public="1"><x path="Int"/></colour>
		<parent public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_CbSet"/></parent>
		<next public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_CbSet"/></next>
		<prev public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_CbSet"/></prev>
		<data public="1"><c path="zpp_nape.callbacks.ZPP_CbSet"/></data>
		<swapped public="1"><f a=":">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<x path="Void"/>
</f></swapped>
		<lt public="1"><f a=":">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<x path="Bool"/>
</f></lt>
		<alloc public="1" get="inline" set="null" line="6432"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="6425"><f a=""><x path="Void"/></f></free>
		<new public="1" set="method" line="6440"><f a=""><x path="Void"/></f></new>
	</class>
</haxe>